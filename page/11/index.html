<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="clear 航">
<meta property="og:type" content="website">
<meta property="og:title" content="why are you so happy">
<meta property="og:url" content="https://skydh.github.io/page/11/index.html">
<meta property="og:site_name" content="why are you so happy">
<meta property="og:description" content="clear 航">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="why are you so happy">
<meta name="twitter:description" content="clear 航">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://skydh.github.io/page/11/"/>





  <title>why are you so happy</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">why are you so happy</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">clear 航</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://skydh.github.io/2018/02/24/spring ioc/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="董航">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="why are you so happy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/24/spring ioc/" itemprop="url">spring ioc浅析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-24T17:03:22+08:00">
                2018-02-24
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="什么是ioc"><a href="#什么是ioc" class="headerlink" title="什么是ioc"></a>什么是ioc</h2><p>　　IOC是spring这个轻量级框架的核心内容，中文叫做控制反转。也叫作依赖注入，这里我们将其看作为一个概念。普通获取类对象时是我们主动获取也就是主动去new。但是IOC则是让我们不用去new这个对象直接去获取，因为我们想要得到这个对象也是调用这个对象所对应的服务。无论这个对象时容器给我们的还是我们自己new的都行。容器给我们的话就会方便很多，也利于管理和维护。</p>
<h2 id="3种注入方法"><a href="#3种注入方法" class="headerlink" title="3种注入方法"></a>3种注入方法</h2><p>　　构造方法注入：就是被注入对象可以通过在其构造方法中声明依赖对象的参数列表让spring容器知道它需要哪些依赖对象。<br>　　setter方法注入，通过其对应的setter方法来注入，更加灵活点。<br>　　接口注入：被注入对象想要spring为其注入依赖对象必须要实现某个接口，这个接口提供一个方法用来为其注入依赖对象。</p>
<h2 id="IOC-service-privider"><a href="#IOC-service-privider" class="headerlink" title="IOC service privider"></a>IOC service privider</h2><p>　　作用是对象的构建管理以及其对象之间的相互依赖<br>　　这个是如何管理对象之间的相互依赖呢？<br>　　１.直接编码<br>　　在容器启动前，我们通过代码的形式将被注入对象和依赖对象注册到容器中，并且明确它们之间的依赖注入关系。<br>　　２．配置文件方式<br>　　我们可以通过spring的配置文件来完成对象之间的关联，在容器启动时在加载到容器中。<br>　　３.元数据方式<br>　　这个是java1.5之后的元数据结合的，个人觉得也是直接代码但是多了元数据这个方便的用法。</p>
<h2 id="Spring-的ICO-Service-Privider"><a href="#Spring-的ICO-Service-Privider" class="headerlink" title="Spring 的ICO Service Privider"></a>Spring 的ICO Service Privider</h2><p>　　Spring ICO容器包含了IOC Service Privider,AOP,线程管理等很多方面。因为他还是个容器。<br>　　Spring ICO容器有2个类型：<br>　　BeanFactory：基础类型的IOC容器，提供基本的IOC支持，默认为延迟加载机制，也就是只有当客户端对象需要访问容器里面的对象时才对受管理的对象进行初始化和注入操作，因此容器启动较快。<br>　　ApplicationContext：这个是在BeanFactory的基础上构建的，是相对其高级的实现，提供了一些额外的高级特性。其这个容器在启动时会初始化加载绑定所有托管的对象。因此启动较慢。继承了BeanFactory这个接口。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://skydh.github.io/2018/02/24/tomcat 浅析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="董航">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="why are you so happy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/24/tomcat 浅析/" itemprop="url">Tomcat浅析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-24T15:31:37+08:00">
                2018-02-24
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Tomcat结构"><a href="#Tomcat结构" class="headerlink" title="Tomcat结构"></a>Tomcat结构</h2><p>　　Tomcat最顶层的容器叫做server。代表整个服务器，Server中至少包含一个Service用于提供服务。而Service主要包含以下2个。Connector：用于处理连接相关的事情，且提供Socket和request，response的装换。<br>　　Container则是用于封装和管理Servlet以及具体处理request请求。一个Tomcat只能有一个Server，一个Server可以包含多个Service，一个Service中只有一个Container，但是可以有多个Connectors（因为一个服务可以有多个连接）。<br>　　Tomcat中的管理类是Catalina,它用来管理Server。其有3个方法来管理Server的整个生命周期。<br>　　load方法用于根据conf/server.xml文件创建Server并调用Server的init方法来进行初始化。<br>　　start方法用于启动服务器。stop方法用于停止服务器。这些方法会逐层调用其下级的方法来启动整个服务器。比如，Server的stat方法调用所有的Service的stat方法，Service的stat方法调用Connectors和Container的stat方法。<br>　　Tomcat的入口main不在CatAlina类里。在BootStrap里。</p>
<h2 id="tomcat启动过程"><a href="#tomcat启动过程" class="headerlink" title="tomcat启动过程"></a>tomcat启动过程</h2><h3 id="BootStrap"><a href="#BootStrap" class="headerlink" title="BootStrap"></a>BootStrap</h3><p>　　启动Tomcat就是调用BootStrap的main方法。在这个main方法里面主要做了这么几个事情。新建BootStrap实例，然后赋值给catalinaDaemon变量。然后根据不同命令不同操作。<br>　　start:调用了3个方法setAwaut(true),load(args),start().这3个方法内部都会调用相应的Catalina进行具体处理执行。<br>　　Stop:调用StopServer方法。</p>
<h3 id="Catalina"><a href="#Catalina" class="headerlink" title="Catalina"></a>Catalina</h3><p>　　可以看到Catalina是上面BootStrap的3个方法来启动的，setAwait设置Server启动后是否进入等待状态（true是，false不是）。load方法用来加载配置文件。创建并且初始化Server，Start方法用来启动服务器。在这个方法里面主要是调用了server的start方法来启动服务器。</p>
<h3 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h3><p>　　Server接口包含了一个个的serveice，因此在server中，提供了addService(Service service),removeService(Service service)来添加和删除service。server的init，start方法则是循环调用了每个Service的init，start方法。来启动所有的service。<br>　　Server默认实现是StandardServer，StandardServer的上级父类有LifeCycleBase的类，init,start方法就定义在这个类里面，这个类的init和start方法调用的是initInternal方法和startinternal方法，而这2个方法是模板方法，由子类具体实现，因此调用StandardServer的init，stat方法就是执行StandardServer的initInternal方法和startinternal方法，而在<br>　　StandardServer的initInternal方法和startinternal方法中分别循环调用了每一个Service的start和init方法。在StandardServer实现了await方法，让服务器进入等待状态。</p>
<h3 id="service"><a href="#service" class="headerlink" title="service"></a>service</h3><p>　　Service的默认实现是StandardService。而这个类也继承了LifeCycleBase这个类，因此其init和stat方法最终也会调用其自身的initInternal方法和startinternal方法。在initInternal方法和startinternal方法的实现中，其主要是调用了其containner(容器)，executors(线程池)，mapperListener是Mapper的监听器，可以监听container的变化。connectors(连接器)的init和start方法。</p>
<h2 id="tomcat生命周期"><a href="#tomcat生命周期" class="headerlink" title="tomcat生命周期"></a>tomcat生命周期</h2><p>　　tomcat通过Lifecycle接口统一管理生命周期，所有生命周期组件都要实现这个接口。<br>　　做了４件事。<br>　　１．定义了１３个String类型的常量，用于LifecycleEvent事件的type属性中，作用是区分组件发出的lifecycleEvent事件的状态。<br>　　２．定义了3个管理监听器方法：addLifecycleListener,findLifecycleListener,removeLifecycleListener,用来添加，查找，删除LifecycleListener类型的监听器。<br>　　３．定义了４个生命周期的方法init,start,stop,destroy,用于执行生命周期的各个阶段的操作。<br>　　４．定义了getState,getStateName,用来获取当前状态，getState的返回值是LifecycleState的枚举类型。里面列举了生命周期的各个节点。而getStateName则是返回String类型的状态的名字。<br>　　lifecycle的默认实现是LifecycleBase,所有实现了生命周期的组件基本都是直接或者间接继承这个类，其为接口Lifecycle的接口方法都给了实现。<br>　　监听器的管理是LifecycleSupport类完成的，其定义了一个LifecycleListenner数组属性来保存所有的监听器。然后定义了添加，删除，查找，执行监听器的方法；</p>
<h2 id="Container简述"><a href="#Container简述" class="headerlink" title="Container简述"></a>Container简述</h2><p>　　容器：存放编写的代码。分为四层容器。<br>　　１．Wrapper:对应一个Servlet。<br>　　２．Context:对应一个应用。<br>　　３．Host：对应一个站点。<br>　　４．Engine对应引擎。每个service只有一个Engine。</p>
<h2 id="Connector简述"><a href="#Connector简述" class="headerlink" title="Connector简述"></a>Connector简述</h2><p>　　负责处理网络连接相关的事情，比如，Socket连接，将其根据HTTP协议，TCP/IP协议封装为Request,Response来具体处理，将其交给Container进行处理，Container就是Servlet的容器。Container处理完就返回给Connector,而Connector使用Socket将处理结果返回给客户端。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://skydh.github.io/2018/02/24/java nio/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="董航">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="why are you so happy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/24/java nio/" itemprop="url">java NIO.</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-24T09:15:41+08:00">
                2018-02-24
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="阻塞和非阻塞"><a href="#阻塞和非阻塞" class="headerlink" title="阻塞和非阻塞"></a>阻塞和非阻塞</h2><p>　　阻塞是函数没有返回结果就一直等待，知道得到返回结果。非阻塞则是函数没有返回结果自己不用等待可以去干别的事情，这是函数内部的的实现区别，也就是函数未就绪时是直接返回结果。
　　</p>
<h2 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h2><p>　　同步是指主动请求并且等待结果。当数据就绪后在读写时必须阻塞，异步则是请求到数据后可以继续处理其他任务，随后等待结果，这可以使得进程读写时不阻塞。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>　　所以说，阻塞，非阻塞和同步，异步是不一样的概念，阻塞和非阻塞是函数的实现方式就是未就绪时是否直接返回结果，阻塞和非阻塞在程序中也算是同步的，而异步则是不管是不是直接返回结果，我都可以干别的事，等到返回结果再处理。</p>
<h2 id="java-NIO"><a href="#java-NIO" class="headerlink" title="java NIO"></a>java NIO</h2><p>　　java的最初io流是阻塞的BIO流,不适合于多连接的处理情况。因为多个连接就要多个线程。而NIO的出现解决了这个问题。而且NIO的操作方式类似于操作系统，因此效率会更加高一些。<br>　　io的操作是基于字节流和字符流，是单向的比如inputStreanm，只能读，而NIO则是基于Channel和Buffer，是双向，比如Channel是双向的既可以用来读也可以来写。<br>　　NIO是非阻塞的，IO则是阻塞的，一个线程调用read()方法时，如果没有操作完，该线程就会一直阻塞。对于这个线程而言，这时他不能干别的事了，因为程序时顺序执行的。NIO则是不一样的，无论是读取数据还是写入数据都不会使得这个线程阻塞下去。可以继续干自己的事情。</p>
<h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><p>　　直接代码示例吧，具体的Channel，Buffer，Selector的用法可以查询java官方api。</p>
<p>　　这里直接上几个代码案例，直接对比。</p>
<p><pre><br>public class Test {</pre></p>
<pre><code>public static void main(String[] args) throws Exception {
    File file = new File(&quot;data.txt&quot;);
    FileInputStream fileOutputStream = new FileInputStream(file);
    FileChannel fileChannel = fileOutputStream.getChannel();
    ByteBuffer byteBuffer = ByteBuffer.allocate(10);
    // String string = &quot;nio test&quot;;
    int a = fileChannel.read(byteBuffer);
    System.out.println(a);

    while (a != -1) {
        byteBuffer.flip();
        while (byteBuffer.hasRemaining()) {
            System.out.print((char) byteBuffer.get());
        }
        byteBuffer.compact();
        a = fileChannel.read(byteBuffer);
    }
}
</code></pre><p>}<br><br>　　这个代码是读取一个文件，并且运用NIO的方式输出出来。有了大概的印象，那么我们来看看在socket中，这些操作时怎么处理的，非阻塞机制到底怎么提高了这个的优化效率。<br>　　第一个是ｉｏ的服务器</p>
<p><pre><br> public class Snippet {<br>    public static void main(String[] args) {<br>        ServerSocket serverSocket = null;<br>        InputStream in = null;<br>        try {<br>            serverSocket = new ServerSocket(8088);<br>            int recvMsgSize = 0;<br>            byte[] recvBuf = new byte[1024];<br>            while (true) {<br>                Socket clntSocket = serverSocket.accept();<br>                SocketAddress clientAddress = clntSocket.getRemoteSocketAddress();<br>                System.out.println(“Handling client at “ + clientAddress);<br>                in = clntSocket.getInputStream();<br>                while ((recvMsgSize = in.read(recvBuf)) != -1) {<br>                    byte[] temp = new byte[recvMsgSize];<br>                    // System.arraycopy(recvBuf, 0, temp, 0, recvMsgSize);<br>                    System.out.println(new String(temp));<br>                }<br>            }<br>        } catch (IOException e) {<br>            e.printStackTrace();<br>        } finally {<br>            try {<br>                if (serverSocket != null) {<br>                    serverSocket.close();<br>                }<br>                if (in != null) {<br>                    in.close();<br>                }<br>            } catch (IOException e) {<br>                e.printStackTrace();<br>            }<br>        }<br>    }<br>}</pre></p>
<p><br>　　客户端代码直接用ＮＩＯ的模式写吧</p>
<p><pre><br> public class NioClient {<br>    public static void main(String[] args) {<br>        ByteBuffer buffer = ByteBuffer.allocate(1024);<br>        SocketChannel socketChannel = null;<br>        try {<br>            socketChannel = SocketChannel.open();<br>            socketChannel.configureBlocking(false);<br>            socketChannel.connect(new InetSocketAddress(“127.0.0.1”, 8088));<br>            System.out.println(“aaa”);</pre></p>
<pre><code>        if (socketChannel.finishConnect()) {
            int i = 0;
            while (i&lt;10) {
                TimeUnit.SECONDS.sleep(1);
                String info = &quot;I&apos;m &quot; + i++ + &quot;-th information from client&quot;;
                buffer.clear();
                buffer.put(info.getBytes());
                buffer.flip();
                while (buffer.hasRemaining()) {// 判断是否数据读完
                    System.out.println(buffer);
                    socketChannel.write(buffer);
                }
            }
        }
    } catch (IOException | InterruptedException e) {
        e.printStackTrace();
    } finally {
        try {
            if (socketChannel != null) {
                socketChannel.close();
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
</code></pre><p>}</p>
<p><br>　　假设服务器是这种代码，客户端有多个连接到来，那么一次只能连接一个，直到用完，或许有的小伙伴说，多线程啊，每个线程一个连接，线程池管理。恩，但是线程太消耗资源，而且线程转换也会消耗资源。那么ｎｉｏ来了，我们来看看Ｎｉｏ的实现。</p>
<pre><code>public class ServerConnect
{
    private static final int BUF_SIZE=1024;
    private static final int PORT = 8080;
    private static final int TIMEOUT = 3000;

    public static void main(String[] args)
    {
        selector();
    }

    public static void handleAccept(SelectionKey key) throws IOException{
        ServerSocketChannel ssChannel = (ServerSocketChannel)key.channel();
        SocketChannel sc = ssChannel.accept();
        sc.configureBlocking(false);
        sc.register(key.selector(), SelectionKey.OP_READ,ByteBuffer.allocateDirect(BUF_SIZE));
    }

    public static void handleRead(SelectionKey key) throws IOException{
        SocketChannel sc = (SocketChannel)key.channel();
        ByteBuffer buf = (ByteBuffer)key.attachment();
        long bytesRead = sc.read(buf);
        while(bytesRead&gt;0){
            buf.flip();
            while(buf.hasRemaining()){
                System.out.print((char)buf.get());
            }
            System.out.println();
            buf.clear();
            bytesRead = sc.read(buf);
        }
        if(bytesRead == -1){
            sc.close();
        }
    }

    public static void handleWrite(SelectionKey key) throws IOException{
        ByteBuffer buf = (ByteBuffer)key.attachment();
        buf.flip();
        SocketChannel sc = (SocketChannel) key.channel();
        while(buf.hasRemaining()){
            sc.write(buf);
        }
        buf.compact();
    }

    public static void selector() {
        Selector selector = null;
        ServerSocketChannel ssc = null;
        try{
            selector = Selector.open();
            ssc= ServerSocketChannel.open();
            ssc.socket().bind(new InetSocketAddress(PORT));
            ssc.configureBlocking(false);
            ssc.register(selector, SelectionKey.OP_ACCEPT);

            while(true){
                if(selector.select(TIMEOUT) == 0){
                    System.out.println(&quot;==&quot;);
                    continue;
                }
                Iterator&lt;SelectionKey&gt; iter = selector.selectedKeys().iterator();
                while(iter.hasNext()){
                    SelectionKey key = iter.next();
                    if(key.isAcceptable()){
                        handleAccept(key);
                    }
                    if(key.isReadable()){
                        handleRead(key);
                    }
                    if(key.isWritable() &amp;&amp; key.isValid()){
                        handleWrite(key);
                    }
                    if(key.isConnectable()){
                        System.out.println(&quot;isConnectable = true&quot;);
                    }
                    iter.remove();
                }
            }

        }catch(IOException e){
            e.printStackTrace();
        }finally{
            try{
                if(selector!=null){
                    selector.close();
                }
                if(ssc!=null){
                    ssc.close();
                }
            }catch(IOException e){
                e.printStackTrace();
            }
        }
    }
}
</code></pre><p>   Selector运行单线程处理多个Channel，如果你的应用打开了多个通道，但每个连接的流量都很低，使用Selector就会很方便。例如在一个聊天服务器中。要使用Selector, 得向Selector注册Channel，然后调用它的select()方法。这个方法会一直阻塞到某个注册的通道有事件就绪。一旦这个方法返回，线程就可以处理这些事件，事件的例子有如新的连接进来、数据接收。<br>　　我们在上面的代码里面将ServerSocketChannel注册到Selector里面，接受accept事件，每当有一个连接到来，select()就会有返回值，因为这个事件完成了，就会触发下面的操作，然后我们把这个新加入的连接也放到selector里面，等待读事件，或者写事件，当这个事件准备好了，就会启动返回。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://skydh.github.io/2018/02/24/servelet/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="董航">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="why are you so happy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/24/servelet/" itemprop="url">浅析Servlet协议</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-24T09:09:59+08:00">
                2018-02-24
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="什么是Servlet"><a href="#什么是Servlet" class="headerlink" title="什么是Servlet"></a>什么是Servlet</h2><p>　　Servelet是Server+Applet的缩写，表示一个服务器应用，是javaEE提出的一套规范。</p>
<h2 id="Servlet规范"><a href="#Servlet规范" class="headerlink" title="Servlet规范"></a>Servlet规范</h2><p><pre>public interface Servlet {<br>    //容器在启动的被调用,仅调用一次<br>    void init(ServletConfig var1) throws ServletException;<br>    //获取Servlet配置<br>    ServletConfig getServletConfig();<br>    //处理具体请求<br>    void service(ServletRequest var1, ServletResponse var2) throws ServletException, IOException;<br>    //获取Servlet的相关信息<br>    String getServletInfo();<br>    //Servlet销毁后释放资源<br>    void destroy();<br>}</pre><br>　　init方法是在容器启动时调用。只会调用一次。ServletConfig方法是获取Servelet配置信息。Service方法则是处理具体的请求。getServeletInfo方法是获取servelet相关信息，比如作者之类的要自己实现，默认返回为空字符串。destroy方法则是Servelet销毁时（一般是指关闭服务器）来释放一些资源，只会调用一次。<br>　　init方法在启动时会获取到一个容器的serveletConfig信息。我们在web.xml的配置的servelet的init-param参数配置的内容就是保存在serveletConfig的。<br>　　在tomcat容器中。Servelet的init是容器的类StandrdWrapper的initServelet方法调用的，serveletConfig传入的也是StandrdWrapper的门面类StandrdWrapperFacade.</p>
<h2 id="HTTPServelet"><a href="#HTTPServelet" class="headerlink" title="HTTPServelet"></a>HTTPServelet</h2><p>　　HttpServlet是我们写servelet常用的，他是继承了HTTP协议实现的</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://skydh.github.io/2018/02/09/http协议浅析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="董航">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="why are you so happy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/09/http协议浅析/" itemprop="url">浅析http协议</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-09T10:35:05+08:00">
                2018-02-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Http协议的报文结构"><a href="#Http协议的报文结构" class="headerlink" title="Http协议的报文结构"></a>Http协议的报文结构</h2><p>　　Http协议分为请求报文和响应报文。分为3部分：首行，头部，主体三部分。<br>　　首行：http版本，状态码，url等。<br>　　头部：保存的是一些键值对信息。<br>　　主体：保存的是具体内容。请求报文主体保存的是post请求参数信息,响应报文保存的是页面要显示的结果。首行，头部，主体用回车换行分割，林外头部和主体之间多了一个空行。<br>　　请求报文的方法有：GET,HEAD,POST,PUT,DELETE.<br>　　响应报文状态码大概有５类：<br>　　1XX:信息状态码。<br>　　2XX:成功状态码。如200表示成功<br>　　3XX:重定向状态码。如301表示重定向。<br>　　4XX:客户端错误状态码。如404表示没找到请求的资源。<br>　　5XX:服务端错误状态码。如500表示内部错误。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://skydh.github.io/2018/02/08/tcp ip协议/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="董航">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="why are you so happy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/08/tcp ip协议/" itemprop="url">tcp/ip协议</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-08T14:24:27+08:00">
                2018-02-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="什么是tcp-ip协议"><a href="#什么是tcp-ip协议" class="headerlink" title="什么是tcp/ip协议"></a>什么是tcp/ip协议</h2><p>　　tcp/ip是2个协议，tcp是运输端协议，ip是网络端协议，这2个协议一般一起使用的。ip协议是来确定和找到地址的，tcp则是具体的传输信息的工作。</p>
<h2 id="tcp的三次握手和四次挥手协议"><a href="#tcp的三次握手和四次挥手协议" class="headerlink" title="tcp的三次握手和四次挥手协议"></a>tcp的三次握手和四次挥手协议</h2><p>　　理解这个过程首先要知道tcp的2个序号和3个标志位的含义。<br>　　seq:表示传输数据的序号。tcp传输时每一个字节都有序号，发送时会把第一个序号发过去。接收端通过序号判断数据是否完整，如果不完整则重发。<br>　　ack:表示确认号，接受端表示数据已经完整接受，向发送端发送确认号。表示希望接受到数据的编号。一般为接受端报文最后的序号+1.<br>　　ACk：表示确认位。只有ACK=1时ack才会起作用。正常通信时ACK=1,第一次的话没有接收方确认是0.<br>　　SYN:这个是同步标志位，当SYN=1,ACK=0时表示这是个连接请求报文段，握手完成后SYN标志位为1<br>　　FIN:FIN=1表示数据已经发送完要求释放运输连接。</p>
<p><img src="https://raw.githubusercontent.com/skydh/picture/master/tcp_001.png" alt="aaa"><br><img src="https://raw.githubusercontent.com/skydh/picture/master/tcp_002.png" alt="aaa"><br>　　简述下３次握手和四次挥手<br>　　三次握手<br>　    1.客户端向服务端发送连接请求包，ACk位为0，SYN为1，seq=X,ACk是因为没有接受到确认信息故为0，因此需要同步标志位来确认其为有效连接。<br>　　２．服务端向客户端发送确认信息：标识位SYN=1，ACK=1，希望收到的下个信息的序号为ack=x+1;自身的seq序号为y.<br>　　３．客户端向服务端发送确认报文，ACK=1,SYN=1,ack=y+1,seq=x+1。<br>　　为何需要三次握手？<br>　　第一次，服务端知道自己接受数据没问题，第二次，客户端知道自己自己发送数据和接受数据没问题，第三次服务端知道自己发送数据没问题。然后，数据开始发送。<br>　　四次挥手<br>　　１．客户发送FIN=1,seq=x,来像服务器发送终止请求。<br>　　２．服务端接受到FIN后，发送一个ACK=1,seq=y,ACK=x+1.<br>　　３．关闭服务端到客户端的连接，且发送一个FIN给客户端。<br>　　４．客户端收到FIN后，且发送一个ACK=1,seq=x+1,ack=y+1.<br>　　简而言之这样的：<br>　　第一次客户端发送一个fin,表示自己数据发完了，服务端收到后，若是数据没有发送完，就发送一个ack，表示，已经收到你的请求，但是服务端数据没有发送完，继续发送数据，等到数据发送完了，就发送一个fin,客户端收到fin后就发送一个ack,表示确认收到，服务端就可以关闭连接了。但是客户端还是要等一个周期时间，如果客户端发送ack丢失了，服务端没有收到就会继续发送fin,直到收到信息后，才关闭，而客户端在一定周期内没有收到信号也关闭。<br>　　为何是结束是4次握手？<br>　　数据可能没有发送完。如果都是同时发送完了，那么也是3次握手，3次握手是由于没有数据传送<br>　　注意到每一次连接都要消耗3次握手和4次握手，<br>　　故有了tcp长连接和短连接，http的长连接和短连接实际上就是tcp的．</p>
<p>　　短连接：就是一次简单的tcp连接，数据发送完直接关闭。连接→数据传输→关闭连接</p>
<p>　　长连接：就是在一次连接内多次发送数据包，中间若是没有数据那么靠心跳保活协议维护， 连接→数据传输→保持连接(心跳)→数据传输→保持连接(心跳)→……→关闭连接<br>　　这样子就减少了多次连接所消耗的握手
　　</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://skydh.github.io/2018/02/08/DNS协议简介/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="董航">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="why are you so happy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/08/DNS协议简介/" itemprop="url">DNS协议</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-08T09:33:46+08:00">
                2018-02-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="什么是DNS协议"><a href="#什么是DNS协议" class="headerlink" title="什么是DNS协议"></a>什么是DNS协议</h2><p>　　我们知道网络上每个站点的位置是靠ip来确认的，想要访问一个网站必须知道他的ip地址。但是ip地址全部是数字，很不好记忆。也不方便记忆，于是就有了域名。每个域名都有对应的ip地址，网上的域名非常多。且网上域名和ip对应关系也经常变化，因此需要有专门的把域名装换为ip的服务器，这个就是DNS服务器，我们把域名传递过去他就会返回对应的ip。我们可以用nslookup来获取域名信息。看下面的例子</p>
<p><img src="https://raw.githubusercontent.com/skydh/picture/master/DNS_001.png" alt="aaa"><br>　　域名服务器的域名是：ns.wuhan.net.cn<br>　　域名服务器的ip是： 202.103.24.68<br>　　被解析的域名对应ip是：180.97.33.107 ，180.97.33.108<br>　　被解析域名的CNAME域名是：www.a.shifen.com<br>　　什么是CNAME?<br>　　CNAME是将别的域名装换为一个域名，再将这个域名解析到A记录上，也就是在转换为ip,为什么需要这么做，一个网站要是有多个域名，如果对应ip变了，那么所有的对应关系都要修改，但是有了中间层这个域名，那么则只要改一下就行了。</p>
<h2 id="DNS注册"><a href="#DNS注册" class="headerlink" title="DNS注册"></a>DNS注册</h2><p>　　DNS是如何获取到ip和域名的对应关系呢？那是通过万网注册。DNS服务器则可以获取到其信息了。</p>
<h2 id="DNS地址获取"><a href="#DNS地址获取" class="headerlink" title="DNS地址获取"></a>DNS地址获取</h2><p>　　可以在网络配置页面进行DNS配置。可以选择自动获取，也可以设置固定的DNS地址。</p>
<h2 id="本机自己配置ip"><a href="#本机自己配置ip" class="headerlink" title="本机自己配置ip"></a>本机自己配置ip</h2><p>　　Windows下这个目录C:\Windows\System32\drivers\etc可以配置对应域名和ip,本机解析域名时先从hosts下找，找不到再从DNS服务器上找。<br>　　这个是我本机的hosts</p>
<pre>
        # Copyright (c) 1993-2009 Microsoft Corp.
        #
        # This is a sample HOSTS file used by Microsoft TCP/IP for Windows.
        #
        # This file contains the mappings of IP addresses to host names. Each
        # entry should be kept on an individual line. The IP address should
        # be placed in the first column followed by the corresponding host name.
        # The IP address and the host name should be separated by at least one
        # space.
        #
        # Additionally, comments (such as these) may be inserted on individual
        # lines or following the machine name denoted by a '#' symbol.
        #
        # For example:
        #
        #      102.54.94.97     rhino.acme.com          # source server
        #       38.25.63.10     x.acme.com              # x client host

        # localhost name resolution is handled within DNS itself.
        #    127.0.0.1       localhost
        #    ::1             localhost
        10.11.248.91 zjy.cscec.com.cn


</pre>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://skydh.github.io/2018/02/07/session 和token/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="董航">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="why are you so happy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/07/session 和token/" itemprop="url">session,token</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-07T10:31:30+08:00">
                2018-02-07
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="session"><a href="#session" class="headerlink" title="session"></a>session</h2><p>　　什么是session？<br>　　session是一个用户会话的配置属性信息，同时存储在用户和服务器里面。<br>　　session的作用。<br>　　用于解决http/https的无状态特性。用于区分确认用户。用户登录后，服务器发放一个sessionid给客户端，自身内存也保存一个一样的sessionid,等到下次用户在访问服务器时，http/https的head头将携带这个sessionId,服务器程序则会判断此id是否存在用于区分不同用户。<br>　　session的缺点以及解决方案<br>　　如果登录用户太多，一台服务器肯定不够，那么就会集群分部，就是用多台服务器来分流处理。前面的负载均衡器则来分发请求。为了避免sessionid在服务器的不同步问题，可以用session sticky来让用户连接到固定的服务器。也可以让服务器之间相互复制，也可以建立一个专门存放sessionid的服务器</p>
<h2 id="token"><a href="#token" class="headerlink" title="token"></a>token</h2><p>　　token则是与session与众不同。如果session占的是空间，那么token占的则是时间。现在服务器性能那么好，时间的消耗微乎其微。而且可以避免上述sessionid在不同服务器之间的问题。<br>　　token是怎么处理的？<br>　　用户登录系统后携带的用户ｉｄ，服务器用专门的密钥对其这个用户ｉｄ来加密，生成一个签名。然后把这个签名和数据一起作为token发给客户端，自身则是不保存，重要的事情说三遍，自身不保存。用户再来访问时则要携带这个token，服务器则是把这个token取出来，在对这个id来用相同方式加密，如果签名不一样则是，无法通过了。<br>　　大致是这种原理，一般来说还会在token里面加个过期时间之类的。<br>　　目前很多小网站没有都是获取到大公司的授权码来登录，用到的也是token<br>　　用下面转载自码农翻身的一张图来解释下</p>
<p><img src="https://raw.githubusercontent.com/skydh/picture/master/token_001.png" alt="aaa"></p>
<p>　　一目了然。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://skydh.github.io/2018/02/05/高并发海量数据解决方案/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="董航">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="why are you so happy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/05/高并发海量数据解决方案/" itemprop="url">海量数据和高并发解决方案</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-05T11:48:48+08:00">
                2018-02-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>ps ：读书笔记</p>
<h1 id="海量数据解决方案"><a href="#海量数据解决方案" class="headerlink" title="海量数据解决方案"></a>海量数据解决方案</h1><h2 id="缓存和页面静态化"><a href="#缓存和页面静态化" class="headerlink" title="缓存和页面静态化"></a>缓存和页面静态化</h2><p>　　缓存就是把从数据库中的数据暂时存起来，下次使用时无需在查询数据库。缓存分为程序直接保存到内存和框架框架２种。程序缓存一般使用currentHashMap直接保存到内存。框架缓存的话有redis，memcache等。<br>　　ps:空数据值问题。<br>　　缓存创建的时候把没有数据的缓存用特定的符号来表示。因为这种模式下如果从缓存中获取不到数据，就会查询数据库，但是其本身就没有数据的话。那么每次都要查询一次数据库，不合理。<br>　　页面静态化：是将程序生成的页面保存起来。这样下次调用直接就使用。连程序这一关也过了。更加快速。可以在程序中使用velocity等技术来生成静态页面，也可以通过上层缓存Nginx来生成。</p>
<h2 id="数据库优化"><a href="#数据库优化" class="headerlink" title="数据库优化"></a>数据库优化</h2><p>　　１．表结构优化：设计合理的符合规范的表。<br>　　２．sql优化：根据日志以及其他工具分析那条sql语句最耗时，在针对性的有的放矢的优化，要统筹好，不能只针对一条语句，优化时要考虑到表上的其他语句综合考虑。<br>　　３．分区：一个表中数据量太大时，那么分区就可以使用了。分区是将数据按照一定规则把数据分到不同区来保存，这样子操作数据时，数据量更少。查询数据时只在一定区间进行。且这种操作时对程序透明的。程序无需修改。<br>　　４．分表：分表就是把表横向切分为几个表。第一种方式就是为了减少数据，比如一张表里面某个字段是分类。可以更具这个分类来分为多个表。以此来减少每个表的数据量。第二种方式是由于某个表某些字段经常被查，但是不修改，某些字段需要进场修改，那么分表是个不错的选择，因为对于mysql之类的表来说，增删改操作时要加锁的，无论是什么隔离级别。，这样子加锁范围就减少了。对于mysql来说不是问题，但是对于其他数据库来说就不知道了。对于mysql来说可以照样读取数据，对于某些数据库或者se隔离级别的mysql，这条记录也是不可读的。需要等待数据库释放这条记录的锁。<br>　　５．索引优化：对于mysql的innodb来说，我上篇博客已经说过了。这里简单说下，最左匹配原则，综合所有查询语句，找出，最佳的索引创建原则和最佳的查询语句，比如，你有联合索引（a,b,c）。你的查询语句为b=1 and c=1 那么要么调整查询语句让其条件多个a=?要么联合索引（a,b,c）调整为（b,c,a）。其次对于mysql来说。一条语句有且只用一个表有且只用一条索引。至于多表查询时连表的语句也会加入到索引里面。<br>　　６．存储过程：对于复杂的sql来说来说，直接使用存储过程来调用，可以有效提高效率。</p>
<h2 id="活跃数据分离"><a href="#活跃数据分离" class="headerlink" title="活跃数据分离"></a>活跃数据分离</h2><p>　　一个数据量很大的表，只有一小部分数据是活跃数据，经常被查询，更多的数据则是惰性数据，偶尔被调用一下。那么我们可以用２个表来保存，第一个表是活跃数据保存，第二个表是惰性数据保存。这样子可以有效提高效率。至于是否活跃数据，怎么分配就要看自己方业务逻辑怎么实现的了。</p>
<h2 id="批量读取和延迟修改"><a href="#批量读取和延迟修改" class="headerlink" title="批量读取和延迟修改"></a>批量读取和延迟修改</h2><p>　　１．批量读取：故名思议，把一堆查询结合成一条查询，比如。有的业务是要查询一次做个操作，那么可以把这些查询放在一个in()语句里面。又或者高并发下，把几秒的异步请求统一查询处理。<br>　　２.延迟修改：就是把一些频繁修改的数据放到一个缓存里面去，然后定时把缓存的数据刷到数据库里面，这个缓存和普通缓存不一样，这个缓存的数据库不是完整的。程序查询时同时读取数据库和缓存的数据，综合读取之。</p>
<h2 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h2><p>　　<img src="https://raw.githubusercontent.com/skydh/picture/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/spring%20mvc/%E4%B8%80.001.png" alt="aaa"></p>
<p>　　先上一张图，这个图是书里面的，说起来很简单就是把读取数据和增删改数据分离到不同数据库里面。增删改放到主数据库里面，读取数据则是放到从数据库里面。主数据的数据通过底层同步到从数据库里面。</p>
<h2 id="分布式数据库"><a href="#分布式数据库" class="headerlink" title="分布式数据库"></a>分布式数据库</h2><p>　　分布式数据库是将不同的表放到不同的数据库里面，然后再放到不同的服务器里面，这样子查询时可以使用多台服务器来运行，可以有效提高效率，主要用于超复杂耗时的查询。这个可以和读写分离一起使用，搭配使用。另一种情况是不同业务的表放在不同数据库里面，可以起到分流的作用</p>
<h2 id="NoSql和Hadoop"><a href="#NoSql和Hadoop" class="headerlink" title="NoSql和Hadoop"></a>NoSql和Hadoop</h2><p>　　NoSql和sql比起来就是非结构化的，就是没有定义好的字段，类型啊之类的，但是NOsql是通过多个块存储数据，因此效率速度很快，被广泛应用于大数据<br>　　Hadoop：Hadoop是针对大数据处理的一套框架。</p>
<p><img src="https://raw.githubusercontent.com/skydh/picture/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/spring%20mvc/hadoop_001.png" alt="aaa"></p>
<p>　　这个是Hadoop存储图，就是把表的数据块分为多个节点保存。这样子可以并发处理并且可以保存数据的稳定性。Hadoop是对每一个数据块找到的节点并处理，然后在统一处理，得到最终结果（这块不熟）</p>
<h1 id="高并发处理方案"><a href="#高并发处理方案" class="headerlink" title="高并发处理方案"></a>高并发处理方案</h1><h2 id="静态资源分离"><a href="#静态资源分离" class="headerlink" title="静态资源分离"></a>静态资源分离</h2><p>　　就是将图片，视频，css，等文件保存到另外一个服务器中，使用2级域名，通过不同域名，可以让浏览器迅速获取到资源而不用访问应用服务器。</p>
<p><img src="https://raw.githubusercontent.com/skydh/picture/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/spring%20mvc/pv_001.png" alt="aaa"></p>
<h2 id="页面缓存"><a href="#页面缓存" class="headerlink" title="页面缓存"></a>页面缓存</h2><p>　　就是将程序生成的页面缓存保存下来，下次访问时就不用再用cpu来生成数据了。浪费其资源。可以使用Nginx服务器自带的缓存机制，也可以使用专门的squid来处理。（ps:对于一些页面某些数据经常变化，但是整体不变，那么我们可以使用ajax来请求重新获取数据来更新界面）</p>
<h2 id="集群和分布式"><a href="#集群和分布式" class="headerlink" title="集群和分布式"></a>集群和分布式</h2><p>　　集群就是相同的程序放到多个服务器里面，主要起到分流的作用。分布式就是更具业务逻辑将程序拆分到不同服务器上。这２个可以一起使用。（至于集群导致的session和token问题，下一章会有篇关于session和token）。不用业务之间的联系可以通过RPC来处理，我们这边业务较为复杂，将大量的程序拆分成一个个的微服务。每个微服务之间通过dubbo来传递消息。</p>
<h2 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h2><p><img src="https://raw.githubusercontent.com/skydh/picture/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/spring%20mvc/fd_001.png" alt="aaa"></p>
<p>　　反向代理：就是客户端访问的服务器不直接提供资源，该服务器从别的服务器获取资源并返回给用户主要由３个作用<br>　　１．可以负载均衡<br>　　２．可以转发请求<br>　　３．可以作为前端服务器和实际请求服务器集成。<br>　　ps:反向代理和代理服务器不一样。反向代理是用户不知道这个事，一切都是透明的。代理服务器则是用于代替用户获取资源在返回给用户，需要用户手动设置。</p>
<h2 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h2><p><img src="https://raw.githubusercontent.com/skydh/picture/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/spring%20mvc/cdn_001.png" alt="aaa"></p>
<p>　　CDN是个特殊的页面缓存服务器，和普通的服务器相比，CDN服务器遍布全国各地，当接受到用户请求时，会将其分配到对应的最合适节点，根据地域等信息来分配，如图所示为其中一个实现方式。
　　</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://skydh.github.io/2018/01/24/mysql索引/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="董航">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="why are you so happy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/24/mysql索引/" itemprop="url">mysql 联合索引匹配原则</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-24T09:30:15+08:00">
                2018-01-24
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="读mysql文档有感"><a href="#读mysql文档有感" class="headerlink" title="读mysql文档有感"></a>读mysql文档有感</h2><p>　　看了mysql关于索引的文档，网上有一些错误的博客文档，这里我自己记一下。</p>
<h2 id="几个重要的概念"><a href="#几个重要的概念" class="headerlink" title="几个重要的概念"></a>几个重要的概念</h2><p>　　１．对于mysql来说，一条sql中，一个表无论其蕴含的索引有多少，但是有且只用一条。<br>　　２．对于多列索引来说（a,b,c）其相当于3个索引（a），（a,b），（a,b,c）3个索引，又由于mysql的索引优化器，其where条件后的语句是可以乱序的，比如（b,c,a）也是可以用到索引。如果条件中a,c出现的多，为了更好的利用索引故最好将其修改为（a.c,b）。</p>
<h2 id="ICP概念"><a href="#ICP概念" class="headerlink" title="ICP概念"></a>ICP概念</h2><p>　　看了一篇大神的博客，上面说了通用索引匹配原则，这里也顺便说下。<br>　　１．Index range 先确认索引的起止范围。<br>　　２．Index Filter 索引过滤。<br>　　３．Table Filter 表过滤。<br>　　传说中mysql5.6后提出的icp就是多了第二步，以前Index filter是放在数据上操作的，现在5.6后多了第二步，因此效率提高了很多。</p>
<h2 id="表的结构"><a href="#表的结构" class="headerlink" title="表的结构"></a>表的结构</h2><pre><code>CREATE TABLE `left_test` (
          `id` int(11) NOT NULL,
          `a` int(11) DEFAULT NULL,
          `b` int(11) DEFAULT NULL,
          `c` int(11) DEFAULT NULL,
          `d` int(11) DEFAULT NULL,
         `e` int(11) DEFAULT NULL,
           PRIMARY KEY (`id`),
          KEY `m_index` (`a`,`b`,`c`)
    ) ENGINE=InnoDB DEFAULT CHARSET=utf8
</code></pre><p>　　且插入了100万条数据。</p>
<h2 id="sql的分析"><a href="#sql的分析" class="headerlink" title="sql的分析"></a>sql的分析</h2><pre><code>select * from left_table where id=1。
select * from left_table where id&gt;1 and id&lt;3
</code></pre><p>　　使用了聚集索引，id为主键，那么这个表里面id则是聚集索引列，这条sql默认使用了聚集索引来搜索。
　</p>
<pre><code>select * from left_table where a=1
select * from left_table where a=1 and b=1
select * from left_table where a=1 and b=1 and c=1
</code></pre><p>　　使用联合索引（a,b,c）。其中这些条件可以可以乱序，因为mysql的sql优化器会优化这些代码</p>
<pre><code>select * from left_table where a&lt;1
select * from left_table where a&lt;1 and b&lt;1
select * from left_table where a&lt;1 and b&lt;1 and c&lt;1
</code></pre><p>　　对于现在mysql5.7中，小于可以乱序（mysql优化器优化了），但是按照最左匹配原则。比如条件(b)，(c),(b,c)组合就不行。</p>
<pre><code>select * from left_table where b&lt;1
select * from left_table where b&lt;1 and c&lt;1
select * from left_table where c&lt;1 
</code></pre><p>　　这个组合就用不到索引，因为不符合最左匹配原则。</p>
<pre><code>select * from left_table where a=1 and id=2
</code></pre><p>　　这里面id是聚簇索引列，而a是个二级索引列，那么这个是用聚集索引列，不用（a,b,c）这个索引，因为对于mysql 5.7 innodb 这个版本一条sql里面索引只能用一条。至于用那个，则是mysql自身的算法选择了。经过大量测试实验，规则如下，如果索引列数据数据一模一样，那么是谁先创建就选谁，如不一样，那么谁占用的列越多，或者列的数据越复杂则选它。当然最好手动指定。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/10/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><span class="page-number current">11</span><a class="page-number" href="/page/12/">12</a><a class="page-number" href="/page/13/">13</a><a class="extend next" rel="next" href="/page/12/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">董航</p>
              <p class="site-description motion-element" itemprop="description">clear 航</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">121</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            

          </nav>

          

          <div class="links-of-author motion-element">
            
          </div>

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">董航</span>

  
</div>


<div class="powered-by">
<i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv">
  本站访客数:<span id="busuanzi_value_site_uv"></span>
</span>
</div>

  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.3</div>




        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.3"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
