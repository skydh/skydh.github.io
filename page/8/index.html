<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="clear 航">
<meta property="og:type" content="website">
<meta property="og:title" content="why are you so happy">
<meta property="og:url" content="https://skydh.github.io/page/8/index.html">
<meta property="og:site_name" content="why are you so happy">
<meta property="og:description" content="clear 航">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="why are you so happy">
<meta name="twitter:description" content="clear 航">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://skydh.github.io/page/8/"/>





  <title>why are you so happy</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">why are you so happy</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">clear 航</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://skydh.github.io/2018/05/09/jvm内存分配策略/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="董航">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="why are you so happy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/09/jvm内存分配策略/" itemprop="url">jvm内存分配策略</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-09T15:05:24+08:00">
                2018-05-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="对象优先在新生代分配"><a href="#对象优先在新生代分配" class="headerlink" title="对象优先在新生代分配"></a>对象优先在新生代分配</h2><p>　　就是新生的对象按照原则一般在新生代内存区给其分配空间。</p>
<h2 id="大对象直接进入老年态"><a href="#大对象直接进入老年态" class="headerlink" title="大对象直接进入老年态"></a>大对象直接进入老年态</h2><p>　　大对象是指需要大量连续的内存空间的对象，比如非常长的字符串或者数组。因为出现这些对象意味着虚拟机要进行一次垃圾回收才可以安置这些对象，可以在虚拟机启动的时候设置 -XX pretenuresizethreshold 参数 来设置大于这个参数的大对象直接进入老年态。</p>
<h2 id="长期存活的对象将进入老年态"><a href="#长期存活的对象将进入老年态" class="headerlink" title="长期存活的对象将进入老年态"></a>长期存活的对象将进入老年态</h2><p>　　既然虚拟机采用了分带管理的策略来管理内存，那么如何判断一个对象时应该在老年态还是新生态中。虚拟机给每个对象设置了一个年龄计算器，当对象在Eden出生，并且活过了第一次垃圾回收，那么该对象将进入到Suivivor空间，年龄也会增加一，妹熬过一次就加一，当达到一个阈值时，就会被移动到老年态中，这个阈值默认是15，也可以通过参数配置和设置。</p>
<h2 id="动态对象年龄判定"><a href="#动态对象年龄判定" class="headerlink" title="动态对象年龄判定"></a>动态对象年龄判定</h2><p>　　为了更好的适应虚拟机的内存整理，虚拟机还有一个原则，如果在新生代的Suivivor空间的相同年龄对象所占的内存大于Suivivor一半时，将大于和等于这个年龄的对象加入到老年代。</p>
<h2 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h2><p>　　在新生代发生垃圾回收时，虚拟机都会先检查这个老年态最大可用连续空间是否大于新生代所有对象总空间，如果成立，那么这次垃圾回收是安全的，可以直接进行垃圾回收。如果不成立，就会查看HandlePromotionFailure这个值是否设置开启的，如果开启，就会继续判断老年代最大可用连续空间是否大于历次垃圾回收晋升到老年代对象的平均大小，如果大于，则进行一次啊垃圾回收。如果小于或者这个参数设置为关闭状态，那么就要进行一次啊Full GC。<br>　　为何如此？前面说了，新生代垃圾回收是复制算法，新生代内存分为8:1:1，每次垃圾回收就会将9份的移到剩余一份里面的，可能溢出，那么就用老年代担保，所以如此哦。一般上面的参数会默认设置为开启状态。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://skydh.github.io/2018/05/08/java垃圾回收算法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="董航">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="why are you so happy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/08/java垃圾回收算法/" itemprop="url">jvm垃圾回收算法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-08T17:30:29+08:00">
                2018-05-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>　　强引用：这个引用在程序代码间很常见，类似于Object a=new Object（），这样直接声明的对象，只要强引用还存在，那么这个对象就不会被gc回收。<br>　　软引用：java用SoftReference类来实现软引用。软引用关联的对象会在系统即将发生内存溢出，也就是内存不够时，将会把这些对象进行回收，如果回收后依旧没有足够的内存才会抛出内存溢出异常。<br>　　弱引用：java用WeakReference类实现弱引用，其强度更弱于软引用，被弱引用的对象会在下次垃圾回收时直接被回收，无论内存是否足够。<br>　　虚引用：java用PhantomReference类来实现虚引用。这个是最弱的一种引用，甚至无法通过虚引用来获取对象。</p>
<h1 id="判断对象是否被引用"><a href="#判断对象是否被引用" class="headerlink" title="判断对象是否被引用"></a>判断对象是否被引用</h1><h2 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h2><p>　　给对象加一个引用计数器，每当一个地方引用它时，计数器就加一，当引用失效时，计数器就减一，任何时刻计数器为０时的对象就是不可能再被使用的。但是有ｂｕｇ，２个对象相互引用，那么这个对象就永远无法被回收。</p>
<h2 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h2><p>　　这个算法是通过一个叫”GC Roots”的对象作为起始点，从这个节点开始向下搜索，搜索的路径叫做引用链，如果可以通过引用链找到这个对象，那么这个对象时有效的，否则，无效，解决了上面2个对象相互引用但是没有别的对象可达的问题，可以作为”GC Roots”的对象有方法区常量引用的对象，虚拟机栈引用的对象，等。目前java就是这种判断模式。</p>
<h1 id="gc垃圾回收算法"><a href="#gc垃圾回收算法" class="headerlink" title="gc垃圾回收算法"></a>gc垃圾回收算法</h1><h2 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h2><p>　　最基础的算法，就是把要回收的对象标记后进行回收，缺点是容易产生大量不连续的内存碎片，如果产生一个大的对象时，由于全是内存碎片，没有整个的内存，因此内存不够就会提前触发垃圾回收，效率很低。</p>
<h2 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h2><p>　　目前主流虚拟机的收集算法之一主要针对新生态对象，初始化时是一比一的算法，就是把内存分为2部分一样大的部分，平时只使用其中一个部分也就是其一半，当发生垃圾回收时，就会把这个部分存活的对象放到另一个部分，这样子就避免了内存碎片，但是要只使用一半的内存，亏损太大划不来，目前主流虚拟机都是用这个算法来回收新生代。IBM研究发现，９８％的新生态对象生存周期很短的，于是一个新的算法出来了，就是把内存分为3部分，8：1：1，每次使用其中的0.9部分，当发生垃圾回收的时候那就把剩余的对象就放到剩余的0.1那里，当然剩余的0.1可能不够那就可以把一部分对象转化为老年态暂时存到老年态里面，这样子就只浪费0.1的内存了，性价比可以。</p>
<h2 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h2><p>　　主要针对老年态对象，由于生存周期较长，不适合复制算法，该算法就是和标记-清除算法的加强版，就是多了一个移动的算法，就是把存活的对象都向一端移动，并且把端边缘的字段干掉</p>
<h2 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h2><p>　　就是把对象划分为新生态和老年态，不同态使用不同不同的收集算法，新生代采用复制算法，老年态使用标记－整理算法或者标记－清除算法，这个也就是主流虚拟机所采用的。</p>
<h1 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h1><p>　　垃圾回收器就是垃圾回收算法的具体实现，我们看看都有哪些垃圾回收器。</p>
<h2 id="serial收集器"><a href="#serial收集器" class="headerlink" title="serial收集器"></a>serial收集器</h2><p>　　一个单线程的垃圾回收器，它在进行垃圾回收时，会让其他所有线程都暂停，直到他垃圾回收完毕，很显然，问题很大。采用的是复制算法。回收新生代对象。</p>
<h2 id="parnew收集器"><a href="#parnew收集器" class="headerlink" title="parnew收集器"></a>parnew收集器</h2><p>　　是serial收集器的多线程版本，没有其他本质的区别</p>
<h2 id="parallel-sacvenge收集器"><a href="#parallel-sacvenge收集器" class="headerlink" title="parallel sacvenge收集器"></a>parallel sacvenge收集器</h2><p>　　这是个新生带收集器，采用的是复制算法。</p>
<h2 id="serial-old收集器"><a href="#serial-old收集器" class="headerlink" title="serial old收集器"></a>serial old收集器</h2><p>　　采用标记－整理算法。单线程。主要配合serial收集器</p>
<h2 id="parnew-old收集器"><a href="#parnew-old收集器" class="headerlink" title="parnew　old收集器"></a>parnew　old收集器</h2><p>　　主要是配合parallel sacvenge收集器这个新生代垃圾回收器使用。</p>
<h2 id="cms收集器"><a href="#cms收集器" class="headerlink" title="cms收集器"></a>cms收集器</h2><p>　　也是老年态收集器，采用标记整理算法。</p>
<h2 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h2><p>　　上述收集器都要相互配合才可以使用，一个负责收集新生代对象，一个负责收集老年态对象。<br>　　但是这个G1不一样，这是个面向服务端的垃圾回收器。<br>　　以下优势：<br>　　１．能充分利用多核CPU来减少暂停时间。<br>　　２．分代收集，自身就可以实现分代收集。<br>　　３．空间整合：整体是采用标记－整理算法实现的收集器，但是局部上也是基于复制算法实现的。<br>　　４.可预测的停顿：让使用者在一定时间内消耗的垃圾回收时间不超过ｎ毫秒。<br>　　其他垃圾回收器回收要么是新生代，要么是老年代，但是G1不一样，虽然依旧保留了新生代和老年代这个概念，但是实际上将这个java堆分成了多个大小相等的独立区域Region，新生代和老年代不再是物理隔离了。他们都是一部分Region的集合（不需要连续）。<br>　　G1使用了一个方法来进行可预测的停顿，G1会跟踪每一个Region堆的垃圾回收价值（回收可用空间和对应时间）,并且维护一个优先列表，当需要进行垃圾回收时就按照这个优先列表来处理。</p>
<h2 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h2><p>　　1.这个Minor GC是针对年轻代的回收，当虚拟机无法为一个新生对象分配空间时。就会发生这个GC操作。<br>　　2.Major GC 是清理老年代。Full GC 是清理整个堆空间—包括年轻代和老年代<br>　　3.每一次GC都会使得整个程序暂停几毫秒，这对用户程序几乎没有反应。</p>
<p>　　</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://skydh.github.io/2018/05/04/java泛型/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="董航">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="why are you so happy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/04/java泛型/" itemprop="url">java 泛型</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-04T11:51:48+08:00">
                2018-05-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="为何有泛型"><a href="#为何有泛型" class="headerlink" title="为何有泛型"></a>为何有泛型</h2><p>　　１．泛型是在编译期间进行校验的以保证类型安全。</p>
<p>　　２．集合不会保证对象的类型，如果不用泛型。那么集合统一用父类object类型来指代，由于java语言的特性，在编译期间，父类和子类都可以用父类来指代，即使在运行期间都是自己的实际类型，集合这个类也是这样的，如果没用用泛型，他们用object这个统一的父类来指代，但是如果在编译期间你要使用子类特有的方法时的话还是要转换成子类类型，现在问题来了，集合类里面什么元素几乎都可以添加，毕竟都是object的子类，但是我们要使用的话，就会出现问题了，我们不知道到底是不是我们要使用的子类，万一集合里面添加了一个不是我们要用的子类，我们转换使用的时候就会报错：java.lang.ClassCastException。</p>
<h2 id="最简单的泛型实例"><a href="#最简单的泛型实例" class="headerlink" title="最简单的泛型实例"></a>最简单的泛型实例</h2><p>　　List<string> list = new ArrayList<string>();</string></string></p>
<p>　　就像这个加了String这个限制，放到集合里面的元素必须是String类型，取出数据的时候也没必要转换为string类型了，因为编译器已经知道了，不需要转换了（额外说下这个多态，多态的原理也正是这个原理，父类可以在编译期间指代子类，但是实际运行还是本身的类型，要是想用子类特有的方法，父类是不行的，虽然确实可以使用，但是编译时不会通过的，会报错，说找不到这个方法。）</p>
<h2 id="自定义泛型接口、泛型类和泛型方法"><a href="#自定义泛型接口、泛型类和泛型方法" class="headerlink" title="自定义泛型接口、泛型类和泛型方法"></a>自定义泛型接口、泛型类和泛型方法</h2><pre><code>class Box&lt;T&gt; {
    private T data;
    public Box() {
    }
    public Box(T data) {
        this.data = data;
    }
    public T getData() {
      return data;
    }
}


public class DemoTest {
    public static void main(String[] args) {
        Box&lt;String&gt; name = new Box&lt;String&gt;(&quot;dh&quot;);
        Box&lt;Integer&gt; age = new Box&lt;Integer&gt;(123);
        System.out.println(&quot;name class:&quot; + name.getClass());      // com.dh.Box
        System.out.println(&quot;age class:&quot; + age.getClass());        // com.dh.Box
        System.out.println(name.getClass() == age.getClass());    // true
    }
}
</code></pre><p>　　在这里我们用Ｔ来来接收来自外部的参数，泛型终究只是编译期的东西，不会带到运行期，主要就是校验所传信息是否正确罢了，当然在逻辑上我们可以理解这是一些不同类（毕竟一个是String类型，一个是Integer类型），但是实际上这些都是相同的类，就是我们在生成对象的时候，给这个对象传了一个类型参数过去，就是这个类型参数是这个类的一点限制，多了一个参数，一个校验参数罢了。</p>
<h2 id="类型通配符"><a href="#类型通配符" class="headerlink" title="类型通配符"></a>类型通配符</h2><pre><code>public class DemoTest {
    public static void main(String[] args) {
        Box&lt;String&gt; name = new Box&lt;String&gt;(&quot;dh&quot;);
        Box&lt;Integer&gt; age = new Box&lt;Integer&gt;(123);
        Box&lt;Number&gt; number = new Box&lt;Number&gt;(456);
        getData(name);
        getData(age);
        getData(number);
          get1rData(number); // 1
        getUpperNumberData(age);    // 2
        getUpperNumberData(number); // 3
    }
    public static void getData(Box&lt;?&gt; data) {
        System.out.println(&quot;data :&quot; + data.getData());
    }
    public static void getUpperNumberData(Box&lt;? extends Number&gt; data){
        System.out.println(&quot;data :&quot; + data.getData());
    }
    public static void get1rData(Box&lt;? super Number&gt; data) {
        System.out.println(&quot;data :&quot; + data.getData());
    }
}
</code></pre><p> 　　结果如下：<br>    data :dh<br>    data :123<br>    data :456<br>    data :456<br>    data :123<br>    data :456<br>　　我们用？来代替具体的参数类型，主要是为了匹配我们创建类ＢＯＸ时用了Ｔ这个形参。？可以说是所有形参的父类。可以指代任何泛型，是实际参数，不是形参。就是固定好的。</p>
<p>　　&lt;? extends T&gt;必须是T和T的子类</p>
<p>　　&lt;? Super T&gt;必须是T或T的父类<br>　　从上面的例子可以很容易的看出来。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://skydh.github.io/2018/05/04/java重写规则/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="董航">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="why are you so happy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/04/java重写规则/" itemprop="url">java 重写规则</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-04T11:39:36+08:00">
                2018-05-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>重写规则之一：重写方法不能比被重写方法限制有更严格的访问级别。<br>（但是可以更广泛，比如父类方法是包访问权限，子类的重写方法是public访问权限。）<br>重写规则之二： 参数列表必须与被重写方法的相同。<br>重写有个孪生的弟弟叫重载，也就是后面要出场的。如果子类方法的参数与父类对应的方法不同，那么就是你认错人了，那是重载，不是重写。<br>重写规则之三：返回类型必须与被重写方法的返回类型相同。<br>父类方法A：void eat(){} 子类方法B：int eat(){} 两者虽然参数相同，可是返回类型不同，所以不是重写。<br>父类方法A：int eat(){} 子类方法B：long eat(){} 返回类型虽然兼容父类，但是不同就是不同，所以不是重写。<br>重写规则之四：重写方法不能抛出新的异常或者比被重写方法声明的检查异常更广的检查异常。但是可以抛出更少，更有限或者不抛出异常。也就是说你自己定义的异常类中，你可以抛出子类，但是不能抛出父类以及以上的类。<br>注意：这种限制只是针对检查异常，至于运行时异常RuntimeException及其子类不再这个限制之中。<br>重写规则之五： 不能重写被标识为final的方法。常量方法啊，很显然。<br>重写规则之六：如果一个方法不能被继承，则不能重写它。如private方法</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://skydh.github.io/2018/05/04/java虚拟机运行时数据区域/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="董航">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="why are you so happy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/04/java虚拟机运行时数据区域/" itemprop="url">java虚拟机运行时数据区域</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-04T11:05:35+08:00">
                2018-05-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h1><p>　　这里必须先提一下操作系统的进程和线程。</p>
<h2 id="什么是进程？"><a href="#什么是进程？" class="headerlink" title="什么是进程？"></a>什么是进程？</h2><p>　　在操作系统中每一个独立的程序单元就是一个进程。每个进程都有相互隔离的内存空间（显然，不然一些流氓进程就可以访问网上银行账号密码等之类的敏感数据了），因此进程之间通信极其不容易。</p>
<h2 id="什么是线程？"><a href="#什么是线程？" class="headerlink" title="什么是线程？"></a>什么是线程？</h2><p>　　线程是进程里面的执行流，每个线程都有自己的程序栈，也有自己TLS,独立的线程私有空间，由于线程是进程里面的一部分，那么线程也可以访问公有内存，线程也有自己私有的空间。因此线程之间的信息交流会非常方便。</p>
<h2 id="线程与进程的关系。"><a href="#线程与进程的关系。" class="headerlink" title="线程与进程的关系。"></a>线程与进程的关系。</h2><p>　　线程是真正的程序执行流，每个程序由一个主线程和多个子线程一起运行工作完成的，因此线程才是真正的程序运行的东东，而进程相当于一个容器，这个容器给线程提供了相对隔离的内存空间，和一个相对安全的访问条件。</p>
<h1 id="jvm-的运行数据分布"><a href="#jvm-的运行数据分布" class="headerlink" title="jvm 的运行数据分布"></a>jvm 的运行数据分布</h1><p>　　了解了一下进程和线程后。我们看看虚拟机的内存分布。</p>
<h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><p>　　程序计数器：是jvm中一小块内存空间，可以当做当前线程的字节码文件的行号，字节码解释器通过改变这个值来获取下一个指令。Java多线程通过线程轮流切换处理器的执行时间来执行的，大家知道现代处理器的原理，每次一个核上只能一个线程进行运转，由于中断，因此每个程序计数器都是独立的，这些程序计数器的所在的内存称为线程私有的内存。如果线程执行的是java方法，那么程序计数器指代的是当前字节码指令的地址，如果是native方法，程序计数器的值为空，这处区域是jvm没有定义OutOfMemoryError错误。就是放代码的地方，通过操作这个栈，来执行这个代码。</p>
<h2 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h2><p>　　打个比方，一般吧java内存粗略分为堆栈，这个虚拟机栈中的局部变量表就是传说中的栈，线程私有的，描述java方法执行的内存模型：每个方法在执行的时候都会建立一个这个;用于存储局部变量表，操作数栈，动态链接，方法出口等，每一个方法从调用到执行完，就代表一个栈帧在虚拟机栈中从入栈到出栈的过程，其中局部变量表存放了编译器可知的基本变量（boolean,int,double,float,char）,还有引用类型（），renturnAddress类型（指向了一个字节码的地址）局部变量表的大小信息在编译期间就确定好了，运行期间不会改变其大小，该虚拟机栈回报2个错误，第一个就是请求的栈帧大于虚拟机栈的深度回报StackOverflowError错误第二个错误就是虚拟机栈动态扩张，扩张到无法申请到内存时报OutOfMemoryError错误。</p>
<h1 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h1><p>　　和虚拟机栈差不多，不过不是java方法是native方法，java规范对native方法的语言和数据格式没有强制要求虚拟机可以自由的去实现它，报的错误也是StackOverflowError错误和OutOfMemoryError错误．</p>
<h2 id="Java堆："><a href="#Java堆：" class="headerlink" title="Java堆："></a>Java堆：</h2><p>　　第一它是所有线程共享的，虚拟机启动创建堆，主要用于存储对象实例和数组，Java垃圾处理器主要处理的就是java堆，因此java堆也被称为gc堆，从内存回收的角度上讲可以划分为新生代和老生代，从内存分配角度讲，可以划分出多个线程私有的内存区域等，java堆有多种划分方式，但是无论怎么划分都是存储对象实例，多重划分是为了更好的划分内存和回收内存，java堆可以位于内存上不连续的空间上，只要逻辑上连续即可，java堆可以实现为固定大小的，也可以实现为可扩展大小的，要是java堆上无法为实例对象分配内存，那么就会报这个OutOfMemoryError．<br>　　堆划分为新生代，老年代，默认比例为１:２，新生代划分为３个区域，eden,From survivor,to survivor,比例为8:1:1。为何呢。参照下面：IBM研究发现，９８％的新生态对象生存周期很短的，于是一个新的算法出来了，就是把内存分为3部分，8：1：1，每次使用其中的0.9部分，当发生垃圾回收的时候那就把剩余的对象就放到剩余的0.1那里，当然剩余的0.1可能不够那就可以把一部分对象转化为老年态暂时存到老年态里面，这样子就只浪费0.1的内存了，性价比可以。<br>　　参数设定：新生代和老年代的比例–XX:NewRatio. 新生代中，eden,from,to的参数为–XX:SurvivorRatio。</p>
<h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区:"></a>方法区:</h2><p>　　各个线程共享的区域，主要存储被虚拟机加载的类信息，常量，静态变量，编译器编译后的代码，和java堆一样逻辑上内存，可扩展的实现大小，这个区域的垃圾回收主要针对常量池的回收和类型的卸载，其中类型的卸载要求比较高，但是必要的垃圾回收是必要的，以前低版本的就出现过严重的内存泄漏。</p>
<h2 id="运行期常量池"><a href="#运行期常量池" class="headerlink" title="运行期常量池:"></a>运行期常量池:</h2><p>　　这个区域也是方法区的一部分，编译后的Class文件中的类名啊，方法名啊，常量啊被加载到虚拟机后就会放到方法去的运行常量池来保存，当然常量不止可以只是在编译期间放到常量池中，还可以用string.intern()方法（如果常量池中存在当前字符串, 就会直接返回当前字符串. 如果常量池中没有此字符串, 会将此字符串放入常量池中后, 再返回）来在运行期间放到常量池中，当然要是常量池中无法申请到内存时就会报出OutOfMemoryError这个经典错误。</p>
<h2 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h2><p>　　直接内存是一个重要的问题，首先它不是运行数据区的部分也不是java虚拟机规范的一部分，这个的出现主要和java1.4后出现的NIO相关，一个基于通道和缓冲区的io方式，它可以使用Native函数库来直接分配堆外内存，然后通过一个存在java堆中的DirectByteBuffer这个对象来对这个java堆外的内存的引用来进行操作，可以提高相关性能，因为避免了java堆和native堆中的来回复制数据。<br>　　那个那么重点来了，既然这个直接内存不归java堆管理，但是也会受到总内存的限制，如果管理员设置课动态扩展的javajvm时，如果忽略了这个直接内存的，最后实际内存总和大于实际内存，当jvm要动态扩展内存时，就会出现这个outofmemoryerror错误。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://skydh.github.io/2018/04/22/java String +操作导致的问题/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="董航">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="why are you so happy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/22/java String +操作导致的问题/" itemprop="url">java String 的+操作导致的问题</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-22T18:24:32+08:00">
                2018-04-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>　　在java中 null既不是对象，也不是一种类型，而是一种特殊的值。在这里我要说的是一种特殊情况哈。</p>
<h2 id="编译器自带的优化"><a href="#编译器自带的优化" class="headerlink" title="编译器自带的优化"></a>编译器自带的优化</h2><p>　　总所周知，我们的java代码中String对象那如果直接用+连连接字符串可能导致效率变低。但是现在在java1.5以后编译器对其自动做了优化，如果你有时间打开反编译的源码看看，你会发现，String a=”b”+”cc”;这个代码在编译器中优化了，优化方式为在这行代码的开始的地方声明一个StringBuilder,然后不断append后面的字符串。因此对于java来说你用StringBuilder和String的+其实效率都是一样的，但是为了保证一个良好的习惯还是用StringBuilder好一点。</p>
<h2 id="导致的问题"><a href="#导致的问题" class="headerlink" title="+导致的问题"></a>+导致的问题</h2><p>　　我们用””+null，这个空对象，会生成一个null字符串。这是为什么呢？<br>　　前文已经提到，我们已经用编译器做了优化，String对象的+被优化为了StringBuilder的append，然而我们看看append的源码，你就会发现为何是null字符串了。</p>
<pre>

         public StringBuilder append(Object obj) {
            return append(String.valueOf(obj));
        }

        @Override
        public StringBuilder append(String str) {
            super.append(str);
            return this;
        }

</pre>
　　查看源码发现，append方法向上调用了其抽象类AbstractStringBuilder方法的append方法，在看
<pre>

     public AbstractStringBuilder append(String str) {
            if (str == null)
                return appendNull();
            int len = str.length();
            ensureCapacityInternal(count + len);
            str.getChars(0, len, value, count);
            count += len;
            return this;
        }
     private AbstractStringBuilder appendNull() {
            int c = count;
            ensureCapacityInternal(c + 4);
            final char[] value = this.value;
            value[c++] = 'n';
            value[c++] = 'u';
            value[c++] = 'l';
            value[c++] = 'l';
            count = c;
            return this;
        }

</pre>
　　你看真相大白了，在这个抽象类的这个append方法中，先进行了判断，如果为null,则是把这个null作为一个字符串加上去。因此解决了上面我们遇到的问题，为何String对象+null,会条件一个null字符串。
　　测试案例如下：
<pre>

    public static void main(String[] args) {
            String a="dh";
            String b=a+null;
            System.out.println(b);

        }
</pre>
　　结果如下：
<pre>
    dhnull
</pre>



          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://skydh.github.io/2018/04/22/java为何方法可以多态而属性没有多态/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="董航">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="why are you so happy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/22/java为何方法可以多态而属性没有多态/" itemprop="url">java属性为什么没多态，而是方法多态</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-22T18:07:37+08:00">
                2018-04-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>　　java多肽的特性：方法具有多态性，属性却没有。</p>
<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>　　基类：</p>
<p><img src="https://raw.githubusercontent.com/skydh/picture/master/%E5%A4%9A%E6%80%81/base.png" alt="aaa"></p>
<p>　　子类：</p>
<p><img src="https://raw.githubusercontent.com/skydh/picture/master/%E5%A4%9A%E6%80%81/child.png" alt="aaa"></p>
<p>　　测试类：</p>
<p><img src="https://raw.githubusercontent.com/skydh/picture/master/%E5%A4%9A%E6%80%81/test%20(1" alt="aaa">.png)</p>
<p>　　结果：</p>
<p><img src="https://raw.githubusercontent.com/skydh/picture/master/%E5%A4%9A%E6%80%81/result.png" alt="aaa"></p>
<h2 id="分析如下"><a href="#分析如下" class="headerlink" title="分析如下"></a>分析如下</h2><p>  父类  a=new 子类，实际对象时子类。由于向上转型，我们可以用父类在编译期间代替子类，使得编译不报错，当然你调用的方法必须是父类所拥有的，不然编译监察报错，</p>
<p>  其实new 子类（）,那么实际类型就是子类，运行期间就是子类的方法和属性啊，而一个父类有多个子类，那么就造成多态的生成和原理，那么问题来了，为什么</p>
<p>  我们的属性不具有多态特性。我们直接调用属性值，那么出来的就是父类的属性值，为什么呢？</p>
<p>  这个就是静态绑定和动态绑定的问题了</p>
<p>  编译期间的绑定就是静态绑定，运行期间的绑定就是动态绑定，java为了实现多态的这个机制，选择让方法在运行期间绑定对应对象所对应实际类型，选择让属性在编译期间绑定其所对应实际类型。那么这个问题不就解决了？</p>
<p>  编译期间时，肯定是父类的类型，如果直接调用属性，故名思议则是父类所对应的属性值。而方法则是在运行期间绑定的，这个对象实际上实际是子类对象，那么运行期间就肯定是子类类型，故方法是子类的方法，而在方法中调用的值是子类的值就更简单了，我们调用子类的值时，实际上简写了this.属性，而this却是指当前对象。当前对象只有被实例化才会有对象，那么肯定是运行期间，故在方法里面调用属性值是子类的值。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://skydh.github.io/2018/04/22/缓冲为何提高效率/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="董航">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="why are you so happy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/22/缓冲为何提高效率/" itemprop="url">io缓冲为何可以提高效率</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-22T18:02:31+08:00">
                2018-04-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>  据我了解，运用FileInputStream读写一段数据是一个字节一个字节的读取，如果有10个字节大小的文件，就要调用10次系统调用，每次将读取的数据赋值给变量，然后程序使用变量。<br>  缓冲区可以看作是一个放在内存中的数组，但是从硬盘中读取数据仍然要使用系统调用，系统调用的读取仍然是每次一个，只是每调用一次之后，将所得到的数据放入缓冲区中的，<br>  然后程序一次性使用10个数据。<br>  我是这样理解的，但是不管用与不用缓冲区，使用的系统调用是一样多的。（不知我的理解正确与否，请指出）如果我理解的是正确的，那么为什么使用缓冲区读写的效率要高呢？？谢谢！</p>
<h2 id="回答"><a href="#回答" class="headerlink" title="回答"></a>回答</h2><p>  理解是对的。<br>  调用I\O操作的时候，实际上还是一个一个的读或者写，关键就在，CPU只有一个，不论是几个核心。CPU在系统调用时，会不会还要参与主要操作？参与多次就会花更多的时间。 系统调用时，<br>  若不用缓冲，CPU会酌情考虑使用 中断。此时CPU是主动地，每个周期中都要花去一部分去询问I\O设备是否读完数据，这段时间CPU不能做任何其他的事情（至少负责执行这段模块的核不能）。所以，调用一次读了一个字，通报一次，CPU腾出时间处理一次。而设置缓冲，CPU通常会使用 DMA 方式去执行 I\O 操作。CPU 将这个工作交给DMA控制器来做，自己腾出时间做其他的事，当DMA完成工作时，DMA会主动告诉CPU“操作完成”。<br>  这时，CPU接管后续工作。在此，CPU 是被动的。DMA是专门 做 I＼O 与 内存 数据交换的，不仅自身效率高，也节约了CPU时间，CPU在DMA开始和结束时做了一些设置罢了。<br>  所以，调用一次，不必通报CPU，等缓冲区满了，DMA 会对C PU 说 “嘿，伙计！快过来看看，把他们都搬走吧”。综上，设置缓冲，就建立了数据块，使得DMA执行更方便，CPU也有空闲，而不是呆呆地候着I\O数据读来。从微观角度来说，设置缓冲效率要高很多。尽管，不能从这个程序上看出来。 几万字的读写\就能看到差距。</p>
<p> 转载自 <a href="http://blog.csdn.net/vic1990/article/details/46236837" target="_blank" rel="noopener">http://blog.csdn.net/vic1990/article/details/46236837</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://skydh.github.io/2018/04/22/lombok/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="董航">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="why are you so happy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/22/lombok/" itemprop="url">lombok 配置使用以及优势</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-22T17:50:48+08:00">
                2018-04-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="maven依赖"><a href="#maven依赖" class="headerlink" title="maven依赖"></a>maven依赖</h2><p>　　<pre></pre></p>
<pre><code>&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
        &lt;artifactId&gt;lombok&lt;/artifactId&gt;
        &lt;version&gt;1.16.20&lt;/version&gt;
        &lt;scope&gt;provided&lt;/scope&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre><p></p>
<h2 id="让你的IDE不报错"><a href="#让你的IDE不报错" class="headerlink" title="让你的IDE不报错"></a>让你的IDE不报错</h2><p>　　更新maven仓库，把lombok的文件拉下来，cmd进入那个目录，然后java -jar  对应jar包，让其运行安装在你的IDE里面。<br>　　在你的eclipse安装目录下的eclipse.ini文件中加入<br>　　-javaagent:lombok.jar<br>　　-Xbootclasspath/a:lombok.jar<br>　　重启eclipse，lombok即可生效</p>
<h2 id="为什么使用？"><a href="#为什么使用？" class="headerlink" title="为什么使用？"></a>为什么使用？</h2><p>　　1,  使得代码整洁许多，大部分entity的get和set方法都是固定不变的，我们使用lombok可以有效的减少源代码的量，只关注最重要的属性。</p>
<p>　　2，曾经遇到一个变态的entity，足足1800行代码，使用lombok后就只用400多行了，这个entity的可读性多了很多</p>
<p>　　3，有些代码没有把属性和方法分隔，可能是遗留代码，也可能是忘了修改，也可能水品和我一样比较差的，导致代码可读性变得弱了好多，如果我们使用了lombok就不会出现这种情况</p>
<p>　　4，还有就是有些情况，有人修改了属性，但是没有修改方法，而且没有报错的那种，等等一系列情况，使用了lombok就可以避免。</p>
<p>　　5，还有就是我们的代码自动生成工具生成的vo也是不够工整，可能是由于某些原因导致的，如果我们使用了这个lombok就可以避免这个问题．</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>   就是元注解出现后注解运行生命周期里面的编译周期，这个就是 JSR 269 Pluggable Annotation Processing API，就是源代码在编译成字节码的时候修改了语法树的节点规则进行了加强生成</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://skydh.github.io/2018/04/22/spring post乱码/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="董航">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="why are you so happy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/22/spring post乱码/" itemprop="url">spring mvc post请求乱码问题</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-22T12:59:44+08:00">
                2018-04-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="如何处理"><a href="#如何处理" class="headerlink" title="如何处理"></a>如何处理</h2><p>　　在web.xml的拦截过滤器上加</p>
<pre><code>&lt;filter&gt;
    &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt;
    &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;encoding&lt;/param-name&gt;
        &lt;param-value&gt;utf-8&lt;/param-value&gt;
    &lt;/init-param&gt;
&lt;/filter&gt;
&lt;filter-mapping&gt;
    &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt;
    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
&lt;/filter-mapping&gt;
</code></pre><p>　　必须放在第一个拦截器上。</p>
<h2 id="数据规范"><a href="#数据规范" class="headerlink" title="数据规范"></a>数据规范</h2><p>　　当前很多浏览器并不发送带Content-Type头部的字符编码标识符，它会把字符编码的决定留在读取HTTP请求的时候。如果客户端没有指明编码，容器用来创建请求读和解析POST数据的默认编码必须是”ISO-8859-1”。然而，为了提示开发者客户端没有成功发送一个字符编码，容器中getCharacterEncoding方法会返回null。<br>　　如果客户端没有设置字符编码，并且请求数据使用了不同编码而不是上述的默认编码，程序将会出现中断。</p>
<h2 id="为何放在第一个过滤器上"><a href="#为何放在第一个过滤器上" class="headerlink" title="为何放在第一个过滤器上"></a>为何放在第一个过滤器上</h2><p>　　为了纠正这种状态。一个新的方法setCharacterEncoding(String enc) 被添加到ServletRequest接口。开发者调用这个方法能重写容器提供的字符编码。这个方法必须在解析request中任何post数据或者读任何输入之前调用。一旦数据已经被读取，调用这个方法不会影响它的编码。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/7/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><span class="page-number current">8</span><a class="page-number" href="/page/9/">9</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><a class="extend next" rel="next" href="/page/9/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">董航</p>
              <p class="site-description motion-element" itemprop="description">clear 航</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">112</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            

          </nav>

          

          <div class="links-of-author motion-element">
            
          </div>

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">董航</span>

  
</div>


<div class="powered-by">
<i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv">
  本站访客数:<span id="busuanzi_value_site_uv"></span>
</span>
</div>

  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.3</div>




        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.3"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
