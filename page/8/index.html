<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="clear 航">
<meta property="og:type" content="website">
<meta property="og:title" content="why are you so happy">
<meta property="og:url" content="https://skydh.github.io/page/8/index.html">
<meta property="og:site_name" content="why are you so happy">
<meta property="og:description" content="clear 航">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="why are you so happy">
<meta name="twitter:description" content="clear 航">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://skydh.github.io/page/8/"/>





  <title>why are you so happy</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">why are you so happy</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">clear 航</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://skydh.github.io/2018/04/21/缓存穿透和缓存雪崩/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="董航">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="why are you so happy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/21/缓存穿透和缓存雪崩/" itemprop="url">缓存穿透和缓存雪崩</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-21T20:44:07+08:00">
                2018-04-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><p>　　缓存穿透是查询一个不存在的数据，由于不存在，所以缓存里面没有，那么缓存查不到，就走查询数据库，由于数据库里面也不存在，那么也不写入缓存，导致这个不存在的数据每次都要到数据库中查询，导致缓存穿透。<br>　　方案：简单利落的方式：就是把这个查询返回的空数据缓存下来，过期时间很短就好了。</p>
<h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><p>　　就是缓存就是集中在一段时间内全部失效，发生了大量的缓存穿透，导致大量的查询走到了数据库，严重时可能导致数据库宕机，从而引发连锁反应，导致整个系统崩溃了。（可以采用熔断模式来熔断。）<br>　　方案：在缓存失效后通过加锁来控制线程数量。或者设置一个算法，让这个ｋｅｙ的过期时间尽可能均匀。</p>
<h2 id="缓存预热"><a href="#缓存预热" class="headerlink" title="缓存预热"></a>缓存预热</h2><p>　　就是在系统上线后，将相关数据直接加载到缓存系统中去，这样可以避免，当用户请求时再去加载相关数据。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://skydh.github.io/2018/04/03/单例模式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="董航">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="why are you so happy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/03/单例模式/" itemprop="url">单例模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-03T14:57:07+08:00">
                2018-04-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>　　单例模式是24种单例模式中最为基本简单的设计模式。单例模式是为了这个类只提供一个对外的实例。单例模式的基本思想是，构造函数私有化，外部无法直接创建一个实例，只能通过该类的静态方法来获取对象实例。</p>
<h2 id="饿汉模式"><a href="#饿汉模式" class="headerlink" title="饿汉模式"></a>饿汉模式</h2><p>　　饿汉模式就是说这个实例在类加载初始化的时候就加载好了，因为特别急，所以戏称饿汉模式。</p>
<p><pre><br>    public class Singleton{<br>        private Singleton(){}<br>        private static Singleton single=new Singleton();<br>        public static Singleton getInstance()<br>        {<br>        return single<br>        }<br>    }<br></pre></p>
<h2 id="懒汉模式"><a href="#懒汉模式" class="headerlink" title="懒汉模式"></a>懒汉模式</h2><p>　　懒汉模式，顾名思义，就是说我懒得在没人用就创建，等到有人要用的时候就第一次创建，后面的调用方就直接用第一次创建的对象。所以戏称为懒汉模式。</p>
<p><pre><br>    public class Singleton{<br>            private Singleton(){}<br>            public static Singleton single=null;<br>            public static Singleton getInstance(){<br>            if(singleton==null)<br>            {<br>            single=new Singleton();<br>            }<br>            return single;<br>    }<br>    }<br></pre><br>　　但是有问题，在多线程并发的情况下，这个单例类还没有创建第一个实例时，多个线程同时进入到了if(singleton==null)这个条件里面，就会创建多个实例。考虑到线程安全，可以在这个getInstance这个方法里面这个非null判断加个类锁(静态方法属于这个类本身，所以加类锁)。</p>
<p><pre><br>    public class Singleton{<br>            private Singleton(){}<br>            public static Singleton single=null;<br>            public static Singleton getInstance(){<br>                synchronized(Singleton3.class){<br>                    if(singleton==null)<br>                    {<br>                        single=new Singleton();<br>                    }<br>            }<br>            return single;<br>        }<br>    }<br></pre><br>　　但是每一次创建类的时候都要加锁，对系统性能有很大的影响。</p>
<p><pre><br>        public class Singleton{<br>            private Singleton(){}<br>            private static Singleton single=null;<br>            public static Singleton getInstance(){<br>                if(single==null)<br>                {<br>                    synchronized(Singleton.class)<br>                    {<br>                        if(single==null){<br>                        single=new Singleton()}<br>                    }<br>                }<br>                return single;<br>            }<br>        }<br></pre><br>　　这里２重锁非null判断，我们这里的话我们只是第一次创建对象的时候加了锁，而后面的获取对象就不用加锁了。恩，暂时没有问题了。</p>
<p>　　为什么要２个非空判断呢？<br>　　A,B2个线程获取实例，都经过了第一个非空判断，A先获取到了类锁，进行初始化，B进入锁等待。A初始化后释放锁，B获取到锁，如果不再进行一次非空判断，就会再次创建一个对象。</p>
<p>　　为什么必须要volatile关键字呢？<br>　　显然这样还不行，这里涉及到指令重排序问题。在上述的双重锁机制中，有的线程可能访问到没有被初始化的资源。<br>　　这是因为　single=new Singleton()这段代码不是原子的，它可以分解为３个操作。</p>
<pre><code>memory = allocate();   //1：分配对象的内存空间
instance = memory;     //3：设置instance指向刚分配的内存地址
                       //注意，此时对象还没有被初始化！
ctorInstance(memory);  //2：初始化对象
</code></pre><p>　　根据java语言规范，在单线程中2和3操作的顺序是不影响程序执行效果的，那么这个顺序就是可以打乱的了，但是在多线程中这个可能会有影响，当a线程第一次访问时，获取到了类锁，进行对象创建，而马上第二个线程b,也访问到了，开始访问第一个非null判断，而a线程创建对象时，到了第3步，没有进行初始化，那么b线程返回的结果可能是一个没有初始化的对象。所以可能出现问题。<br>　　那么怎么解决呢？<br>　　那就是给这个要初始化的对象加volatile关键字，来禁止指令重排序，问题完美解决。</p>
<h2 id="枚举方式实现单例"><a href="#枚举方式实现单例" class="headerlink" title="枚举方式实现单例"></a>枚举方式实现单例</h2><pre><code>public enum Singleton{
    INSTANCE;
}
</code></pre><p>　　我们可以通过Singleton.INSTANCE来访问实例。创建枚举默认就是线程安全的，还能防止反序列化导致重新创建新的对象。不然就要像其他单例模式一样要重写readObject方法。
　　</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://skydh.github.io/2018/03/26/shiro 学习/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="董航">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="why are you so happy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/26/shiro 学习/" itemprop="url">shiro学习</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-26T09:45:54+08:00">
                2018-03-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="学习原因"><a href="#学习原因" class="headerlink" title="学习原因"></a>学习原因</h2><p>　　１.我不会，所以要学习啊。<br>　　２．这边我需要用它来完成登录安全认证。</p>
<h2 id="shiro-概念"><a href="#shiro-概念" class="headerlink" title="shiro 概念"></a>shiro 概念</h2><p>　　Subject:用户。<br>　　SecurityManager：安全管理器；即所有与安全有关的操作都会与SecurityManager交互；且它管理着所有Subject；可以看出它是Shiro的核心，它负责与后边介绍的其他组件进行交互，如果学习过SpringMVC，你可以把它看成DispatcherServlet前端控制器；<br>　　Authenticator:认证器。<br>　　Authorizer:授权器。<br>　　Realm:域，，Shiro从从Realm获取安全数据（如用户、角色、权限），就是说SecurityManager要验证用户身份，那么它需要从Realm获取相应的用户进行比较以确定用户身份是否合法；也需要从Realm得到用户相应的角色/权限进行验证用户是否能进行操作；可以把Realm看成DataSource，即安全数据<br>　　sessionmanager:会话管理器。<br>　　sessionDAO:session数据访问对象。<br>　　cacheManager:缓存控制器，可以和redis集成。　</p>
<h2 id="身份认证流程如下："><a href="#身份认证流程如下：" class="headerlink" title="身份认证流程如下："></a>身份认证流程如下：</h2><p>　　代码如下：</p>
<pre>
    public class ShiroTest {
        @Test
        public void test() {
            Factory<securitymanager> factory = new IniSecurityManagerFactory("classpath:shiro.ini");
            // 2、得到SecurityManager实例 并绑定给SecurityUtils
            SecurityManager securityManager = factory.getInstance();
            SecurityUtils.setSecurityManager(securityManager);
            // 3、得到Subject及创建用户名/密码身份验证Token（即用户身份/凭证）
            Subject subject = SecurityUtils.getSubject();
            UsernamePasswordToken token = new UsernamePasswordToken("zhang", "123");
            try {
                // 4、登录，即身份验证
                subject.login(token);
                System.out.println("222");
            } catch (AuthenticationException e) {
                System.out.println("111");
            }
            Assert.assertEquals(true, subject.isAuthenticated()); // 断言用户已经登录
            // 6、退出
            subject.logout();
        }

    }


</securitymanager></pre>
<pre>
    声明一个realm  
    myRealm1=com.github.zhangkaitao.shiro.chapter2.realm.MyRealm1  
    myRealm2=com.github.zhangkaitao.shiro.chapter2.realm.MyRealm2  
    指定securityManager的realms实现  
    securityManager.realms=$myRealm1,$myRealm2 
</pre>
<pre>
    public class MyRealm1 implements Realm {  
        @Override  
        public String getName() {  
            return "myrealm1";  
        }  
        @Override  
        public boolean supports(AuthenticationToken token) {  
            //仅支持UsernamePasswordToken类型的Token  
            return token instanceof UsernamePasswordToken;   
        }  
        @Override  
        public AuthenticationInfo getAuthenticationInfo(AuthenticationToken token) throws AuthenticationException {  
            String username = (String)token.getPrincipal();  //得到用户名  
            String password = new String((char[])token.getCredentials()); //得到密码  
            if(!"zhang".equals(username)) {  
                throw new UnknownAccountException(); //如果用户名错误  
            }  
            if(!"123".equals(password)) {  
                throw new IncorrectCredentialsException(); //如果密码错误  
            }  
            //如果身份认证验证成功，返回一个AuthenticationInfo实现；  
            return new SimpleAuthenticationInfo(username, password, getName());  
        }  
    }   
</pre>

<p>　　首先调用Subject.login(token)进行登录，其会自动委托给Security Manager，调用之前必须通过SecurityUtils. setSecurityManager()设置；<br>　　SecurityManager负责真正的身份验证逻辑；它会委托给Authenticator进行身份验证；<br>　　Authenticator才是真正的身份验证者，Shiro API中核心的身份认证入口点，此处可以自定义插入自己的实现；<br>　　Authenticator可能会委托给相应的AuthenticationStrategy进行多Realm身份验证，默认ModularRealmAuthenticator会调用AuthenticationStrategy进行多Realm身份验证；<br>　　Authenticator会把相应的token传入Realm，从Realm获取身份验证信息，如果没有返回/抛出异常表示身份验证失败了。此处可以配置多个Realm，将按照相应的顺序及策略进行访问。</p>
<h2 id="授权管理"><a href="#授权管理" class="headerlink" title="授权管理"></a>授权管理</h2><p>　　主体，即访问应用的用户，在Shiro中使用Subject代表该用户。用户只有授权后才允许访问相应的资源。<br>　　资源，在应用中用户可以访问的任何东西，比如访问JSP页面、查看/编辑某些数据、访问某个业务方法、打印文本等等都是资源。用户只要授权后才能访问。<br>　　权限，安全策略中的原子授权单位，通过权限我们可以表示在应用中用户有没有操作某个资源的权力。即权限表示在应用中用户能不能访问某个资源，如：访问用户列表页面，查看/新增/修改/删除用户数据（即很多时候都是CRUD（增查改删）式权限控制），打印文档等等。。<br>　　角色代表了操作集合，可以理解为权限的集合，一般情况下我们会赋予用户角色而不是权限，即这样用户可以拥有一组权限，赋予权限时比较方便。典型的如：项目经理、技术总监、CTO、开发工程师等都是角色，不同的角色拥有一组不同的权限。<br>　　权限的话，可以有单个资源的权限的crud，也可以使是单个实例的crud哦。</p>
<h2 id="自身项目如何用的shiro"><a href="#自身项目如何用的shiro" class="headerlink" title="自身项目如何用的shiro"></a>自身项目如何用的shiro</h2><p>　　项目是基于ssm的框架。<br>　　首先在web.xml上配置shiro拦截器。DelegatingFilterProxy作用是自动到spring容器查找名字为shiroFilter（filter-name） 的bean并把 所有Filter的操作委托给它。然后将ShiroFilter配置到spring容器即可<br>    <filter><br>        <filter-name>shiroFilter</filter-name><br>        <filter-class>org.springframework.web.filter.DelegatingFilterProxy</filter-class><br>        <async-supported>true</async-supported><br>        <init-param><br>            <param-name>targetFilterLifecycle</param-name><br>            <param-value>true</param-value><br>        </init-param><br>    </filter></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://skydh.github.io/2018/03/20/java动态代理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="董航">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="why are you so happy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/20/java动态代理/" itemprop="url">java 动态代理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-20T09:27:10+08:00">
                2018-03-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>　　java动态代理是个很有用的东西，很多开源框架都用到了这个。比如aop等。</p>
<h2 id="简单demo"><a href="#简单demo" class="headerlink" title="简单demo"></a>简单demo</h2><p><pre><br>    package com.dh.test;<br>    public interface PersonDao {<br>        public void say();<br>    }<br></pre><br>　　接口，java动态代理必须有个接口。</p>
<p><pre><br>        package com.dh.test;<br>        public class PersonDaoImpl implements PersonDao{<br>            @Override<br>            public void say() {<br>                System.out.println(“time to eat”);<br>            }  </pre></p>
<pre><code>}
</code></pre><p><br>　　接口的实现。</p>
<p><pre><br>    package com.dh.test;<br>    import java.lang.reflect.InvocationHandler;<br>    import java.lang.reflect.Method;<br>    public class PersonHandler implements InvocationHandler {<br>        private Object obj;<br>        public PersonHandler(Object obj) {<br>            this.obj = obj;<br>        }<br>        @Override<br>        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {<br>            System.out.println(“before”);<br>            Object result = method.invoke(obj, args);<br>            System.out.println(“after”);<br>            return result;<br>        }<br>    }<br></pre><br>　　这个是动态要加强的东西。</p>
<p><pre><br>    package com.dh.test;<br>    import java.lang.reflect.Proxy;<br>    public class PersonTest {<br>    public static void main(String args[]) {<br>        PersonDao pDao = new PersonDaoImpl();<br>        PersonHandler handler = new PersonHandler(pDao);<br>        PersonDao proxy = (PersonDao) Proxy.newProxyInstance(pDao.getClass().getClassLoader(),<br>                pDao.getClass().getInterfaces(), handler);<br>        proxy.say();<br>    }<br>    }<br>    }<br></pre><br>　　运行这个得到结果。</p>
<p><pre><br>    before<br>    time to eat<br>    after<br></pre></p>
<h2 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h2><p>　　代码先从这个Proxy的newProxyInstance开始解析，注释就写在代码上面</p>
<p><pre><br>    @CallerSensitive<br>        public static Object newProxyInstance(ClassLoader loader， Class&lt;?&gt;[] interfaces,InvocationHandler h)<br>            throws IllegalArgumentException<br>        {<br>        /*</pre></p>
<pre><code> *  这个方法校验这个实现了InvocationHandler接口的加强类是否为空
 */
    Objects.requireNonNull(h);
    final Class&lt;?&gt;[] intfs = interfaces.clone();
    final SecurityManager sm = System.getSecurityManager();
    if (sm != null) {
        checkProxyAccess(Reflection.getCallerClass(), loader, intfs);
    }
    /*
     * Look up or generate the designated proxy class.
     * 这是生成class的地方。
     */
    Class&lt;?&gt; cl = getProxyClass0(loader, intfs);
    /*
     * Invoke its constructor with the designated invocation handler.
     * 使用我们实现的InvocationHandler作为参数调用构造方法来获得代理类的实例 
     */
    try {
        if (sm != null) {
            checkNewProxyPermission(Reflection.getCallerClass(), cl);
        }

        final Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams);
        final InvocationHandler ih = h;
        if (!Modifier.isPublic(cl.getModifiers())) {
            AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() {
                public Void run() {
                    cons.setAccessible(true);
                    return null;
                }
            });
        }
        return cons.newInstance(new Object[]{h});
    } catch (IllegalAccessException|InstantiationException e) {
        throw new InternalError(e.toString(), e);
    } catch (InvocationTargetException e) {
        Throwable t = e.getCause();
        if (t instanceof RuntimeException) {
            throw (RuntimeException) t;
        } else {
            throw new InternalError(t.toString(), t);
        }
    } catch (NoSuchMethodException e) {
        throw new InternalError(e.toString(), e);
    }
}
</code></pre><p><br>　　下面是对生成代理类的代码</p>
<pre>

<pre><code>private static Class&lt;?&gt; getProxyClass0(ClassLoader loader, Class&lt;?&gt;... interfaces) {
  //被代理类的接口不得超过65535个
      if (interfaces.length &gt; 65535) {
          throw new IllegalArgumentException(&quot;interface limit exceeded&quot;);
      }
      // If the proxy class defined by the given loader implementing
      // the given interfaces exists, this will simply return the cached copy;
      // otherwise, it will create the proxy class via the ProxyClassFactory
      //JDK对代理进行了缓存，如果已经存在相应的代理类，则直接返回，否则才会通过ProxyClassFactory来创建代理  
      return proxyClassCache.get(loader, interfaces);
  }
</code></pre><p></p></pre><br>　　我们进入　proxyclassCache里面找到其参数为内部类ProxyClassFactory，进去看看<p></p>
<pre>

<pre><code>private static final class ProxyClassFactory  
    implements BiFunction&lt;ClassLoader, Class&lt;?&gt;[], Class&lt;?&gt;&gt; {  
    // 所有代理类名字的前缀  
    private static final String proxyClassNamePrefix = &quot;$Proxy&quot;;  
    // 用于生成代理类名字的计数器  
    private static final AtomicLong nextUniqueNumber = new AtomicLong();  
    @Override  
    public Class&lt;?&gt; apply(ClassLoader loader, Class&lt;?&gt;[] interfaces) {  
        // 省略验证代理接口的代码……  
        String proxyPkg = null;     // 生成的代理类的包名  
        // 对于非公共接口，代理类的包名与接口的相同  
        for (Class&lt;?&gt; intf : interfaces) {  
            int flags = intf.getModifiers();  
            if (!Modifier.isPublic(flags)) {  
                String name = intf.getName();  
                int n = name.lastIndexOf(&apos;.&apos;);  
                String pkg = ((n == -1) ? &quot;&quot; : name.substring(0, n + 1));  
                if (proxyPkg == null) {  
                    proxyPkg = pkg;  
                } else if (!pkg.equals(proxyPkg)) {  
                    throw new IllegalArgumentException(  
                        &quot;non-public interfaces from different packages&quot;);  
                }  
            }  
        }  
        // 对于公共接口的包名，默认为com.sun.proxy  
        if (proxyPkg == null) {  
            proxyPkg = ReflectUtil.PROXY_PACKAGE + &quot;.&quot;;  
        }  
        // 获取计数  
        long num = nextUniqueNumber.getAndIncrement();  
        // 默认情况下，代理类的完全限定名为：com.sun.proxy.$Proxy0，com.sun.proxy.$Proxy1……依次递增  
        String proxyName = proxyPkg + proxyClassNamePrefix + num;  
        // 这里才是真正的生成代理类的字节码的地方  
        byte[] proxyClassFile = ProxyGenerator.generateProxyClass(  
            proxyName, interfaces);  
        try {  
            // 根据二进制字节码返回相应的Class实例  
            return defineClass0(loader, proxyName,  
                                proxyClassFile, 0, proxyClassFile.length);  
        } catch (ClassFormatError e) {  
            throw new IllegalArgumentException(e.toString());  
        }  
    }  
}  
</code></pre><p></p></pre><br>　　看看怎么生成字节码<p></p>
<pre>

<pre><code>public static byte[] generateProxyClass(final String var0, Class[] var1) {  
    ProxyGenerator var2 = new ProxyGenerator(var0, var1);  
    final byte[] var3 = var2.generateClassFile();  
    // 这里根据参数配置，决定是否把生成的字节码（.class文件）保存到本地磁盘，我们可以通过把相应的class文件保存到本地，再反编译来看看具体的实现，这样更直观  
    if(saveGeneratedFiles) {  
        AccessController.doPrivileged(new PrivilegedAction() {  
            public Void run() {  
                try {  
                    FileOutputStream var1 = new FileOutputStream(ProxyGenerator.dotToSlash(var0) + &quot;.class&quot;);  
                    var1.write(var3);  
                    var1.close();  
                    return null;  
                } catch (IOException var2) {  
                    throw new InternalError(&quot;I/O exception saving generated file: &quot; + var2);  
                }  
            }  
        });  
    }  
    return var3;  
}  
</code></pre><p></p></pre><br>　　这是反编译的生成代理类<p></p>
<p><pre><br>    package com.sun.proxy;<br>    import com.mikan.proxy.HelloWorld;<br>    import java.lang.reflect.InvocationHandler;<br>    import java.lang.reflect.Method;<br>    import java.lang.reflect.Proxy;<br>    import java.lang.reflect.UndeclaredThrowableException;<br>    public final class $Proxy0 extends Proxy implements HelloWorld {<br>      private static Method m1;<br>      private static Method m3;<br>      private static Method m0;<br>      private static Method m2;<br>      public $Proxy0(InvocationHandler paramInvocationHandler) {<br>        super(paramInvocationHandler);<br>      }<br>      public final boolean equals(Object paramObject) {<br>        try {<br>          return ((Boolean)this.h.invoke(this, m1, new Object[] { paramObject })).booleanValue();<br>        }<br>        catch (Error|RuntimeException localError) {<br>          throw localError;<br>        }<br>        catch (Throwable localThrowable) {<br>          throw new UndeclaredThrowableException(localThrowable);<br>        }<br>      }<br>      public final void sayHello(String paramString) {<br>        try {<br>          this.h.invoke(this, m3, new Object[] { paramString });<br>          return;<br>        }<br>        catch (Error|RuntimeException localError) {<br>          throw localError;<br>        }<br>        catch (Throwable localThrowable) {<br>          throw new UndeclaredThrowableException(localThrowable);<br>        }<br>      }<br>      public final int hashCode() {<br>        try {<br>          return ((Integer)this.h.invoke(this, m0, null)).intValue();<br>        }<br>        catch (Error|RuntimeException localError) {<br>          throw localError;<br>        }<br>        catch (Throwable localThrowable) {<br>          throw new UndeclaredThrowableException(localThrowable);<br>        }<br>      }<br>      public final String toString() {<br>        try {<br>          return (String)this.h.invoke(this, m2, null);<br>        }<br>        catch (Error|RuntimeException localError) {<br>          throw localError;<br>        }<br>        catch (Throwable localThrowable) {<br>          throw new UndeclaredThrowableException(localThrowable);<br>        }<br>      }<br>      static {<br>        try {<br>          m1 = Class.forName(“java.lang.Object”).getMethod(“equals”, new Class[] { Class.forName(“java.lang.Object”) });<br>          m3 = Class.forName(“com.mikan.proxy.HelloWorld”).getMethod(“sayHello”, new Class[] { Class.forName(“java.lang.String”) });<br>          m0 = Class.forName(“java.lang.Object”).getMethod(“hashCode”, new Class[0]);<br>          m2 = Class.forName(“java.lang.Object”).getMethod(“toString”, new Class[0]);<br>          return;<br>        }<br>        catch (NoSuchMethodException localNoSuchMethodException) {<br>          throw new NoSuchMethodError(localNoSuchMethodException.getMessage());<br>        }<br>        catch (ClassNotFoundException localClassNotFoundException) {<br>          throw new NoClassDefFoundError(localClassNotFoundException.getMessage());<br>        }<br>      }<br>    }<br> </pre><br>　　恩，大致如此，其实吧就是把源码考了过来，读了一下就这样。<br>　　继承了Proxy类，实现了代理的接口，由于java不能多继承，这里已经继承了Proxy类了，不能再继承其他的类，所以JDK的动态代理不支持对实现类的代理，只支持接口的代理。<br>　　提供了一个使用InvocationHandler作为参数的构造方法。<br>　　流程：<br>　　１．Proxy的这个newProxyInstance方法返回生成的代理类。<br>　　２．这个Proxy的这个newProxyInstance方法的getProxyClass0方法返回代理类的class，没有加载，没有初始化。<br>　　３．这个方法通过ProxyClassFactory这个内部类获取生成的class.<br>　　４．上面那个内部类的apply方法调用ProxyGenerator.generateProxyClass生成class文件的Byte数组。然后组合生成代理类的class返回给newProxyInstance然后在通过反射生成对象返回。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://skydh.github.io/2018/03/19/mysql连接算法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="董航">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="why are you so happy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/19/mysql连接算法/" itemprop="url">mysql联接算法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-19T22:19:31+08:00">
                2018-03-19
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>　　联接算法是MySQL数据库处理联接的物理策略，目前支持Nested-Loops Join算法，时间复杂度为O(N)有索引，无的话为o(N2).<br>这个是没有索引的表联接</p>
<pre>
    For each row r in R do
        For each row s in S do
            If r and s satisfy the join condition
                Then output the tuple <r, s="">
</r,></pre>
　　然而真实情况mysql没有采用这种算法。是这样的：
　　把驱动表的要select的数据，丢到join_buffer中内存。再扫描被驱动表，取出一行行数据对比，满足条件的作为结果集返回。和上面的算法比较，比较次数，扫描次数一样，但是是内存，因此效率高很多。显然join_buffer可能不够大，默认是256k，join_buffer_size这个参数确定，    分段处理    ，放满了join_buffer，比较，然后清空join_buffer，再放入驱动表的数据。比较，直到走完。但是分段次数太多，可能导致扫描次数变多。因此，可以将join_buffer这个调大一点。

　　时间复杂度为o(R*S)
　　这个是有索引的
<pre>
    For each row r in R do
        lookup r in S index
            If find s == r
               Then output the tuple <r, s="">
</r,></pre>

<p>　　对于对于联接的列含有索引的情况，外部表的每条记录不再需要扫描整张内部表，只需要扫描内部表上的索引即可得到联接的判断结果。<br>　　根据前面描述的Simple Nested-Loops Join算法，优化器在一般情况下总是选择将联接列含有索引的表作为内表。如果两张表R和S在联接列上都有索引，并且索引的高度相同，那么优化器会选择记录数少的表作为外部表，这是因为内部表的扫描次数总是索引的高度，与记录的数量无关。</p>
<p>　　如果联接表没有索引时，Simple Nested-Loops Join算法扫描内部表很多次，执行效率会非常差。而Block Nested-Loops Join算法就是针对没有索引的联接情况设计的，其使用Join Buffer（联接缓存）来减少内部循环取表的次数。<br>　　对这个没有太大注意，反正效率不高就是了。最好还是加上索引用第一个最好了。<br>　　对于left join 那么一定是左边的表作为外部表，即使右边表没有索引而自身有索引。<br>　　对于　right join 那么一定是右边的表作为外部表，即使左侧表无索引，而右侧表有索引。</p>
<p>　　为了效率：<br>　　１．我们一般左连接，那么希望２表连接的话，小数据量的放到左边。<br>　　２．左连接，左边表字段是否有索引不关心，右边表必须要有索引。<br>　　３．表连接最好加上索引，否则另外一个算法效率很低。<br>　　４.内连接比左右连接方便，是因为内连接可以自身优化左右表的顺序。原则如下：１，若都有索引，默认数据量小的表作为外部表。即时加了索引缩小范围。２，若只有一个表有索引，那么默认没有索引的表作为外部表。３，若都没有索引，那么默认Block Nested-Loops Join算法。<br>　　ps:这里的小表：是指按照各自的条件过滤后，这些判断是要走索引的，不然和全表扫描没区别了。计算参与join的各个字段的总数据量，这个总数据量小的，就是小表。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://skydh.github.io/2018/03/18/spring事务机制/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="董航">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="why are you so happy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/18/spring事务机制/" itemprop="url">spring 事务机制</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-18T17:13:06+08:00">
                2018-03-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://skydh.github.io/2018/03/18/redis入门学习/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="董航">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="why are you so happy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/18/redis入门学习/" itemprop="url">redis入门学习</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-18T17:11:52+08:00">
                2018-03-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="NOSQL"><a href="#NOSQL" class="headerlink" title="NOSQL"></a>NOSQL</h2><p>　　为什么需要NOSQL?<br>　　１．高并发读写。<br>　　２．海量数据的高效率的存储和访问。<br>　　３．高可扩展和高可用性。<br>　　什么是NOSQL?<br>　　NOSQL是not only sql。非关系数据库。<br>　　NOSQL数据库的四大分类。<br>　　键值存储：ｒｅｄｉｓ．<br>　　列存储：ＨＢＡＳＥ，<br>　　文档数据库：ＭＯＮＧＤＢ．<br>　　图形数据库：Ｎｅｏ４ｊ，</p>
<p><img src="https://raw.githubusercontent.com/skydh/picture/master/nosql.png" alt="aaa"></p>
<h2 id="Redis概述"><a href="#Redis概述" class="headerlink" title="Redis概述"></a>Redis概述</h2><p>　　高性能的键值对数据库，也是内存数据库很快，支持很多键值数据类型：<br>　　字符串类型。<br>　　列表类型。<br>　　有序集合类型。<br>　　散列类型。<br>　　集合类型。<br>　　Redis主要用于场景。<br>　　缓存。　任务队列。网站访问统计等。</p>
<h2 id="Redis安装"><a href="#Redis安装" class="headerlink" title="Redis安装"></a>Redis安装</h2><p>　　工具：CentOS,虚拟机VM,FileZilla,SecureCRT,官网下载的redis压缩包这5个工具。<br>　　１，打开虚拟机，用ifconfig查看网络地址，然后打开SecureCRT连接到这个虚拟机，然后进行操作.<br>　　２．打开FileZilla,连上虚拟机，然后找到找到文件传送到虚拟机里面的centos里面。<br>　　３．安装Gcc环境：yum install gcc c++,在线安装gcc。<br>　　４，解压这个redis压缩包。命令如下： tar -zxvf redis-4.0.8.tar.gz。然后进入到解压的包里面，编译这个redis。命令是： make,好了之后就是安装了，命令如下所示：make PREFIX=/usr/local/redis install,中间的是我的安装路径。然后进入到解压路径，找到redis.conf这个文件，复制到安装路径。命令如下：cp redis.conf /usr/local/redis。然后进入到安装路径下，找到这个文件打开编辑这个文件，将 daemonize no,改成yes。再然后启动redis,进入到安装目录的redis包下命令如下: ./bin/redis-server ./redis.conf。然后用这个命令：ps -ef | grep -i redis查看redis是否成功启动。，进入到redis的操作界面命令如下： redis.cli进行交互。至此，安装完毕</p>
<h2 id="jedis介绍"><a href="#jedis介绍" class="headerlink" title="jedis介绍"></a>jedis介绍</h2><p>　　Jedis是redis的基本连接java操作接口。是redis官网首选的java客户端开发包。注意地址你要先ifconfig，查看地址。<br>代码演示下</p>
<pre>

    public class JunitTest {
        @Test
        public void demo1() {
            //System.out.println("111");
            Jedis jedis = new Jedis("192.168.1.106", 6379);
            jedis.set("name1", "dh");
            System.out.println(jedis.get("name1"));
            jedis.close();
        }

    }
</pre>

<p><pre><br>    @Test<br>    public void demo2() {<br>        // System.out.println(“111”);</pre></p>
<pre><code>    JedisPoolConfig jedisPoolConfig = new JedisPoolConfig();
    // 最大数
    jedisPoolConfig.setMaxTotal(20);
    // 最大空闲数
    jedisPoolConfig.setMaxIdle(10);

    JedisPool jedisPool = new JedisPool(jedisPoolConfig, &quot;192.168.1.106&quot;, 6379);

    Jedis jedis = null;
    try {
        jedis = jedisPool.getResource();
        jedis.set(&quot;name1&quot;, &quot;dh&quot;);
        System.out.println(jedis.get(&quot;name1&quot;));
    } catch (Exception e) {
    } finally {
        jedis.close();
        jedisPool.close();
    }

}
</code></pre><p><br>　　相关的maven1依赖自己加。这里我要说的是以下几点，第一。直接运行会报错的，很多原因，CentOs方案如下：<br>　　１.开启防火墙：systemctl start firewalld.service<br>　　２．开启端口firewall-cmd –zone=public –add-port=80/tcp –permanent<br>　　命令含义：<br>　　–zone #作用域<br>　　–add-port=80/tcp #添加端口，格式为：端口/通讯协议<br>　　–permanent #永久生效，没有此参数重启后失效<br>　　３．重启防火墙：firewall-cmd –reload<br>　　４．修改上面redis包下的redis.conf文件1&gt;注释掉bind<br>   为#bind 127.0.0.1<br>　　2&gt;默认不是守护进程方式运行，这里可以修改<br>　　daemonize yes<br>　　3&gt;禁用保护模式<br>　　protected-mode no<br>　　５．若是SecureCRT无法连接虚拟机，输入：systemctl restart sshd.service<br>　　然后在运行，搞定。</p>
<h2 id="redis基本数据结构"><a href="#redis基本数据结构" class="headerlink" title="redis基本数据结构"></a>redis基本数据结构</h2><p>　　五大基本数据类型：字符串（String）,字符串列表（list）,有序字符创集合（sorted set）,哈希（hash）,字符串集合（set）<br>　　key定义的注意点：1,key值不要太长，不要超过1024字节。2,不要太短，可读性太差，3命名规范</p>
<h3 id="字符串String"><a href="#字符串String" class="headerlink" title="字符串String"></a>字符串String</h3><p>　　存入redis是2进制操作的，最大是512M.<br>　　基本命令：赋值：set company yonyou,取值 get company,取值并且赋值getset company baidu “mmm”,删除 del company.加值操作： incr num，若num不存在，那么创建值为0，且加一，若是存在那么加一，若是无法转为整形，报错。同样还有decr num是减一操作。incrby num 5,这是一次加5，其余的和incr一样，decrby num 5,这是和incryby相反的。append compay dh,是在company这个key的value的值后面添加一个字符串。返回值为字符串长度。若是不存在，那么直接创建这个值。<br>　　基本用法：将用户信息序列化之后存到redis里面。然后取出反序列化。<br>　　数据结构：数据结构类似ArrayList，是动态的，为了减少频繁的扩容，会预先分配冗余空间。当字符串大小小于1M时，扩容时翻倍扩容，大于等于1M时则是一次扩容1M。</p>
<h3 id="存储Hash"><a href="#存储Hash" class="headerlink" title="存储Hash"></a>存储Hash</h3><p>　　String key 和String Value的map容器，每个Hash可以存很多键值对。相当于java里面的HashMap.当第一维数组发生碰撞时，会将碰撞的数据形成链表。<br>　　基本用法：也可以存储用户信息，可以把信息，也就是每个字段单独存储。用的时候不用一下子全部取出来，只用取出自己要用的部分。可以减少网络io，但是这种数据结构性能太差。<br>　　赋值：hest myhash username dh,多个赋值，hmset myhash username dh age 21.取值：hget myhash username,一次取多个值hget myhash username age.全部取出来 hgetall myhash.<br>　　删除：单个删除：hdel myhash user age,del myhash是删除整个集合。同一样可以加值操作， hincrby myhash age 5,也有删除操作hdecrby myhash age 5,判断hash中是否存在某个key:hexists myhash username,成功返回1，不成功返回0.判断hash中多少属性key:hlen myhash.获得所有的key:hkeys myhash,获取所有value:hvalue myhash</p>
<h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><p>　　按照插入顺序的链表。可以从头部和尾部插入，没有key时创建这个key，数据没了删除这个key,链表的操作特征，大家都懂的。可以用作队列和栈。由于该结构是链表结构，如果按照顺序获取数据，左出或者右出都可以很高效，但是如果按照下标获取数据，那么久可能会很慢，因为要一个个遍历，时间复杂度高。<br>　　这个list的实际存储并不是纯粹的linkedList，而是一个叫做快速链表的一个结构，首先数据量小的时候使用一块连续的内存存储，这个结构就是ziplist,也就是压缩列表，所有元素紧挨一起存储，分配一块连续的内存，当数据量大的时候才会变成快速链表，就是多个ziplist连在一起。</p>
<p>　　这些方式来存储数据ArrayList,linklist双向链表<br>　　左边插入数据Ipush mylist a,b,c,建立一个list,并且把数据插进去，就像栈一样，返回值是链表的个数。<br>　　右侧插入rpush mylist a b,c<br>　　查看链表　lrange mylist 0 5,查看链表0-5的元素。０代表第一个元素，－１代表最后一个元素。那么查看索引信息的<br>　　左侧弹出元素　lpop mylist<br>　　右侧弹出元素　rpop mylist<br>　　获取元素个数　llen mylist<br>　　lpushx,rpushx这个和lpush差不多一样，但是没有这个key的时候是不会创建这个链表的。<br>　　lrem mylist count 1,当cout&gt;0,那么从头开始删除数目为count的1，当count&lt;0,从尾部开始删除绝对值为count的1，如果count=0，那么删除所有的1，。<br>　　lset mylist 3 mmm,效果是吧第四个元素替换为mmm,<br>　　linsert mylist before b 11,在这个mylist的这个list里面的这个b元素前边插入11<br>　　linsert mylist after b 11,在这个mylist的这个list里面的这个b元素后边插入11。<br>　　 rpoplpush mylist mylist1 将list1结尾的元素放到list2首部,这个主要用于消息队列。</p>
<h3 id="存储set。"><a href="#存储set。" class="headerlink" title="存储set。"></a>存储set。</h3><p>　　和java的set集合类似。也类似于集合。<br>　　sadd myset a b c，添加元素<br>　　srem  myset a删除元素<br>　　smembers myset 返回集合的所有元素。<br>　　sismember myset a,判断集合是否存在a,返回值为1表示存在，返回值为0表示不存在。<br>　　sdiff myset myset1,返回myset1中没有，但是myset有的值。<br>　　sinter myset myset1 返回这2个都有的值，也就是交集。<br>　　sunion myset myset1 ,这个就是求着2个集合的并集。<br>　　scard myset 返回集合的数目<br>　　srandmember myset 返回随机一个集合的元素<br>　　sdiffstore my1 myset myset1,就是将myset，myset1按这个顺序做一个差集，再把这个差集添加到my1这个集合里面去。<br>　　sinterstore my1 myset myset1,就是将myset，myset1做一个交集，再把这个交集添加到my1这个集合里面去。<br>　　sunionstore my1 myset myset1,就是将myset，myset1做一个并集，再把这个并集添加到my1这个集合里面去。
　　</p>
<h3 id="Sorted-set"><a href="#Sorted-set" class="headerlink" title="Sorted-set"></a>Sorted-set</h3><p>　　和Set差不多属性，就是多了个排序的能力。<br>　　zadd mysort 70 cs 80 ls 90 ss,增加3个元素，前面的是分数，代表其在sorted-set中的顺序，如果在添加zadd mysort 100 cs,这个value已经有了，那么就会用新的分数代替旧的分数。<br>　　zscore mysort cs 获取cs这个value对应的分数。<br>　　zcard mysort 返回这个sorted-set里面多少元素。<br>　　zrem mysort tom ww,删除tom,ww这个2个值。<br>　　zrange mysort 0 -1,和list的操作一样。这个只是返回值。<br>　　zrange mysqrt 0 -1 withscores，多返回了分数，从小到大的顺序出来。<br>　　zrevrange mysort 0 -1 withscores 从大到小排序。<br>　　zremrangebyrank mysort 0 4,范围删除。<br>　　zremrangebyscore mysort 80 100,按照分数范围删除。<br>　　zrangebyscore mysort 0 100,分数从0到100的value<br>　　zrangebyscore mysort 0 100 withscores 和上面一样就是多了分数。<br>　　zrangebyscore mysort 0 100 withscores limit 0 2,选取前面2个数据<br>　　zincrby mysort 3 ls，给ls这个元素的分数加3.<br>　　zcount mysort 80 90,分数80到90的个数。<br>　　 底层实现：这个底层是基于跳跃表实现的。为了满足随机插入，删除，定位，因此采用跳跃表。跳跃表是类似于这种层级制。最下面一层元素都会串起来，然后每隔几个元素选出一个代表，将这几个代表串起来，然后在这些代表里面在选出代表，在串起来，不断向上。</p>
<h3 id="keys操作"><a href="#keys操作" class="headerlink" title="keys操作"></a>keys操作</h3><p>　　keys * 查看所有的keys<br>　　keys my? 以my开头的keys.<br>　　del my1,my2,删除这些keys.<br>　　exists mykeys判断这个key是否存在。<br>　　rename company newname,给这个key重命名<br>　　expire newname 1000.1000秒就过期。ke<br>　　ttl newname 所剩超时时间<br>　　type newname返回类型</p>
<h2 id="Redis特性"><a href="#Redis特性" class="headerlink" title="Redis特性"></a>Redis特性</h2><h3 id="多数据库"><a href="#多数据库" class="headerlink" title="多数据库"></a>多数据库</h3><p>　　一个Redis可以包含多个数据库。一个Redis最多16个数据库，客户端默认连接的是0号数据库。类似于mysql可以创建多个数据库。<br>　　select 1,选择一号数据库<br>　　move myset 1,这个就是把当前数据库的这个key移到1号数据库里面。</p>
<h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>　　multi exec discard<br>　　事务会让命令串行化执行，同时也不会向其他客户端提供服务。从而保证事务。<br>　　用multi来开启事务，用exec来提交事务。用discard来进行回滚。<br>　　当你用multi时，后续的命令都会被加到命令队列里面。直到遇见exec来提交。</p>
<h2 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h2><p>　　就是把redis的数据同步到硬盘上，redis快是由于其运行在内存里面的。<br>　　２种方式实现持久化。<br>　　ＲＤＢ，ＡＯＦ这２个方式。<br>　　RDB，就是指定时间内就把数据写入硬盘。<br>　　配置：<br>　　打开我们的redis的配置文件redis.conf，<br>    save 900 1<br>    save 300 10<br>    save 60 10000<br>　　就是每900秒若是有一个key变化就写入文件。第二个就是每300秒有10个key变化时就写入文件，第三个就是每60秒有10000key变化时就写入文件。<br>　　dbfilename dump.rdb<br>　　文件名字。<br>　　dir ./当前路径。<br>　　aof，将以日志记录每个数据操作，启动时，重新加载。<br>　　配置：打开redis.conf这个文件找到这个appendonly no,这个是配置这个redis是否发开的方式。将之改为yes就是启动这个aof配置。<br>　　３个同步方案；<br>　　appendsync always ,每次操作都同步<br>　　appendfsync </p>
<h2 id="info-指令"><a href="#info-指令" class="headerlink" title="info 指令"></a>info 指令</h2><p>　　我们可以用info指令查看redis运行状态。其大致分为9大块。</p>
<pre><code>Server 服务器运行的环境参数
Clients 客户端相关信息
Memory 服务器运行内存统计数据
Persistence 持久化信息
Stats 通用统计数据
Replication 主从复制相关信息
CPU CPU 使用情况
Cluster 集群信息
KeySpace 键值对统计数量信息
</code></pre><p>　　我们可以根据这些信息判断这些时候redis是否需要集群啊，等问题，来调整redis。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://skydh.github.io/2018/03/12/mybatis简介/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="董航">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="why are you so happy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/12/mybatis简介/" itemprop="url">mybatis简介</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-12T11:26:20+08:00">
                2018-03-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="优点和缺点"><a href="#优点和缺点" class="headerlink" title="优点和缺点"></a>优点和缺点</h2><p>　　sql和代码分离，利于管理和优化，但是sql代码量大，有些不好处理。MyBatis支持普通sql查询，存储过程，高级映射，其消除了所有的JDBC代码和参数的手工设置以及结果集的检索，使用简单的XML和注解来配置映射关系。恩，还有动态sql,避免了sql注入。</p>
<h2 id="mybatis缓存机制"><a href="#mybatis缓存机制" class="headerlink" title="mybatis缓存机制"></a>mybatis缓存机制</h2><p>　　Mybatis缓存是分为2级缓存。<br>　　一级缓存是一个sqlSession级别的。就是一个sqlSession里面sql和参数一样的sql就会从从缓存里面取出来，默认开启。<br>　　二级缓存：，多个SqlSession使用同一个Mapper的sql语句去操作数据库，得到的数据会存在二级缓存区域，它同样是使用HashMapper进行数据存储，相比一级缓存SqlSession，二级缓存的范围更大，多个SqlSession可以共用二级缓存，二级缓存是跨SqlSession的。默认不开启</p>
<p><pre><br>    mybatis-config<br>    <settings><br>        <setting name="cacheEnabled" value="true"><br>    </setting></settings><br>    <!-- 开启当前mapper的namespace下的二级缓存 --><br>    <cache eviction="LRU" flushinterval="60000" size="512" readonly="true"><br></cache></pre><br>　　对于缓存数据更新机制，当某一个作用域(一级缓存Session/二级缓存Namespaces)的进行了 C/U/D 操作后，默认该作用域下所有 select 中的缓存将被clear。</p>
<h2 id="和-的区别是什么？"><a href="#和-的区别是什么？" class="headerlink" title="#{}和${}的区别是什么？"></a>#{}和${}的区别是什么？</h2><p>   第一个是解析传递进来的参数数据，是预编译处理，<br>第二个是对传递进来的参数原样拼接在SQL中，是字符串替换。<br>使用#{}可以有效的防止SQL注入，提高系统安全性。<br>看看案例实现</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://skydh.github.io/2018/03/11/spring mvc简介/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="董航">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="why are you so happy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/11/spring mvc简介/" itemprop="url">spring mvc介绍和demo</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-11T15:07:15+08:00">
                2018-03-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>　　DispatcherServlet:这个就类似于前端分发器。用于分发前端的请求到具体的Controller。然后获取数据到前端。<br>　　Controller:就是控制层。<br>　　HandlerAdapter:Handler是DispacherServlet使用的，是controller的一个表现形式。我们的DispatcherServlet调用Controller就是以调用Handle来调用的，而HanDlerAdapter则是将不同类型的类适配为我们这个DispacherServlet可以使用的类。<br>　　handleInterceptor:就是拦截器，就是在Handle上加上一些拦截器。<br>　　HandleMapping：顾名思义，Handle是DispacherServlet调用Controller的一个过渡中间对象，那么这个就是前段访问对应那个Controller。以及这个Controller的拦截器。<br>　　HandlerExecutionChain:调用的Controller按照拦截器的模式前置拦截，以及后置拦截器等拦截器的链条。<br>　　ModelAndView:这就是model的显示类型。<br>　　ViewResolve：视图解析器。根据配置找到确切的视图对象告诉DispacherServlet。<br>　　View：界面显示。<br><img src="https://raw.githubusercontent.com/skydh/picture/master/springmvc.png" alt="aaa"><br><img src="https://raw.githubusercontent.com/skydh/picture/master/springmvc2.png" alt="aaa"><br>　　请求从浏览器发送经过DispacherServlet的HandleMapping找到对应的Controller以及其拦截器。从而生成一个Handle给DispacherServlet，让其调用，生成一个model就是数据模型，然后DispacherServlet调用ViewResolve找到view，吧数据model注入进去，并且把这个view返回给Response。</p>
<h2 id="配置解析"><a href="#配置解析" class="headerlink" title="配置解析"></a>配置解析</h2><p>　　web.xml文件解析。<br>　　这个文件是用来加载初始化信息的，当服务容器开始启动时，先加载web.xml文件。里面的元素配置信息加载顺序为：context-param&gt;listener&gt;filter&gt;servlet<br>　　第一步，获取到context-param的值，然后创建这个web项目的上下文，然后创建listener的实例，从而获取到相关信息。最后则是加载filter的实例。<br>　　web.xml文件启动大致分为2个部分。<br>　　ContextLoad而Listener的初始化，实例化话ioc,并且将这个ioc注册到application中。<br>　　DispacherServlet的初始化。<br>　　我们知道Spring容器加载配置文件后，会生成一个上下文，而springmvc加载配置文件后也会生成一个上下文，为什么这样划分呢？？？这样的，我们的应用可能给不同类型的人分发请求，那么就会有多个DispacherServlet，呢么就有多个上下文，而spring的上下文则是公共的，那么就会少加载初始化一些类。</p>
<h2 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h2><p><img src="https://raw.githubusercontent.com/skydh/picture/master/spring-mvc.png" alt="aaa"><br>　　这里配置多个拦截器如下所示。<br><img src="https://raw.githubusercontent.com/skydh/picture/master/spring-mvc1.png" alt="aaa"></p>
<h2 id="demo样例"><a href="#demo样例" class="headerlink" title="demo样例"></a>demo样例</h2><p>　　可以自己下载运行调试。<br>　　<a href="https://github.com/skydh/spring-mvc-test.git" target="_blank" rel="noopener">点我一下就到了</a></p>
<p>　　</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://skydh.github.io/2018/03/02/消息中间件/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="董航">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="why are you so happy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/02/消息中间件/" itemprop="url">java消息中间件入门</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-02T10:55:54+08:00">
                2018-03-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="消息中间件来解耦服务调用"><a href="#消息中间件来解耦服务调用" class="headerlink" title="消息中间件来解耦服务调用"></a>消息中间件来解耦服务调用</h2><p>　　比如１个登录系统，登录的话需要调用很多系统的其他服务，如果中间调用失败，可能会导致登录信息一致无法返回，同时也增加了系统的耦合度。而用消息中间件的话，则是不发送服务到其他系统，而是发送服务到消息中间件，发完消息就直接返回结果，完美。而消息中间件则是自己吧消息发送给那些服务。</p>
<h2 id="什么是中间件"><a href="#什么是中间件" class="headerlink" title="什么是中间件"></a>什么是中间件</h2><p>　　非底层操作系统软件。非业务应用软件，不是直接给用户的，不能给客户带来直接价值的软件叫中间件。</p>
<h2 id="什么是消息中间件"><a href="#什么是消息中间件" class="headerlink" title="什么是消息中间件"></a>什么是消息中间件</h2><p>　　关注与数据的发送和接受，利用高效可靠的异步消息传递机制集成分布式系统。</p>
<h2 id="什么是JMS"><a href="#什么是JMS" class="headerlink" title="什么是JMS"></a>什么是JMS</h2><p>　　java消息服务即是JMS,是一个java平台中关于面向消息中间件的API,用于2个程序啊件进行异步通信。就是一个规范。</p>
<h2 id="什么是AMQP"><a href="#什么是AMQP" class="headerlink" title="什么是AMQP"></a>什么是AMQP</h2><p>　　一个提供统一消息服务的应用层标准高级消息队列协议,是应用层协议的一个开放标准,为面向消息的中间件设计。和JMS想对。</p>
<h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>　　第一步，下载安装activemq,第二步，编写发送端和接收端。<br>　　下载后可以修改这个消息队列的配置文件，来修改持久化方式，有文件持久化，数据库持久化等。发送端发送消息给消息队列，接收端从消息队列中获取消息。有２个方式来消费消息，一个是队列方式，一个是主体模式。队列模式就是现有的消费者们平均或者按照一定规则消费队列里面的消息。主题模式则是每个消费者完整的消费消息队列里面的消息。<br>　　这里写了一个案例来显示<br>　　生产者代码</p>
<p><pre><br>    public class Producer {<br>        public static final String url = “tcp://127.0.0.1:61616”;<br>        public static final String queueName = “dh-test-queue”;<br>        public static void main(String[] args) throws JMSException {<br>            ConnectionFactory connectionFactory = new ActiveMQConnectionFactory(url);<br>            Connection connection = connectionFactory.createConnection();<br>            connection.start();<br>            Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);<br>            Destination destination = session.createQueue(queueName);<br>            MessageProducer mp = session.createProducer(destination);<br>            for (int i = 0; i &lt; 100; i++) {<br>                TextMessage textMessage = session.createTextMessage(“test” + i);<br>                mp.send(textMessage);<br>                System.out.println(“发送消息” + textMessage.getText());<br>            }<br>            connection.close();</pre></p>
<pre><code>}
</code></pre><p><br>　　这个是先根据url生成一个连接工厂，然后根据这个工厂类生成一个连接。然后根据这个连接创建一个session，然后根据这个session创建一个目的地，这个就是消息队列上你的消息队列的名字，然后根据session和这个目的地，创建一个消息发送者，就可以发送消息到消息队列了。</p>
<p>　　消费者代码</p>
<p><pre><br>    public class ConsumerApp {<br>        public static final String url = “tcp://127.0.0.1:61616”;<br>        public static final String queueName = “dh-test-queue”;<br>        public static void main(String[] args) throws JMSException {<br>            ConnectionFactory connectionFactory = new ActiveMQConnectionFactory(url);<br>            Connection connection = connectionFactory.createConnection();<br>            connection.start();<br>            Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);<br>            Destination destination = session.createQueue(queueName);<br>            MessageConsumer mc= session.createConsumer(destination);<br>            mc.setMessageListener(new MessageListener() {<br>                @Override<br>                public void onMessage(Message message)<br>                    TextMessage textMessage=(TextMessage) message;<br>                    try {<br>                        System.out.println(textMessage.getText());<br>                    } catch (JMSException e) {<br>                        // TODO Auto-generated catch block<br>                        e.printStackTrace();<br>                    }<br>                }<br>            });<br>            //connection.close();</pre></p>
<pre><code>}
</code></pre><p><br>　　前面代码都大致一样，后面不同的就是根据session和目的地生成一个消费者，然后用这个消费者调用一个监听器持续监听来自消息队列的消息，从而获取消息。</p>
<h2 id="rabbitmq"><a href="#rabbitmq" class="headerlink" title="rabbitmq"></a>rabbitmq</h2><h3 id="生产者到消息队列确认机制，以及为何发生消息重复"><a href="#生产者到消息队列确认机制，以及为何发生消息重复" class="headerlink" title="生产者到消息队列确认机制，以及为何发生消息重复"></a>生产者到消息队列确认机制，以及为何发生消息重复</h3><p>　　定义几个概念：<br>　　A=生成者-&gt;消息队列,发送消息到消费者。<br>　　B=消息队列加入消息持久化，<br>　　C=消息队列-&gt;生产者。回复ack，<br>　　D=消息队列-&gt;消费者，发送消息到消费者。<br>　　E=消费者-&gt;消息队列，回复ack，<br>　　F=消息队列删除消息，持久化。<br>　　基本可以分为这几个步骤。<br>　　１.第一个是前３个回合。<br>　　生产端要维护一个消息发送的表，消息发送的时候记录消息id，这个消息id是消息队列自己生产的id,唯一。在消息成功落地broker磁盘并且进行回调确认（ack）的时候，根据本地消息表和回调确认的消息id进行对比，然后删除。如果这个表里面存在没有收到ack的消息，且超时了，那么生产者会再次发送。且消息id不变。<br>　　我们分析，前面３个步骤Ａ，Ｂ，Ｃ无论哪个出了问题，生产者都没有收到ack,那么都会发送再次发送消息到消息队列，那么势必造成重复，但是消息队列对这个做了去重处理，根据消息id.<br>　　第二个回合就是后面３个回合了。<br>　　对于消息队列来说，必须收到ack，我才会进行进行删除，不然我会持续发送，但是存在一个情况就是E的时候网络断了，但是消息是确实消费了，消息队列却没有删除，再次消费，则会造成消息重复，这个需要我们自己去处理。<br>　　因此第一个回合消息是幂等的，第二个回合消息不是幂等的。</p>
<h3 id="四种交换机"><a href="#四种交换机" class="headerlink" title="四种交换机"></a>四种交换机</h3><p>　　１．扇形交换机<br>　　广播模式，将消息发送到绑定到该交换机的所有队列上。<br>　　２．直连交换机<br>　　每个队列绑定到一个交换机上面，同时有个routing_key对应这个队列到交换机。同时消息也携带一个routing_key。交换机根据这个routing_key将消息指定到对应队列里面。如果希望一个消息发送到多个队列里面，那么就要发送多次.这里面的routing_key是写死的，比如某个队列绑定到交换机的routing_key=back,那么携带back的消息就会被路由分配到这个队列里面。<br>　　３．主题交换机<br>　　这个是上面直连交换机的加强版。不过routing_key加强了，可以用一部分规则了。规则如下。*：一个单词。#：任意单词。我们队列的routing_key=com.hehe.#，那么任何以com.hehe开头的消息都会被分配到这里。<br>　　４．首部交换机<br>　　首部交换机个人觉得类似于主题交换机，只不过规则变了，是基于hash了，队列和交换机绑定的时候声明一个hash数据结构，当消息发送的时候，会携带一个hash数组，然后进行匹配，如果匹配成功就会写入到相对应的队列。</p>
<h2 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h2><p>　　为了保证rabbitMq的可靠性，保证消息的可靠性。需要将quene,exchange,message都持久化。</p>
<p>　　quene持久化就是将quene的持久化标示设置为true,当服务重启后，之前存在quene会被重洗放到rabbitmq里面。</p>
<p>　　message持久化：quene持久化，如果message不持久化，那么重启后quene里面的没消费的消息会丢失。设置了队列和消息的持久化之后，当broker服务重启的之后，消息依旧存在。单只设置队列持久化，重启之后消息会丢失；单只设置消息的持久化，重启之后队列消失，既而消息也丢失。单单设置消息持久化而不设置队列的持久化显得毫无意义。<br>　　exchange持久化：这个持久化与否没什么影响，但是建议持久化，不然重启后交换机就会丢失。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>　　大致了解了一些消息队列，以及做出了一个简单demo，目前没有用到，用到在细看。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/7/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><span class="page-number current">8</span><a class="page-number" href="/page/9/">9</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><a class="extend next" rel="next" href="/page/9/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">董航</p>
              <p class="site-description motion-element" itemprop="description">clear 航</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">102</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            

          </nav>

          

          <div class="links-of-author motion-element">
            
          </div>

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">董航</span>

  
</div>


<div class="powered-by">
<i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv">
  本站访客数:<span id="busuanzi_value_site_uv"></span>
</span>
</div>

  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.3</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.3"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
