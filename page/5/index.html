<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="clear 航">
<meta property="og:type" content="website">
<meta property="og:title" content="why are you so happy">
<meta property="og:url" content="https://skydh.github.io/page/5/index.html">
<meta property="og:site_name" content="why are you so happy">
<meta property="og:description" content="clear 航">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="why are you so happy">
<meta name="twitter:description" content="clear 航">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://skydh.github.io/page/5/"/>





  <title>why are you so happy</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">why are you so happy</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">clear 航</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://skydh.github.io/2018/09/25/redis 删除策略/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="董航">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="why are you so happy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/25/redis 删除策略/" itemprop="url">redis过期删除策略</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-25T18:41:04+08:00">
                2018-09-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="惰性删除"><a href="#惰性删除" class="headerlink" title="惰性删除"></a>惰性删除</h2><p>　　redis将设置了过期时间的key放到一个独立的字典里面，以后定时遍历这个字典来删除到期的key，同时采用惰性原则，当客户端访问这个key的时候，redis会对其进行检查，如果过期了，那么立即删除。</p>
<h2 id="定时策略"><a href="#定时策略" class="headerlink" title="定时策略"></a>定时策略</h2><p>　　redis默认每秒10次扫描过期字典的key,不是遍历，而是一种贪心策略。<br>　　１．从过期字典随机20个key。<br>　　２．删除这２０个ｋｅｙ里面过期的key。<br>　　３．如果过期的key&gt;1/4,那就重复1.<br>　　同时为了避免循环过度，造成线程卡死，算法还设置了一个时间上限，默认不超过25ms。<br>　　<br>　　不要用大量key同一时间过期，会导致系统卡顿。因为卡顿是很多小卡顿积累出来的。</p>
<h2 id="从库的删除策略"><a href="#从库的删除策略" class="headerlink" title="从库的删除策略"></a>从库的删除策略</h2><p>　　从库不会进行过期扫描，从库的处理是被动的。主库key到期后，会在aof文件里面增加一个del指令，同步到所以的从库。</p>
<h2 id="真删除-del"><a href="#真删除-del" class="headerlink" title="真删除 del"></a>真删除 del</h2><p>　　redis的单线程是指接受客户端请求的时候是单线程，基于多路io复用，但是redis里面还是有多个异步子线程来进行一些耗时操作的。<br>　　比如：del删除指令会直接释放对象的内存，对于小对象来说，无所谓，秒删，但是对于大的数据，hash，那么就会造成单线程卡顿，redis提供了一个叫unlink的指令，对删除进行懒操作处理。对给后台线程异步回收内存。同时使用这个指令后，主线程就无法访问到了。<br>　　主线程执行这个指令后，就会将这个key的内存回收操作包装为一个任务，塞进异步任务队列，后台线程就会从这个异步队列里面取任务，然后执行。<br>　　Aof sync 操作中一秒一次增量同步，需要频繁磁盘io,耗时，于是也有一个子线程来异步后台处理</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://skydh.github.io/2018/09/20/redis-stream/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="董航">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="why are you so happy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/20/redis-stream/" itemprop="url">redis -stream</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-20T11:48:31+08:00">
                2018-09-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="诞生"><a href="#诞生" class="headerlink" title="诞生"></a>诞生</h2><p>　　Redis5.0出来的，新的数据结构 Stream 支持多播的可持久化的消息队列。其设计借鉴了kafka的设计。<br>　　这个存储类型是一个数据链表，将所有加入的消息都串起来。每个消息都有唯一的id和对应的内容，消息是持久化的，redis重启后，内容还在，其持久化方式，类似于rdb+aof。<br>　　每个stream都有唯一的一个名称就是其key,我们首次使用xadd指令追加消息时，自动创建，同时每个strean可以同时挂多个消费组，每个消费组都有游标last_delivered_id在Stream数组之上向前移动，表示当前消费组已经消费到哪条消息了，每个消费组都有一个stream内唯一的名称，消费组不会自动创建，需要单独的指令xgroup create进行创建，需要制定从这个stream的某个消息id,表示从这个stream开始消费，这个id用来初始化last_delivered_id变量。<br>　　每个消费组的状态都是独立的。相互不影响，也就是说同一个stream内部的消息会被每个消费组消费到。<br>　　每个消费组可以挂起多个消费者，这些消费者是竞争关系的，一个消息被一个消费者消化了，那就无法被另一个消化。每个消费者组内是唯一的。<br>　　消费者内部有个状态变量pending_ids,它记录了客户端读取的消息，但是没有ack的，如果客户端发了ack,那么这个消息id就会被去掉，它来表示消息是否被至少消费一次。<br>　　消息id是timestampInMillis-sequence，当前时间戳，的第几条消息，同时也可以客户端自己指定，但是形式必须是整数-整数，消息内容是键值对。</p>
<h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><p>　　xadd:追加消息。<br>　　xadd codehole * name laoqian age 30<br>　　xdel:删除消息这里的删除仅仅是设置了标志位，不影响消息总长度。<br>　　xrange:获取消息队列，自动过滤被删除消息。<br>　　xrange codehole - +<br>　　xlen:消息长度。<br>　　xlen codehole<br>　　del：删除stream。</p>
<h2 id="独立消费"><a href="#独立消费" class="headerlink" title="独立消费"></a>独立消费</h2><p>　　我们可以不建立消费组的情况下对stream独立消费，其有一个指令叫做xread,可以将stream当做普通的消息队列（list）来使用，使用xread的时候我们可以忽略消费组的存在，好比stream就是一个普通的列表（list）。xread count 2 streams codehole 0-0表示从头读2个数据，没有数据就一直阻塞。但是我们可以用block来设置阻塞时间，0表示永久阻塞。1000表示1秒。 xread block 1000 count 1 streams codehole $。</p>
<h2 id="创建消费组"><a href="#创建消费组" class="headerlink" title="创建消费组"></a>创建消费组</h2><p>　　Stream通过xgroup createn 创建消费组。需要传递起始消息id作为参数来初始化last_delivered_id。<br>　　xgroup create codehole cg1 0-0：从头开始消费。<br>　　xgroup create codehole cg2 $：从尾部开始消费，只接受新消息。<br>　　 xinfo stream codehole：获取stream信息。</p>
<h2 id="消费"><a href="#消费" class="headerlink" title="消费"></a>消费</h2><p>　　Stream指令xreadgroup可以进行消费组的组内消费，需要消费组名称，消费者名称，起始消息id,读取到新消息后，对应的消息id就会进入消费者的PEL结构里面，等待ack,来删除。</p>
<p>　　 xreadgroup GROUP cg1 c1 count 1 streams codehole   &gt;<br>     命令           消费组 消费者  读几个    那个stream 表示从这个之后读取</p>
<h2 id="限制长度"><a href="#限制长度" class="headerlink" title="限制长度"></a>限制长度</h2><p>　　stream消息要是太多怎么办，一个链表太长了，会导致性能下降很多，而且，删除也是逻辑删除，这边我们可以在创建这个stream的时候设置默认长度，新的覆盖旧的。<br>　　xadd codehole maxlen 3 * name xiaorui age 1　长度为３</p>
<h2 id="pel如何避免消息丢失"><a href="#pel如何避免消息丢失" class="headerlink" title="pel如何避免消息丢失"></a>pel如何避免消息丢失</h2><p>　　当客户端突然断掉了来自服务端的消息，消息丢失了，但是pel里面已经保存了发消息的id,待客户端连上了，我们可以读取pel里面的消息列表，来保证消息不丢失。不过此时 xreadgroup 的起始消息 ID 不能为参数&gt;，而必须是任意有效的消息 ID，一般将参数设为 0-0，表示读取所有的 PEL 消息以及自last_delivered_id之后的新消息。</p>
<h2 id="stream的高可用"><a href="#stream的高可用" class="headerlink" title="stream的高可用"></a>stream的高可用</h2><p>　　这个的高可用是建立在主从复制的基础上的，他和其他数据的复制机制没区别。</p>
<h2 id="分区-Partition"><a href="#分区-Partition" class="headerlink" title="分区 Partition"></a>分区 Partition</h2><p>　　Redis不支持分区功能，如果要分区，那就配置多个stream,然后客户端根据一定策略生成消息到不同stream。
　　</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://skydh.github.io/2018/09/17/mysql 数据库分表分库/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="董航">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="why are you so happy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/17/mysql 数据库分表分库/" itemprop="url">mysql 分库分表</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-17T17:48:33+08:00">
                2018-09-17
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="垂直切分"><a href="#垂直切分" class="headerlink" title="垂直切分"></a>垂直切分</h2><p>　　将表按照功能模块、关系密切程度划分出来，部署到不同的库上。也就是分库。适用于表多的情况。</p>
<h2 id="水平切分"><a href="#水平切分" class="headerlink" title="水平切分"></a>水平切分</h2><p>　　当一个表中的数据量过大时，我们可以把该表的数据按照某种规则，例如userID散列，进行划分，然后存储到多个结构相同的表，这就是分表。</p>
<h2 id="切分的选择"><a href="#切分的选择" class="headerlink" title="切分的选择"></a>切分的选择</h2><p>　　应该使用哪一种方式来实施数据库分库分表，这要看数据库中数据量的瓶颈所在，并综合项目的业务类型进行考虑。</p>
<p>　　如果数据库是因为表太多而造成海量数据，并且项目的各项业务逻辑划分清晰、低耦合，那么规则简单明了、容易实施的垂直切分必是首选。而如果数据库中的表并不多，但单表的数据量很大、或数据热度很高，这种情况之下就应该选择水平切分，水平切分比垂直切分要复杂一些，它将原本逻辑上属于一体的数据进行了物理分割，除了在分割时要对分割的粒度做好评估，考虑数据平均和负载平均，后期也将对项目人员及应用程序产生额外的数据管理负担。</p>
<p>　　在现实项目中，往往是这两种情况兼而有之，这就需要做出权衡，甚至既需要垂直切分，又需要水平切分。我们的游戏项目便综合使用了垂直与水平切分，我们首先对数据库进行垂直切分，然后，再针对一部分表，通常是用户数据表，进行水平切分。</p>
<h2 id="问题挑战"><a href="#问题挑战" class="headerlink" title="问题挑战"></a>问题挑战</h2><p>　　在分片之后的数据库中并不一定能够正确运行。<br>　　跨库事务也是分布式的数据库集群要面对的棘手事情。 合理采用分表，可以在降低单表数据量的情况下，尽量使用本地事务，善于使用同库不同表可有效避免分布式事务带来的麻烦。 在不能避免跨库事务的场景，有些业务仍然需要保持事务的一致性。 而基于XA的分布式事务由于在并发度高的场景中性能无法满足需要，并未被互联网巨头大规模使用，他们大多采用最终一致性的柔性事务代替强一致事务。</p>
<h2 id="分表的2个方式"><a href="#分表的2个方式" class="headerlink" title="分表的2个方式"></a>分表的2个方式</h2><p>　　１．事先预估好了，直接根据一定规则把表划分为多个。比如用户表。事先建ｎ个这样的表，user1,user2,user3。然后根据用户的ID来判断这个用户的聊天信息放到哪张表里面，你可以用hash的方式来获得，可以用求余的方式来获得，方法很多。<br>　　２.使用merge的方式建立映射。但是要求很多不能是innodb存储引擎。一般不使用。</p>
<h2 id="实践使用sharing-jdbc"><a href="#实践使用sharing-jdbc" class="headerlink" title="实践使用sharing-jdbc"></a>实践使用sharing-jdbc</h2>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://skydh.github.io/2018/09/17/redis 主从同步/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="董航">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="why are you so happy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/17/redis 主从同步/" itemprop="url">redis主从同步和集群</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-17T17:48:05+08:00">
                2018-09-17
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="什么是主从同步"><a href="#什么是主从同步" class="headerlink" title="什么是主从同步"></a>什么是主从同步</h2><p>　　主从分布是部署多个redis实例，一主多从，当主实例挂了，那么我们就可以用从实例替换上去，增加了系统的稳定性。</p>
<h2 id="CAP理论"><a href="#CAP理论" class="headerlink" title="CAP理论"></a>CAP理论</h2><p>　　Ｃ：一致性：分布式的系统中同一时刻有一样的值。<br>　　Ａ：可用性：集群故障之后依旧可以相应客户端的读写请求。<br>　　Ｐ：分区容错性：系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在C和A之间做出选择。<br>　　而分布式系统往往分布在不同的机器上面。这意味着必然有网络断开的风险，这个网络断开的场景的专业词汇叫网络分区。<br>　　当网络之间无法通信时，节点数据不在统一，那么一致性不满足了，或者我们暂停服务，那么可用性不满足了。<br>　　也就是说当网络分区时，一致性和可用性无法２全。</p>
<h2 id="redis的最终一致性"><a href="#redis的最终一致性" class="headerlink" title="redis的最终一致性"></a>redis的最终一致性</h2><p>　　redis的主从数据是异步同步的，所以redis系统不满足一致性要求。redis的主节点修改数据后，立即返回，因此就算主从网络断开，主节点依旧可以提供服务。满足可用性，当网络恢复了，从节点会尽可能的同步数据。</p>
<h2 id="增量同步"><a href="#增量同步" class="headerlink" title="增量同步"></a>增量同步</h2><p>　　这个同步方式是主节点会把对自己状态修改的指令记录在内存buffer中，redis的复制内存buffer是一个定长的环形数组，如果数组满了，将会覆盖这个数组。因此如果长时间无法同步，那么指令可能会被覆盖。</p>
<h2 id="快照同步"><a href="#快照同步" class="headerlink" title="快照同步"></a>快照同步</h2><p>　　需要将主库的数据全部快照到磁盘文件，然后将快照文件传给子节点。从节点立即进行一次全量加载，加载之前需要将数据清空，加载后，在进行增量同步。（个人理解是和持久化一样的策略，进行快照时，新的操作用增量），但是存在一种情况，就是在快照和同步的时候，增量缓存已经被覆盖，那么只增在进行快照，然后buffer又被覆盖，进入了死循环。因此buffer大小必须设置好。</p>
<h2 id="无盘复制"><a href="#无盘复制" class="headerlink" title="无盘复制"></a>无盘复制</h2><p>　　快照时会很严重的io操作，对系统很大的影响，我们可以通过服务器直接将套接字将快照内容发到从节点，生成快照是一个遍历的过程，主节点一遍遍历内存一遍序列化内容发送到从节点，从节点接受后也是先缓存到磁盘，然后加载到从节点里面。<br>　　我们可以用wait指令强行同步复制。wait 1 1,1就是一个从库，0就是最多等待时间。如果时间=0，那么将将无限制一致等待。</p>
<h2 id="sentinel-自动化切换"><a href="#sentinel-自动化切换" class="headerlink" title="sentinel 自动化切换"></a>sentinel 自动化切换</h2><p>　　前面介绍了主从同步的策略实现以及原理。但是主节点出现故障，还是要手动去切换到从节点，为了避免这个问题，redis官方提供了一个方案-redis sentinel 来处理。可以在主节点挂了之后自动切换到从节点。<br>　　我们一般用3~5个sentinel作为集群，来监察redis的集群。客户端访问redis集群的时候，一般先去访问sentinel,从其中获取主节点地址，然后再去访问redis，当redis主节点挂了之后，客户端访问失败后，再次访问sentinel,他会选一个最优的从节点作为主节点，并把地址返回给客户端。而sentinel会持续监控这个坏掉的主节点，等其回复了之后将其作为从节点。<br>　　主节点断掉了，那么以为消息的丢失，因为redis的消息同和和zookeeper不一样是异步，如果延迟过大，可能造成很大的影响。</p>
<pre><code>min-slaves-to-write 1
min-slaves-max-lag 10
</code></pre><p>　　Sentinel 采用上面的命令来尽量减少丢失，第一个参数是，起码必须有1个正在正常复制中，第二个参数是如果超过10秒没有复制，那么就是不正常复制了。</p>
<h2 id="codis-方案"><a href="#codis-方案" class="headerlink" title="codis 方案"></a>codis 方案</h2><p>　　大数据量下单个redis实例是明显不够的，原因如下：<br>　　１．导致内存过大，这样主从复制的时候全量同步时间过长，其次持久化时间也太长，重启消耗大量时间资源。<br>　　２．云环境下，单个实例内存是收到限制的。<br>　　３．redis是基于多路io复用的单线程，对cpu利用率不高。<br>　　因此redis集群应运而生，多个redis实例可以有效提高cpu使用率，而codis是一个非常好的方案，它是一个代理中间件和redis一样使用redis的协议来对外提供服务。当客户端向codis发送指令时，codis负责将指令转发到后面的redis实例完成，起到一个负载均衡，代理的作用。codis上连接的所有redis实例构成了一个集群。codis对客户端是透明的，客户端就像直接使用redis实例一样。codis是无状态的，我们可以同时启动多个实例，来增加其容错性，以及提高并发量。<br>　　那么问题来了，一个key到底对应哪个redis实例呢？<br>　　codis这样玩的，他对每个key做一个运算，然后对1024取模得到一个值，codis在内存维护的一个映射关系。就是redis实例和1024的对应关系，然后这个值通过这个映射关系，找打对应的redis实例。<br>　　那么问题又来了，我们如何对codis同步数据，同步映射关系，这边采用的是使用zookeeper来持久化映射关系，同时codis提供了一个dashboard来观察修改槽位关系，当槽位关系变化时,codis会监听到变化，从而同步其关系。<br>　　缺点：key分布式了，所以不再支持事务，其次是动态扩容时，key的迁移消耗资源太大。</p>
<h2 id="cluster-亲儿子"><a href="#cluster-亲儿子" class="headerlink" title="cluster(亲儿子)"></a>cluster(亲儿子)</h2><p>　　cluster是redis官方推出的方案，采用去中心化的方案来集群，多个节点通过一个二进制协议交换集群信息。redis将数据的key分为16384 的 slots，其槽点的信息存在每一个节点里面，当客户端获取数据时，先获取到整个槽点的信息，且将其缓存下来。RedisCluster 的每个节点会将集群的配置信息持久化到配置文件中，所以必须确保配置文件是可写的，而且尽量不要依靠人工修改配置文件。具体配置看详细即可。欧了</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://skydh.github.io/2018/09/17/redi 小对象压缩/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="董航">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="why are you so happy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/17/redi 小对象压缩/" itemprop="url">redis 小对象压缩</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-17T17:47:13+08:00">
                2018-09-17
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="redis-数据库的优化"><a href="#redis-数据库的优化" class="headerlink" title="redis 数据库的优化"></a>redis 数据库的优化</h2><p>　　redis是一个内存数据库，速度高的同时也加大消耗了内存资源，为了减少内存消耗，redis做了很多优化。</p>
<h2 id="32bit-和64-bit"><a href="#32bit-和64-bit" class="headerlink" title="32bit 和64 bit"></a>32bit 和64 bit</h2><p>　　32bit相对于64bit有个很大的优势，就是指针空间占用很少，但是总内存不能超过4G。但是4G够了。</p>
<h2 id="ziplist"><a href="#ziplist" class="headerlink" title="ziplist"></a>ziplist</h2><p>　　对于redis的hashmap和zset来说，如果内部元素很少，依旧使用二维结构会很浪费空间。目前有个叫做ziplist的数据结构，该结构是一个紧凑的字节数组结构，每个元素都是紧挨着的。</p>
<h2 id="intset"><a href="#intset" class="headerlink" title="intset"></a>intset</h2><p>　　set集合的元素很少的时候，且都是整数的时候，会采用intset这个数据结构。这是一个紧凑的整形数组结构。如果加入了字符串就会转换为hashmap结构。</p>
<h2 id="转换条件"><a href="#转换条件" class="headerlink" title="转换条件"></a>转换条件</h2><p>　　hash-max-ziplist-entries 512  # hash 的元素个数超过 512 就必须用标准结构存储<br>hash-max-ziplist-value 64  # hash 的任意元素的 key/value 的长度超过 64 就必须用标准结构存储<br>list-max-ziplist-entries 512  # list 的元素个数超过 512 就必须用标准结构存储<br>list-max-ziplist-value 64  # list 的任意元素的长度超过 64 就必须用标准结构存储<br>zset-max-ziplist-entries 128  # zset 的元素个数超过 128 就必须用标准结构存储<br>zset-max-ziplist-value 64  # zset 的任意元素的长度超过 64 就必须用标准结构存储<br>set-max-intset-entries 512  # set 的整数元素个数超过 512 就必须用标准结构存储</p>
<h2 id="redis-垃圾回收策略"><a href="#redis-垃圾回收策略" class="headerlink" title="redis 垃圾回收策略"></a>redis 垃圾回收策略</h2><p>　　当你从redis里面删除了1GB的key时，你会发现内存变化不大。因为操作系统回收数据是以页为单位的，即使这个页里面还有一个key,那么这个页也不会被回收。这个1Gb的key分散到各个页面。因此内存不会立即被回收。<br>　　当然你使用flushdb这个指令，可以强制回收。redis虽然无法保证立即回收已删除key的内存，但是他会优先使用尚未被回收的空闲内存。</p>
<h2 id="redis内存分配算法"><a href="#redis内存分配算法" class="headerlink" title="redis内存分配算法"></a>redis内存分配算法</h2><p>　　redis的内存分配是直接交给第三方库来管理，jemalloc这个facebook的第三方库来管理。因为内存管理很复杂，需要考虑到内存碎片,性能优化，效率等，为了redis的简单高效，于是使用第三方插件.</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://skydh.github.io/2018/09/14/redis 事务/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="董航">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="why are you so happy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/14/redis 事务/" itemprop="url">redis 事务</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-14T11:03:30+08:00">
                2018-09-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Redis的事务"><a href="#Redis的事务" class="headerlink" title="Redis的事务"></a>Redis的事务</h2><p>　　基本每个成熟的数据库都有事务，redis也不例外。<br>　　redis通过multi(开始事务)，exec指事务的执行，discard表示事务的丢弃。<br>　　multi开始后，后面的指令不是直接执行，而是缓存在服务器redis的事务队列中，而服务器一旦收到exec指令，才开始执行整个事务队列，执行完毕后统一返回结果，由于redis的单线程特性，故不用担心其被其他指令打扰。<br>　　redis的事务没有原子性，中间的失败了，不仅不回滚，后面的反而继续执行。<br>　　我们可以用discard指令来丢弃redis事务队列里面的数据。<br>　　我们一般用pipeline来发送事务里面的指令一起发送，减少网络io次数。<br>　　但是redis里面无法做乘除法则，有时候需要乘除，那该怎么办呢？也就是说一个事务里面无法完成所有的操作，我们必须通过2个甚至多个事务来完成，这样就会有并发问题，因为这个不是串行的，可能2个事务之间，会有别的事务插进来。于是有了watch机制。就是开启事务之前，先watch要修改的key,然后在事务修改，当修改遇见问题则会报错，是一个乐观锁。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://skydh.github.io/2018/09/13/redis 管道/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="董航">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="why are you so happy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/13/redis 管道/" itemprop="url">redis 管道</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-13T17:47:48+08:00">
                2018-09-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>ps：读redis掘金小册</p>
<h2 id="pipe管道命令"><a href="#pipe管道命令" class="headerlink" title="pipe管道命令"></a>pipe管道命令</h2><p>　　管道命令本质上是为了减少网络io交互产生的，其实现是在客户端实现的，客户端将多个请求并到一起发送，然后一起返回，有效减少了io次数。<br>　　这便是管道操作的本质，服务器根本没有任何区别对待，还是收到一条消息，执行一条消息，回复一条消息的正常的流程。客户端通过对管道中的指令列表改变读写顺序就可以大幅节省 IO 时间。管道中指令越多，效果越好。<br>　　我们可以用： redis-benchmark -t set -P 2 -q来进行压测，看看其QPS。</p>
<h2 id="io操作真正的耗时点在哪里"><a href="#io操作真正的耗时点在哪里" class="headerlink" title="io操作真正的耗时点在哪里"></a>io操作真正的耗时点在哪里</h2><pre><code>１．客户端进程调用write将消息写到操作系统内核为套接字分配的发送缓冲send buffer。

２．客户端操作系统内核将发送缓冲的内容发送到网卡，网卡硬件将数据通过「网际路由」送到服务器的网卡。

３．服务器操作系统内核将网卡的数据放到内核为套接字分配的接收缓冲recv buffer。

４．服务器进程调用read从接收缓冲中取出消息进行处理。

５．服务器进程调用write将响应消息写到内核为套接字分配的发送缓冲send buffer。

６．服务器操作系统内核将发送缓冲的内容发送到网卡，网卡硬件将数据通过「网际路由」送到客户端的网卡。

７．客户端操作系统内核将网卡的数据放到内核为套接字分配的接收缓冲recv buffer。

８．客户端进程调用read从接收缓冲中取出消息返回给上层业务逻辑进行处理。
</code></pre><p>　　我们开始以为 write 操作是要等到对方收到消息才会返回，但实际上不是这样的。write 操作只负责将数据写到本地操作系统内核的发送缓冲然后就返回了。剩下的事交给操作系统内核异步将数据送到目标机器。但是如果发送缓冲满了，那么就需要等待缓冲空出空闲空间来，这个就是写操作 IO 操作的真正耗时。</p>
<p>　　我们开始以为 read 操作是从目标机器拉取数据，但实际上不是这样的。read 操作只负责将数据从本地操作系统内核的接收缓冲中取出来就了事了。但是如果缓冲是空的，那么就需要等待数据到来，这个就是读操作 IO 操作的真正耗时。</p>
<p>　　所以对于value = redis.get(key)这样一个简单的请求来说，write操作几乎没有耗时，直接写到发送缓冲就返回，而read就会比较耗时了，因为它要等待消息经过网络路由到目标机器处理后的响应消息,再回送到当前的内核读缓冲才可以返回。这才是一个网络来回的真正开销。</p>
<p>　　而管道操作就是只用等一个网路来回从而减少时间开销，实际上减少了多余的通信次数。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://skydh.github.io/2018/09/12/redis io模型/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="董航">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="why are you so happy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/12/redis io模型/" itemprop="url">redis io模型</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-12T17:23:39+08:00">
                2018-09-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>ps，读redi小册</p>
<h2 id="redis的几个特性"><a href="#redis的几个特性" class="headerlink" title="redis的几个特性"></a>redis的几个特性</h2><p>　　单线程：没错redis是单线程的。<br>　　快：因为所有数据都在内存里面。<br>　　单线程如何高效处理大并发请求：多路复用。非阻塞io。其实现和java nio,netty都是基于多路复用实现的，通过select函数不断轮训请求，然后判断请求类型，就行不同操作，比如连接请求，读请求，写请求等(具体实现请看我的博客关于java nio的一章)<br>　　Redis 会将每个客户端套接字都关联一个指令队列。客户端的指令通过队列来排队进行顺序处理，先到先服务。<br>　　Redis 同样也会为每个客户端套接字关联一个响应队列。Redis 服务器通过响应队列来将指令的返回结果回复给客户端．<br>　　Redis 的定时任务会记录在一个称为最小堆的数据结构中。这个堆中，最快要执行的任务排在堆的最上方。在每个循环周期，Redis 都会将最小堆里面已经到点的任务立即进行处理。处理完毕后，将最快要执行的任务还需要的时间记录下来，这个时间就是select系统调用的timeout参数。因为 Redis 知道未来timeout时间内，没有其它定时任务需要处理，所以可以安心睡眠timeout的时间。</p>
<h2 id="Redis-通信协议"><a href="#Redis-通信协议" class="headerlink" title="Redis 通信协议"></a>Redis 通信协议</h2><p>　　Redis通信协议是一个文本协议RESP。优势是实现简单，解析性能好。<br>Redis协议将所传输的数据分为5个最小类型。单元结束统一加\r\n:</p>
<pre><code>单行字符串 以 + 符号开头。
多行字符串 以 $ 符号开头，后跟字符串长度。
整数值 以 : 符号开头，后跟整数的字符串形式。
错误消息 以 - 符号开头。
数组 以 * 号开头，后跟数组的长度。
空串 用多行字符串表示，长度填 0。
</code></pre><p>　　set author codehole会被序列化成下面的字符串。</p>
<pre><code>*3
$3
set
$6
author
$8
codehole
</code></pre><h2 id="redis持久化"><a href="#redis持久化" class="headerlink" title="redis持久化"></a>redis持久化</h2><p>　　redis持久化有2个机制。一个是RDB(快照:全量备份，内存数据的2进制序列化形式)，一个是AOF(增量备份，记录内存数据的修改指令文本)。<br>　　快照原理：内存快照要求redis必须进行文件io操作，而这个操作是无法阻塞的。如果单线程在服务线上请求还要进行文件io操作，那么性能会变得很差，如果不阻塞线上的业务，便持久化边相应请求，持久化同时，内存数据结构还在变化，这怎么玩呢？redis采用多进程来进行处理。redis在持久化时fork一个子进程，快照持久化交给子进程来处理，父进程继续处理客户端请求。子进程刚产生时和父进程共享内存里面的代码段和数据段。所以不会导致内存突然变大。子进程做持久化，不会修改这个内存数据，只会对其结构不断遍历读取，然后序列化之后写到磁盘，但是父进程则是不断相应客户端请求，然后对内存数据不断修改。然后使用操作系统的写时复制机制，在内存里面，数据是一页一页的，当父进程修改内存数据时会把这个数据所在的那一页辅助一份出来，进行修改，等子进程顺利遍历完了，在替换合并。<br>　　AOF原理：就是一个日志存储着redis创建后的所有修改指令。redis是先执行指令在存日志的。同时redis长期运行会导致日志庞大，重启时间长，导致redis长期无法对外提供服务。所以需要瘦身，redis提供了bgrewriteaof 指令对aof日志瘦身，其原理是开辟一个子进程对内存进行遍历转换生成一系列的redis操作指令，序列化到一个新的aof日志文件里面，序列化后，再讲操作期间发生的增量aof日志加到新的aof日志文件里面，追加完毕即可代替旧的aof日志。aof日志以文件方式存在的，当程序对aof日志文件进行写操作时，实际上是将内容写到了内核为文件描述符分配的内存缓存，但是如果系统宕机了aof日志没来得及刷到磁盘，该如何。linux提供了fsync函数可以将日志文件强刷到磁盘。所以redis一般每隔一秒执行一次fsunc操作，使得尽可能减少数据丢失。<br>　　快照是通过开启子进程的方式进行的，它是一个比较耗资源的操作。</p>
<p>　　遍历整个内存，大块写磁盘会加重系统负载<br>　　AOF 的 fsync 是一个耗时的 IO 操作，它会降低 Redis 性能，同时也会增加系统 IO 负担<br>　　所以通常 Redis 的主节点是不会进行持久化操作，持久化操作主要在从节点进行。从节点是备份节点，没有来自客户端请求的压力，它的操作系统资源往往比较充沛。</p>
<p>　　但是如果出现网络分区，从节点长期连不上主节点，就会出现数据不一致的问题，特别是在网络分区出现的情况下又不小心主节点宕机了，那么数据就会丢失，所以在生产环境要做好实时监控工作，保证网络畅通或者能快速修复。另外还应该再增加一个从节点以降低网络分区的概率，只要有一个从节点数据同步正常，数据也就不会轻易丢失。</p>
<h2 id="混合持久化"><a href="#混合持久化" class="headerlink" title="混合持久化"></a>混合持久化</h2><p>　　redis4.0之后将rdb文件的内容和增量aof文件存在一起，这里的aof日志则是自持久化到持久化结束的增量aof文件.这样redis重启的时候则是先加载rdb文件，在加载aof日志文件。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://skydh.github.io/2018/09/11/spring data jpa/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="董航">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="why are you so happy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/11/spring data jpa/" itemprop="url">spring data jpa</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-11T10:02:07+08:00">
                2018-09-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p>　　公司框架为这个。且大多数同学不了解这个怎么玩。为了避免采坑太多，这里先学习总结下。</p>
<h2 id="代码地址以及相关介绍"><a href="#代码地址以及相关介绍" class="headerlink" title="代码地址以及相关介绍"></a>代码地址以及相关介绍</h2><p>　　本代码使用spring+spring mvc+spring data jpa+hibernate+mysql(8.0之后的版本)<br>　　git地址：<a href="https://github.com/skydh/SpringJpaLearn" target="_blank" rel="noopener">https://github.com/skydh/SpringJpaLearn</a><br>　　为了方便公司的小伙伴们看。<br>　　公司内部git地址：<a href="http://git.ipo.com/donghang846/spring-jpa-learn.git" target="_blank" rel="noopener">http://git.ipo.com/donghang846/spring-jpa-learn.git</a>
　　</p>
<h2 id="单表的3种简单查询模式以及注意点。"><a href="#单表的3种简单查询模式以及注意点。" class="headerlink" title="单表的3种简单查询模式以及注意点。"></a>单表的3种简单查询模式以及注意点。</h2><p>　　１．直接调用接口自带的方法。我们继承的是JpaRepository接口。主要有</p>
<pre><code>count() 获取表多少数据。
findOne() 根据id获取数据。
save() 保存数据。
等。
</code></pre><p>　　注意点：</p>
<p>　　第一点.getone()和findone()作用一样都是根据id获取对象，但是getone是懒加载，没有配置的要报错，还有实体转json的时候也会报错。再看了源代码对接口的解释findOne返回实体，而getOne则是返回实体的引用。总而言之，最好用findOne.<br>　　<br>　　第二点：我们调用save方法时，如果主键不是自增的，我们必须在entity里面增加id,因为jpa会先根据这个id在数据库里面查询数据，如果有数据，那么生成的sql则是更新语句，也就是这个save方法同时承担了更新的职责。<br>　　<br>　　２．在对应的dao接口里面写好方法，调用这个接口即可调用sql获取数据。spring-data-jpa会根据方法的名字来自动生成sql语句，我们只需要按照方法定义的规则即可。规则如我网上找的表。<br>    <img src="https://raw.githubusercontent.com/skydh/picture/master/jpa.png" alt="aaa"><br>　　案例如下：</p>
<pre><code>public interface UserDao extends JpaRepository&lt;User, Serializable&gt; {

/**
 * 根据name,id 找这个人
 * @param name
 * @param id
 * @return
 */
User findByNameAndId(String name,Integer id);
</code></pre><p>}</p>
<p>　　３.当上面２方法都不满足你的需求的时候，或者想自己写sql稳定精确一点的。可以自定义sql。案例如下：</p>
<pre><code>public interface UserDao extends JpaRepository&lt;User, Serializable&gt; {

@Query(value=&quot;select * from User where address= :address&quot; ,nativeQuery = true)
List&lt;User&gt; findUserByAddress(@Param(&quot;address&quot;)String address );
}
</code></pre><p>　　这里有几个注意点<br>　　１．这里我推荐使用　nativeQuery = true　方式，直接写sql，因为确定了，我们的数据库是mysql,所以我们直接写mysql的sql即可。<br>　　２．除了查询语句这种快照读之外，其余所有的语句都要加　@Transactional<br>　　@Modifying<br>　　例子如下：</p>
<pre><code>@Transactional
@Modifying
@Query(value=&quot;update User set address= :address where name= :name&quot;)
void updateData(@Param(&quot;name&quot;)String name,@Param(&quot;address&quot;)String address);
</code></pre><p>　　<br>　　因为jpa对于非快照操作，要求必须都是事务操作。</p>
<h2 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h2><p>　　这边鉴于大多数同学都喜欢mybatis，喜欢写原生sql,这边采用EntityManager这个类来进行多表查询，相对于specification，确实利于优化和调试。<br>　　话不多说，上代码：</p>
<pre><code>@Repository
public class UserDao {
@Autowired 
private EntityManager entityManager;
public void getUser() {
    StringBuilder sb = new StringBuilder();
    sb.append(&quot;select a.name as name ,b.name as name1 from user a inner join Orders b on a.id=b.user_id&quot;);
    Query query = entityManager.createNativeQuery(sb.toString());
    List&lt;Object&gt; list = query.getResultList();
    for (Object user : list) {
        System.out.println(user);
    }
}
}
</code></pre><p>　　如此可以多表查询，且很方便。我们可以在自己拼装sql的时候加逻辑判断。<br>　　几个注意点：<br>　　１．这个有的表的字段有重复名的我们必须起别名，不然报错。这边最好用有Native关键字的方法，便于我们使用原生sql.</p>
<pre><code>Query query1 = entityManager.createNativeQuery(sb.toString(),UserEntity.class);
</code></pre><p>　　第一个返回的都是一个个Object对象，我们要自己拼装成自己需要的vo,但是当sql返回的都是一个表的数据时，我们可以在后面传这个这个类的Class对象。这样不用拼装sql了。但是坑爹的是，我们必须将这个entity的所有字段都要对应上才行。<br>　　由于上面要一个个对应字段，太麻烦了，这边写了一个工具类，帮助大家提高效率，和代码工整度。代码就不细说了，有问题联系我修改哈。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://skydh.github.io/2018/09/10/redis限流/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="董航">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="why are you so happy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/10/redis限流/" itemprop="url">redis之简单限流</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-10T09:31:48+08:00">
                2018-09-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="什么是接口限流"><a href="#什么是接口限流" class="headerlink" title="什么是接口限流"></a>什么是接口限流</h2><p>　　为什么要有接口限流？场景如下：１．接口限流，比如我们对外一个接口，我们要限制一个用户单位时间访问次数？２．系统要限定用户的某个行为在指定的时间A里只能允许发生 N 次。</p>
<h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><p>　　我们用zset来实现这个方案。我们将用户id和事件id生成这个zset的容器id,当发生一次时，我们将当前时间作为score,同时也作为value,放到集合里面。然后删除这个元素加入前限定时间A之外的数据。然后将集合的所有数据设置为过了A时间就过期.然后取出这个集合有多少数据，判断是否超标。</p>
<pre><code>public boolean isActionAllowed(String userId, String     actionKey, int period, int maxCount) {
    String key = String.format(&quot;hist:%s:%s&quot;, userId, actionKey);
    long nowTs = System.currentTimeMillis();
    Pipeline pipe = jedis.pipelined();
    pipe.multi();
    pipe.zadd(key, nowTs, &quot;&quot; + nowTs);
    pipe.zremrangeByScore(key, 0, nowTs - period * 1000);
    Response&lt;Long&gt; count = pipe.zcard(key);
    pipe.expire(key, period + 1);
    pipe.exec();
    pipe.close();
    return count.get() &lt;= maxCount;
</code></pre><p>  }</p>
<h2 id="漏斗限流策略"><a href="#漏斗限流策略" class="headerlink" title="漏斗限流策略"></a>漏斗限流策略</h2><pre><code>public class FunnelRateLimiter {
static class Funnel {
int capacity;//容量
float leakingRate;//漏水速度
int leftQuota;//剩余容量
long leakingTs;//上次漏水时间

public Funnel(int capacity, float leakingRate) {
  this.capacity = capacity;
  this.leakingRate = leakingRate;
  this.leftQuota = capacity;
  this.leakingTs = System.currentTimeMillis();
}

void makeSpace() {
  long nowTs = System.currentTimeMillis();
  long deltaTs = nowTs - leakingTs;
  int deltaQuota = (int) (deltaTs * leakingRate);
  if (deltaQuota &lt; 0) { // 间隔时间太长，整数数字过大溢出
    this.leftQuota = capacity;
    this.leakingTs = nowTs;
    return;
  }
  if (deltaQuota &lt; 1) { // 腾出空间太小，最小单位是1
    return;
  }
  this.leftQuota += deltaQuota;
  this.leakingTs = nowTs;
  if (this.leftQuota &gt; this.capacity) {
    this.leftQuota = this.capacity;
  }
}
boolean watering(int quota) {
  makeSpace();
  if (this.leftQuota &gt;= quota) {
    this.leftQuota -= quota;
    return true;
  }
  return false;
}
}
private Map&lt;String, Funnel&gt; funnels = new HashMap&lt;&gt;();
public boolean isActionAllowed(String userId, String actionKey, int capacity, float leakingRate) {
String key = String.format(&quot;%s:%s&quot;, userId, actionKey);
Funnel funnel = funnels.get(key);
if (funnel == null) {
  funnel = new Funnel(capacity, leakingRate);
  funnels.put(key, funnel);
}
return funnel.watering(1); // 需要1个quota
}
}
</code></pre><p>　　<br>　　Funnel 对象的 make_space 方法是漏斗算法的核心，其在每次灌水前都会被调用以触发漏水，给漏斗腾出空间来。能腾出多少空间取决于过去了多久以及流水的速率。Funnel 对象占据的空间大小不再和行为的频率成正比，它的空间占用是一个常量。<br>　　我们观察 Funnel 对象的几个字段，我们发现可以将 Funnel 对象的内容按字段存储到一个 hash 结构中，灌水的时候将 hash 结构的字段取出来进行逻辑运算后，再将新值回填到 hash 结构中就完成了一次行为频度的检测。</p>
<h2 id="新方案"><a href="#新方案" class="headerlink" title="新方案"></a>新方案</h2><p>　　redis4.0出了一个新的模块。叫redis-cell。该模块也使用了漏斗算法，且提供了限流指令。<br>　　cl.throttle sd:sd 15 30 60<br>　　意思是15的容量，每60秒就丢弃30个元素。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/4/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><a class="extend next" rel="next" href="/page/6/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">董航</p>
              <p class="site-description motion-element" itemprop="description">clear 航</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">114</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            

          </nav>

          

          <div class="links-of-author motion-element">
            
          </div>

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">董航</span>

  
</div>


<div class="powered-by">
<i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv">
  本站访客数:<span id="busuanzi_value_site_uv"></span>
</span>
</div>

  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.3</div>




        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.3"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
