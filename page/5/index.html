<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="clear 航">
<meta property="og:type" content="website">
<meta property="og:title" content="why are you so happy">
<meta property="og:url" content="https://skydh.github.io/page/5/index.html">
<meta property="og:site_name" content="why are you so happy">
<meta property="og:description" content="clear 航">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="why are you so happy">
<meta name="twitter:description" content="clear 航">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://skydh.github.io/page/5/"/>





  <title>why are you so happy</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">why are you so happy</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">clear 航</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://skydh.github.io/2018/09/12/redis io模型/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="董航">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="why are you so happy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/12/redis io模型/" itemprop="url">redis io模型</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-12T17:23:39+08:00">
                2018-09-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>ps，读redi小册</p>
<h2 id="redis的几个特性"><a href="#redis的几个特性" class="headerlink" title="redis的几个特性"></a>redis的几个特性</h2><p>　　单线程：没错redis是单线程的。<br>　　快：因为所有数据都在内存里面。<br>　　单线程如何高效处理大并发请求：多路复用。非阻塞io。其实现和java nio,netty都是基于多路复用实现的，通过select函数不断轮训请求，然后判断请求类型，就行不同操作，比如连接请求，读请求，写请求等(具体实现请看我的博客关于java nio的一章)<br>　　Redis 会将每个客户端套接字都关联一个指令队列。客户端的指令通过队列来排队进行顺序处理，先到先服务。<br>　　Redis 同样也会为每个客户端套接字关联一个响应队列。Redis 服务器通过响应队列来将指令的返回结果回复给客户端．<br>　　Redis 的定时任务会记录在一个称为最小堆的数据结构中。这个堆中，最快要执行的任务排在堆的最上方。在每个循环周期，Redis 都会将最小堆里面已经到点的任务立即进行处理。处理完毕后，将最快要执行的任务还需要的时间记录下来，这个时间就是select系统调用的timeout参数。因为 Redis 知道未来timeout时间内，没有其它定时任务需要处理，所以可以安心睡眠timeout的时间。</p>
<h2 id="Redis-通信协议"><a href="#Redis-通信协议" class="headerlink" title="Redis 通信协议"></a>Redis 通信协议</h2><p>　　Redis通信协议是一个文本协议RESP。优势是实现简单，解析性能好。<br>Redis协议将所传输的数据分为5个最小类型。单元结束统一加\r\n:</p>
<pre><code>单行字符串 以 + 符号开头。
多行字符串 以 $ 符号开头，后跟字符串长度。
整数值 以 : 符号开头，后跟整数的字符串形式。
错误消息 以 - 符号开头。
数组 以 * 号开头，后跟数组的长度。
空串 用多行字符串表示，长度填 0。
</code></pre><p>　　set author codehole会被序列化成下面的字符串。</p>
<pre><code>*3
$3
set
$6
author
$8
codehole
</code></pre><h2 id="redis持久化"><a href="#redis持久化" class="headerlink" title="redis持久化"></a>redis持久化</h2><p>　　redis持久化有2个机制。一个是RDB(快照:全量备份，内存数据的2进制序列化形式)，一个是AOF(增量备份，记录内存数据的修改指令文本)。<br>　　快照原理：内存快照要求redis必须进行文件io操作，而这个操作是无法阻塞的。如果单线程在服务线上请求还要进行文件io操作，那么性能会变得很差，如果不阻塞线上的业务，便持久化边相应请求，持久化同时，内存数据结构还在变化，这怎么玩呢？redis采用多进程来进行处理。redis在持久化时fork一个子进程，快照持久化交给子进程来处理，父进程继续处理客户端请求。子进程刚产生时和父进程共享内存里面的代码段和数据段。所以不会导致内存突然变大。子进程做持久化，不会修改这个内存数据，只会对其结构不断遍历读取，然后序列化之后写到磁盘，但是父进程则是不断相应客户端请求，然后对内存数据不断修改。然后使用操作系统的写时复制机制，在内存里面，数据是一页一页的，当父进程修改内存数据时会把这个数据所在的那一页辅助一份出来，进行修改，等子进程顺利遍历完了，在替换合并。<br>　　AOF原理：就是一个日志存储着redis创建后的所有修改指令。redis是先执行指令在存日志的。同时redis长期运行会导致日志庞大，重启时间长，导致redis长期无法对外提供服务。所以需要瘦身，redis提供了bgrewriteaof 指令对aof日志瘦身，其原理是开辟一个子进程对内存进行遍历转换生成一系列的redis操作指令，序列化到一个新的aof日志文件里面，序列化后，再讲操作期间发生的增量aof日志加到新的aof日志文件里面，追加完毕即可代替旧的aof日志。aof日志以文件方式存在的，当程序对aof日志文件进行写操作时，实际上是将内容写到了内核为文件描述符分配的内存缓存，但是如果系统宕机了aof日志没来得及刷到磁盘，该如何。linux提供了fsync函数可以将日志文件强刷到磁盘。所以redis一般每隔一秒执行一次fsunc操作，使得尽可能减少数据丢失。<br>　　快照是通过开启子进程的方式进行的，它是一个比较耗资源的操作。</p>
<p>　　遍历整个内存，大块写磁盘会加重系统负载<br>　　AOF 的 fsync 是一个耗时的 IO 操作，它会降低 Redis 性能，同时也会增加系统 IO 负担<br>　　所以通常 Redis 的主节点是不会进行持久化操作，持久化操作主要在从节点进行。从节点是备份节点，没有来自客户端请求的压力，它的操作系统资源往往比较充沛。</p>
<p>　　但是如果出现网络分区，从节点长期连不上主节点，就会出现数据不一致的问题，特别是在网络分区出现的情况下又不小心主节点宕机了，那么数据就会丢失，所以在生产环境要做好实时监控工作，保证网络畅通或者能快速修复。另外还应该再增加一个从节点以降低网络分区的概率，只要有一个从节点数据同步正常，数据也就不会轻易丢失。</p>
<h2 id="混合持久化"><a href="#混合持久化" class="headerlink" title="混合持久化"></a>混合持久化</h2><p>　　redis4.0之后将rdb文件的内容和增量aof文件存在一起，这里的aof日志则是自持久化到持久化结束的增量aof文件.这样redis重启的时候则是先加载rdb文件，在加载aof日志文件。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://skydh.github.io/2018/09/11/spring data jpa/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="董航">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="why are you so happy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/11/spring data jpa/" itemprop="url">spring data jpa</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-11T10:02:07+08:00">
                2018-09-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p>　　公司框架为这个。且大多数同学不了解这个怎么玩。为了避免采坑太多，这里先学习总结下。</p>
<h2 id="代码地址以及相关介绍"><a href="#代码地址以及相关介绍" class="headerlink" title="代码地址以及相关介绍"></a>代码地址以及相关介绍</h2><p>　　本代码使用spring+spring mvc+spring data jpa+hibernate+mysql(8.0之后的版本)<br>　　git地址：<a href="https://github.com/skydh/SpringJpaLearn" target="_blank" rel="noopener">https://github.com/skydh/SpringJpaLearn</a><br>　　为了方便公司的小伙伴们看。<br>　　公司内部git地址：<a href="http://git.ipo.com/donghang846/spring-jpa-learn.git" target="_blank" rel="noopener">http://git.ipo.com/donghang846/spring-jpa-learn.git</a>
　　</p>
<h2 id="单表的3种简单查询模式以及注意点。"><a href="#单表的3种简单查询模式以及注意点。" class="headerlink" title="单表的3种简单查询模式以及注意点。"></a>单表的3种简单查询模式以及注意点。</h2><p>　　１．直接调用接口自带的方法。我们继承的是JpaRepository接口。主要有</p>
<pre><code>count() 获取表多少数据。
findOne() 根据id获取数据。
save() 保存数据。
等。
</code></pre><p>　　注意点：</p>
<p>　　第一点.getone()和findone()作用一样都是根据id获取对象，但是getone是懒加载，没有配置的要报错，还有实体转json的时候也会报错。再看了源代码对接口的解释findOne返回实体，而getOne则是返回实体的引用。总而言之，最好用findOne.<br>　　<br>　　第二点：我们调用save方法时，如果主键不是自增的，我们必须在entity里面增加id,因为jpa会先根据这个id在数据库里面查询数据，如果有数据，那么生成的sql则是更新语句，也就是这个save方法同时承担了更新的职责。<br>　　<br>　　２．在对应的dao接口里面写好方法，调用这个接口即可调用sql获取数据。spring-data-jpa会根据方法的名字来自动生成sql语句，我们只需要按照方法定义的规则即可。规则如我网上找的表。<br>    <img src="https://raw.githubusercontent.com/skydh/picture/master/jpa.png" alt="aaa"><br>　　案例如下：</p>
<pre><code>public interface UserDao extends JpaRepository&lt;User, Serializable&gt; {

/**
 * 根据name,id 找这个人
 * @param name
 * @param id
 * @return
 */
User findByNameAndId(String name,Integer id);
</code></pre><p>}</p>
<p>　　３.当上面２方法都不满足你的需求的时候，或者想自己写sql稳定精确一点的。可以自定义sql。案例如下：</p>
<pre><code>public interface UserDao extends JpaRepository&lt;User, Serializable&gt; {

@Query(value=&quot;select * from User where address= :address&quot; ,nativeQuery = true)
List&lt;User&gt; findUserByAddress(@Param(&quot;address&quot;)String address );
}
</code></pre><p>　　这里有几个注意点<br>　　１．这里我推荐使用　nativeQuery = true　方式，直接写sql，因为确定了，我们的数据库是mysql,所以我们直接写mysql的sql即可。<br>　　２．除了查询语句这种快照读之外，其余所有的语句都要加　@Transactional<br>　　@Modifying<br>　　例子如下：</p>
<pre><code>@Transactional
@Modifying
@Query(value=&quot;update User set address= :address where name= :name&quot;)
void updateData(@Param(&quot;name&quot;)String name,@Param(&quot;address&quot;)String address);
</code></pre><p>　　<br>　　因为jpa对于非快照操作，要求必须都是事务操作。</p>
<h2 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h2><p>　　这边鉴于大多数同学都喜欢mybatis，喜欢写原生sql,这边采用EntityManager这个类来进行多表查询，相对于specification，确实利于优化和调试。<br>　　话不多说，上代码：</p>
<pre><code>@Repository
public class UserDao {
@Autowired 
private EntityManager entityManager;
public void getUser() {
    StringBuilder sb = new StringBuilder();
    sb.append(&quot;select a.name as name ,b.name as name1 from user a inner join Orders b on a.id=b.user_id&quot;);
    Query query = entityManager.createNativeQuery(sb.toString());
    List&lt;Object&gt; list = query.getResultList();
    for (Object user : list) {
        System.out.println(user);
    }
}
}
</code></pre><p>　　如此可以多表查询，且很方便。我们可以在自己拼装sql的时候加逻辑判断。<br>　　几个注意点：<br>　　１．这个有的表的字段有重复名的我们必须起别名，不然报错。这边最好用有Native关键字的方法，便于我们使用原生sql.</p>
<pre><code>Query query1 = entityManager.createNativeQuery(sb.toString(),UserEntity.class);
</code></pre><p>　　第一个返回的都是一个个Object对象，我们要自己拼装成自己需要的vo,但是当sql返回的都是一个表的数据时，我们可以在后面传这个这个类的Class对象。这样不用拼装sql了。但是坑爹的是，我们必须将这个entity的所有字段都要对应上才行。<br>　　由于上面要一个个对应字段，太麻烦了，这边写了一个工具类，帮助大家提高效率，和代码工整度。代码就不细说了，有问题联系我修改哈。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://skydh.github.io/2018/09/10/redis限流/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="董航">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="why are you so happy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/10/redis限流/" itemprop="url">redis之简单限流</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-10T09:31:48+08:00">
                2018-09-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="什么是接口限流"><a href="#什么是接口限流" class="headerlink" title="什么是接口限流"></a>什么是接口限流</h2><p>　　为什么要有接口限流？场景如下：１．接口限流，比如我们对外一个接口，我们要限制一个用户单位时间访问次数？２．系统要限定用户的某个行为在指定的时间A里只能允许发生 N 次。</p>
<h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><p>　　我们用zset来实现这个方案。我们将用户id和事件id生成这个zset的容器id,当发生一次时，我们将当前时间作为score,同时也作为value,放到集合里面。然后删除这个元素加入前限定时间A之外的数据。然后将集合的所有数据设置为过了A时间就过期.然后取出这个集合有多少数据，判断是否超标。</p>
<pre><code>public boolean isActionAllowed(String userId, String     actionKey, int period, int maxCount) {
    String key = String.format(&quot;hist:%s:%s&quot;, userId, actionKey);
    long nowTs = System.currentTimeMillis();
    Pipeline pipe = jedis.pipelined();
    pipe.multi();
    pipe.zadd(key, nowTs, &quot;&quot; + nowTs);
    pipe.zremrangeByScore(key, 0, nowTs - period * 1000);
    Response&lt;Long&gt; count = pipe.zcard(key);
    pipe.expire(key, period + 1);
    pipe.exec();
    pipe.close();
    return count.get() &lt;= maxCount;
</code></pre><p>  }</p>
<h2 id="漏斗限流策略"><a href="#漏斗限流策略" class="headerlink" title="漏斗限流策略"></a>漏斗限流策略</h2><pre><code>public class FunnelRateLimiter {
static class Funnel {
int capacity;//容量
float leakingRate;//漏水速度
int leftQuota;//剩余容量
long leakingTs;//上次漏水时间

public Funnel(int capacity, float leakingRate) {
  this.capacity = capacity;
  this.leakingRate = leakingRate;
  this.leftQuota = capacity;
  this.leakingTs = System.currentTimeMillis();
}

void makeSpace() {
  long nowTs = System.currentTimeMillis();
  long deltaTs = nowTs - leakingTs;
  int deltaQuota = (int) (deltaTs * leakingRate);
  if (deltaQuota &lt; 0) { // 间隔时间太长，整数数字过大溢出
    this.leftQuota = capacity;
    this.leakingTs = nowTs;
    return;
  }
  if (deltaQuota &lt; 1) { // 腾出空间太小，最小单位是1
    return;
  }
  this.leftQuota += deltaQuota;
  this.leakingTs = nowTs;
  if (this.leftQuota &gt; this.capacity) {
    this.leftQuota = this.capacity;
  }
}
boolean watering(int quota) {
  makeSpace();
  if (this.leftQuota &gt;= quota) {
    this.leftQuota -= quota;
    return true;
  }
  return false;
}
}
private Map&lt;String, Funnel&gt; funnels = new HashMap&lt;&gt;();
public boolean isActionAllowed(String userId, String actionKey, int capacity, float leakingRate) {
String key = String.format(&quot;%s:%s&quot;, userId, actionKey);
Funnel funnel = funnels.get(key);
if (funnel == null) {
  funnel = new Funnel(capacity, leakingRate);
  funnels.put(key, funnel);
}
return funnel.watering(1); // 需要1个quota
}
}
</code></pre><p>　　<br>　　Funnel 对象的 make_space 方法是漏斗算法的核心，其在每次灌水前都会被调用以触发漏水，给漏斗腾出空间来。能腾出多少空间取决于过去了多久以及流水的速率。Funnel 对象占据的空间大小不再和行为的频率成正比，它的空间占用是一个常量。<br>　　我们观察 Funnel 对象的几个字段，我们发现可以将 Funnel 对象的内容按字段存储到一个 hash 结构中，灌水的时候将 hash 结构的字段取出来进行逻辑运算后，再将新值回填到 hash 结构中就完成了一次行为频度的检测。</p>
<h2 id="新方案"><a href="#新方案" class="headerlink" title="新方案"></a>新方案</h2><p>　　redis4.0出了一个新的模块。叫redis-cell。该模块也使用了漏斗算法，且提供了限流指令。<br>　　cl.throttle sd:sd 15 30 60<br>　　意思是15的容量，每60秒就丢弃30个元素。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://skydh.github.io/2018/09/06/redis布隆过滤器/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="董航">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="why are you so happy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/06/redis布隆过滤器/" itemprop="url">redis之布隆过滤器</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-06T11:06:22+08:00">
                2018-09-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="由来"><a href="#由来" class="headerlink" title="由来"></a>由来</h2><p>　　情景：当我们使用新闻客户端看新闻时，他会不断推送新的内容，他每次推荐时都要去重，那么问题来了，客户端如何实现推送去重呢？<br>　　当然不会采用记录用户看过的内容，第一数据量大，第二不断exists消耗性能太多。缓存也不行，时间久了数据量太大。<br>　　这个时候布隆过滤器出现了。</p>
<h2 id="什么是布隆过滤器"><a href="#什么是布隆过滤器" class="headerlink" title="什么是布隆过滤器"></a>什么是布隆过滤器</h2><p>　　这是一个不怎么精确地set结构，当你使用它的contains方法判断某个数据是否存在时，他可能误判，布隆过滤器是不精确的。只要参数设置合理，那么其精确度是可控的。其判断一个值存在时，其可能不存在，判断一个值不存在时，那么一定不存在。</p>
<h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p>　　bf.add 添加元素，bf.exists,查询元素是否存在，其用法和set集合差不多，批量命令是bf.madd指令，批量查询则是bf.mexists指令。我们创建的布隆过滤器都是默认的过滤器，在我们第一次add的时候自动创建。，但是为了提供高精确率。我们可以用bf.reserve指令来修改其参数即可。第一个为其名字，第二个为<br>     client.createFilter(“codehole”, 50000, 0.001);第二个参数为预计存放数据量，第三个为误差率。误差率越低，需要空间越大。</p>
<h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>　　底层是一个大型的位数组，和几个无偏的hash函数（无偏就是让hash值分布均匀）。添加值的时候，会用多个hash函数对key进行hash运算，然后对应数组上不同点，再把这些点全部置为1。询问key是否存在时，和add一样，也是用hash算法吧这些位置都计算出来，看看是否都为1，只要有一个为0，那么这个值不存在。当然如果都是1，也不一定都存在，可能是其他计算的点正好都覆盖了。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://skydh.github.io/2018/09/05/HypeLogLog/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="董航">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="why are you so happy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/05/HypeLogLog/" itemprop="url">redis之HyperLogLog</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-05T11:53:10+08:00">
                2018-09-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="由来"><a href="#由来" class="headerlink" title="由来"></a>由来</h2><p>　　PV和UV,统计pv很简单，对每个网页加一个独立的redis计数器即可，这个计数器+当天的日期，每来一个请求，就incrby一次即可。但是UV不一样要求一个用户只能算一次，或许你想到了可以用set,把每一个页面放到set里面，当一个请求来了，就将其sadd进去，也可以通过scard取出这个集合的大小，但是有个问题，那就是访问量很大的时候，这个set集合就会很大。而这个redis提供的HyperLogLog数据结构来解决该问题。该数据结构提供一个不精确去重计数方案。</p>
<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>　　HyperLogLog提供了2个指令pfadd,pfcount 根据字面意思很好理解，一个是增加计数，一个是获取计数，pfadd的用法和set集合的asdd一样的，pfcount和scard用法一样的，直接获取计数值。pfmerge将２个HyperLogLog合并。<br>　　pfadd codehole user1<br>　　其底层实现是稠密矩阵。一个我也不懂的数据结构
　　</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://skydh.github.io/2018/09/05/redis位图/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="董航">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="why are you so happy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/05/redis位图/" itemprop="url">redis 位图</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-05T09:09:13+08:00">
                2018-09-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>ps：读掘金小册笔记</p>
<h2 id="位图的产生和作用"><a href="#位图的产生和作用" class="headerlink" title="位图的产生和作用"></a>位图的产生和作用</h2><p>　　开发时我们常常需要存储一些bool型数据类型，比如用户的签到记录，签了为1，没签为0，如果用普通的key/value，每个用户要记录365个，当用户多的时候，需要的存储太多，为了解决这个问题，redis提供了位图数据结构，每天的签到记录只占据一个位，365天就是365位，也就是46个字节，其内容也是普通的字符串，也就是byte数组，可以用get,set获取和设置整个数组，也可以用getbite/setbite来将其作为数组来操作。</p>
<h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><p>　　setbit a 1 1;这个就是设置这个a这个数组第二位位1，getbite a 1,获取a这个byte数组的第二位的数字，如果直接用get a 则是获得到这个byte数组对应的Ascll值，用时我们也可以先set字符，然后getbite 其数组。总之，这2套操作是互通的。</p>
<h2 id="统计查找"><a href="#统计查找" class="headerlink" title="统计查找"></a>统计查找</h2><p>　　redis提供了位图统计指令bitcount和位图查找指令bitpos,bitcount是统计指定位置范围内1的个数，bitpos用来查找指定范围内出现的第一个0或者1。后面的2个参数指的是字符索引。比如bitcount w 0 0,表示w字节数组第一个字符中1的位数。比如bitcount w 0 1,则是查询前2个字符中1的位数。bitpos w 0,表示查询w这个字节数组第一个出现0的位置，bitpop w 1 2 2,表示查询第三个字符中第一个1出现的位置。</p>
<h2 id="批量处理"><a href="#批量处理" class="headerlink" title="批量处理"></a>批量处理</h2><p>　　１．前面getite都是单个单个执行的。如果想批量执行，就要用bitfield这个指令。<br>　　比如：bitfield w get u4 0,从第一个位置开始取4个数，结果是无符号数（u）,bitfield w get i3 2,从第三个数开始取3个数，结果是有符号数（i）.所谓有符号就是第一位是符号位，有符号数最多可以获取64位，无符号只能63位（redis协议中integer就是有符号数）<br>　　 bitfield w set u8 8 97 这个就是把第二个字符改成ａ，因为ａ的ASCII码的值是97.这就可以批量修改字节数组的值。</p>
<p>　　bitfield w incrby u4 2 1  这个就是从第三个位开始，对接下来的无符号数＋１，既然是自增操作，那么就可能出现溢出如果增加了正数就会上溢，如果增加的负数就会下溢出，redis默认的方法时折返，如果出现了溢出，就将溢出的符号位丢了。关于溢出，默认是折返<br>　　还有其他策略，饱和截断超过了范围就停留在最大值最小值那里，失败报错不执行。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://skydh.github.io/2018/09/04/redis消息队列/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="董航">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="why are you so happy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/04/redis消息队列/" itemprop="url">redis消息队列</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-04T16:53:36+08:00">
                2018-09-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>ps：读掘金小册笔记</p>
<h2 id="简单的异步消息队列"><a href="#简单的异步消息队列" class="headerlink" title="简单的异步消息队列"></a>简单的异步消息队列</h2><p>　　对于一些只有一组消费者的消息队列，使用redis可以轻松解决，redis的list结构可以很好的处理，这个list的基本操作rpush，lpush,rpop,lpop即可处理队列。</p>
<h2 id="队列为空怎么破"><a href="#队列为空怎么破" class="headerlink" title="队列为空怎么破"></a>队列为空怎么破</h2><p>　　客户端通过pop操作来获取消息，从而消费，如果队列空了，客户端就会进入pop的死循环，由于没数据，不停的pop，这种空循环不但对客户端影响很大，对redis的qps也有影响，我们则是通过sleep来解决这个问题，让线程睡一下即可，也就是暂停一秒左右。</p>
<h2 id="队列延迟"><a href="#队列延迟" class="headerlink" title="队列延迟"></a>队列延迟</h2><p>　　这个让线程休眠会导致消息延迟变高，有个办法可以避免这个问题，不用让线程睡眠，那就是用blpop/brpop阻塞读，阻塞读在队列没有数据的时候，会进入到休眠状态，一旦数据到来，就会立刻醒过来。</p>
<h2 id="空闲连接自动断开"><a href="#空闲连接自动断开" class="headerlink" title="空闲连接自动断开"></a>空闲连接自动断开</h2><p>　　如果这个线程一直阻塞在哪里，redis的客户端连接就会变成限制连接，服务器会主动断开，减少资源占用，这个时候blpop/brpop就会抛出异常。，因此编写客户端的时候要注意捕捉异常。</p>
<h2 id="锁冲突处理"><a href="#锁冲突处理" class="headerlink" title="锁冲突处理"></a>锁冲突处理</h2><p>　　请求加锁失败时：<br>　　１．直接抛出异常。２．sleep一会再试。3.将请求移动到延时队列，过一会再试试。实现如下：<br>　　通过zset来实现延时队列，我们将消息序列化为value,到期时间作为score，然后多个线程轮训获取到期任务处理。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://skydh.github.io/2018/09/03/redis分布式锁/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="董航">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="why are you so happy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/03/redis分布式锁/" itemprop="url">redis分布式锁</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-03T17:47:45+08:00">
                2018-09-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="什么是分布式锁"><a href="#什么是分布式锁" class="headerlink" title="什么是分布式锁"></a>什么是分布式锁</h2><p>　　一个重要资源被多个jvm进程竞争，会发生数据安全问题，对于分布式系统来说，多个微服务同时竞争一个资源时，就会产生如上问题。对于该问题，我们的方案是用分布式锁来锁住该数据。</p>
<h2 id="使用redis来分布式锁。"><a href="#使用redis来分布式锁。" class="headerlink" title="使用redis来分布式锁。"></a>使用redis来分布式锁。</h2><p>　　分布式锁的本质是在redis里面占一个坑，当别的进程也要占时，却占不了了，只能等待，或者放弃。<br>　　命令如下setnx(set if not exists)只允许一个客户端占坑，然后del 则是删除这个锁。</p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>　　１．由于种种原因，比如程序执行到中间出了bug,导致这个del指令没有被调用，这样就会陷入死锁。</p>
<p>　　２．于是我们队这个setnx加了过期时间限制，比如setnx lock true; expire lock 5,使得过5秒自动过期。然后再删除。但是存在问题，当setnx和expire之间服务器突然挂掉了，会导致expire得不到执行，从而继续死锁。如果用redis事务来处理也不行，因为当setnx没有抢到锁时，expire是不该被执行的。而这个redis事务里面没有ifelse判断语句。后续redis2.8版本该作者加入了set指令的扩展参数，是的setnx和expire可以一起执行形成一个原子操作。彻底解决了这个问题。</p>
<p>　　３．存在超时问题：当一个进程获取到锁后，由于逻辑执行部分太长，以至于超出了锁的超时限制。<br>　　<br>　　那就出现了问题，因为第二个进程获取到了这个锁，接着第一个线程执行了业务逻辑，于是就释放了这个锁，那么第三个进程就会获取到这个锁。<br>　　　<br>　　为了避免这个问题，redis分布式锁，一般不用于较长时间的任务，如果真的出现了，那会很麻烦。为了避免第一个进程删除第二个进程锁的问题。我们可以在加锁前，设置一个随机数，释放锁的时候就进行判断是否需要删除这个锁。这样就保证了自己删自己的锁。但是匹配value和删除可以不是一个原子操作，这就需要lua脚本处理了，因为lua脚本可以保证多个命令是原子操作的。可以将匹配和删除放在一起。</p>
<p>　　４．主从集群问题，当主节点挂掉了，从节点变成了主节点，但是从节点没有锁，其他进程就会请求加锁成功。为了解决这个问题，有些开源的library对其做了良好的封装。用户可以拿来就用。比如redlock-py,加锁时，它会向过半节点发送加锁命令，释放锁的时候，则是删除所有节点信息</p>
<h2 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h2><p>　　获取锁。要让其加锁和释放锁的是同一个线程，因此给这个key加了valu.第三个为nxxx，这个参数我们填的是NX，意思是SET IF NOT EXIST，即当key不存在时，我们进行set操作；若key已经存在，则不做任何操作.</p>
<pre><code>  /**
 * 尝试获取分布式锁
 * @param jedis Redis客户端
 * @param lockKey 锁
 * @param requestId 请求标识
 * @param expireTime 超期时间
 * @return 是否获取成功
 */
public static boolean tryGetDistributedLock(Jedis jedis, String lockKey, String requestId, int expireTime) {

    String result = jedis.set(lockKey, requestId, SET_IF_NOT_EXIST, SET_WITH_EXPIRE_TIME, expireTime);

    if (LOCK_SUCCESS.equals(result)) {
        return true;
    }
    return false;

}
</code></pre><p>　　释放锁。先判断value是否一致，看看自己是不是自己加的锁，让自己释放自己的锁。判断和删除要保证原子性，因此要使用lua脚本保证其原子性。</p>
<pre><code> /**
 * 释放分布式锁
 * @param jedis Redis客户端
 * @param lockKey 锁
 * @param requestId 请求标识
 * @return 是否释放成功
 */
public static boolean releaseDistributedLock(Jedis jedis, String lockKey, String requestId) {

    String script = &quot;if redis.call(&apos;get&apos;, KEYS[1]) == ARGV[1] then return redis.call(&apos;del&apos;, KEYS[1]) else return 0 end&quot;;
    Object result = jedis.eval(script, Collections.singletonList(lockKey), Collections.singletonList(requestId));

    if (RELEASE_SUCCESS.equals(result)) {
        return true;
    }
    return false;

}
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://skydh.github.io/2018/07/11/队列和栈/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="董航">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="why are you so happy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/11/队列和栈/" itemprop="url">栈和队列</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-11T14:31:47+08:00">
                2018-07-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>　　手动实现基于java栈和队列。<br>　　栈：</p>
<pre><code>package base_struct.hashmap;
public class DhStack &lt;K&gt;{
private class Data&lt;K&gt;{
    public K k;
    public Data(K k){
        this.k=k;
    }
}
private int size;
private int offet;
private Data&lt;K&gt;[] data;

public DhStack(int a)
{
    data=new Data[a];
    size=a;
    offet=0;    
}
public synchronized void put(K k)
{
    Data&lt;K&gt; temp=new Data&lt;K&gt;(k);
    data[offet]=temp;
    offet++;    
}
public synchronized K get()
{
    offet=offet-1;
    if(offet&lt;0)
    {
        return null;
    }
    K a=data[offet].k;

    return  data[offet].k;
}
}
</code></pre><p>　　对列：</p>
<pre><code>public class DhQueue&lt;K&gt; {
private class Data&lt;K&gt;{
    public K k;
    public Data&lt;K&gt; next;
    public Data(K k){
        this.k=k;
    }
}    
/*
 * 限制队列大小的参数
 */
private int size;
private int offet;
private Data&lt;K&gt; dataLinkedList;
public DhQueue(int a)
{

    size=a;


}
public synchronized void put(K k)
{
    if(offet&gt;=size-1)
    {
        throw new IllegalArgumentException();
    }
    Data&lt;K&gt; data=new Data&lt;K&gt;(k);


    Data&lt;K&gt; temp=dataLinkedList;
    if(dataLinkedList==null)
    {
        dataLinkedList=data;
    }else{
        while (temp.next != null) {

            temp = temp.next;
        }
        temp.next=data;
    }
    offet++;


}
public synchronized K get()
{
    if(offet&lt;=0)
    {
        return null;
    }
    K a=dataLinkedList.k;
    dataLinkedList=dataLinkedList.next;
    offet=offet-1;
    return a;    
}
}
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://skydh.github.io/2018/07/10/currentHashMap/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="董航">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="why are you so happy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/10/currentHashMap/" itemprop="url">concurrenthashmap</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-10T15:49:34+08:00">
                2018-07-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>　　１.7的ConcurrentHashMap最重要的一点就是Segment这个概念，每一个Segment就是一个小的HashMap，可以将这个理解为2级哈希表，一个总的Segment数组，每个数组里面存放一个类似Hashmap的结构，而加锁则是对Segment进行加锁。<br>   Segment继承自ReentrantLock，所以我们可以很方便的对每一个Segment上锁<br>　　1.8的则抛弃其冗余的设计，采用Node + CAS + Synchronized来保证并发安全进行实现，分析下其如何实现的吧。<br>　　点到ConcurrentHashMap的put方法里面，分析下源码：</p>
<pre><code>if (tab == null || (n = tab.length) == 0)
            tab = initTable();
</code></pre><p>　　当数组为空时，初始化数组。</p>
<pre><code>private final Node&lt;K,V&gt;[] initTable() {
    Node&lt;K,V&gt;[] tab; int sc;
    while ((tab = table) == null || tab.length == 0) {
        if ((sc = sizeCtl) &lt; 0)
            Thread.yield(); // lost initialization race; just spin
        else if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) {
            try {
                if ((tab = table) == null || tab.length == 0) {
                    int n = (sc &gt; 0) ? sc : DEFAULT_CAPACITY;
                    @SuppressWarnings(&quot;unchecked&quot;)
                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n];
                    table = tab = nt;
                    sc = n - (n &gt;&gt;&gt; 2);
                }
            } finally {
                sizeCtl = sc;
            }
            break;
        }
    }
    return tab;
}
</code></pre><p>　　初始化部分全部使用了CAS来完成线程安全。</p>
<pre><code>else if ((f = tabAt(tab, i = (n - 1) &amp; hash)) == null) {
           if (casTabAt(tab, i, null,
                        new Node&lt;K,V&gt;(hash, key, value, null)))
               break;                   // no lock when adding to empty bin
       }
</code></pre><p>　　如果相应位置的Node还未初始化，则通过CAS插入相应的数据<br>　　然后判断其数组不为空，那么就对这个节点加锁，然后插入数据</p>
<pre><code>synchronized (f) {
               if (tabAt(tab, i) == f) {
                   if (fh &gt;= 0) {
                       binCount = 1;
                       for (Node&lt;K,V&gt; e = f;; ++binCount) {
                           K ek;
                           if (e.hash == hash &amp;&amp;
                               ((ek = e.key) == key ||
                                (ek != null &amp;&amp; key.equals(ek)))) {
                               oldVal = e.val;
                               if (!onlyIfAbsent)
                                   e.val = value;
                               break;
                           }
                           Node&lt;K,V&gt; pred = e;
                           if ((e = e.next) == null) {
                               pred.next = new Node&lt;K,V&gt;(hash, key,
                                                         value, null);
                               break;
                           }
                       }
                   }
                   else if (f instanceof TreeBin) {
                       Node&lt;K,V&gt; p;
                       binCount = 2;
                       if ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,
                                                      value)) != null) {
                           oldVal = p.val;
                           if (!onlyIfAbsent)
                               p.val = value;
                       }
                   }
               }
           }
</code></pre><p>　　判断，链表就用链表的方式添加，红黑树就用红黑树的方式添加。</p>
<pre><code>if (binCount != 0) {
               if (binCount &gt;= TREEIFY_THRESHOLD)
                   treeifyBin(tab, i);
               if (oldVal != null)
                   return oldVal;
               break;
           }
</code></pre><p>如果大于了一个阈值，就将链表转换为数组。<br>嗯就这样，也就是说，1.8的HashMap和ConcurrentHashMap都是大致一样的数据结构，只是其中是否加锁。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/4/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><a class="extend next" rel="next" href="/page/6/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">董航</p>
              <p class="site-description motion-element" itemprop="description">clear 航</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">107</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            

          </nav>

          

          <div class="links-of-author motion-element">
            
          </div>

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">董航</span>

  
</div>


<div class="powered-by">
<i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv">
  本站访客数:<span id="busuanzi_value_site_uv"></span>
</span>
</div>

  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.3</div>




        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.3"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
