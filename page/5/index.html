<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="clear 航">
<meta property="og:type" content="website">
<meta property="og:title" content="why are you so happy">
<meta property="og:url" content="https://skydh.github.io/page/5/index.html">
<meta property="og:site_name" content="why are you so happy">
<meta property="og:description" content="clear 航">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="why are you so happy">
<meta name="twitter:description" content="clear 航">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://skydh.github.io/page/5/"/>





  <title>why are you so happy</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">why are you so happy</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">clear 航</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://skydh.github.io/2018/09/03/redis分布式锁/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="董航">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="why are you so happy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/03/redis分布式锁/" itemprop="url">redis分布式锁</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-03T17:47:45+08:00">
                2018-09-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="什么是分布式锁"><a href="#什么是分布式锁" class="headerlink" title="什么是分布式锁"></a>什么是分布式锁</h2><p>　　一个重要资源被多个jvm进程竞争，会发生数据安全问题，对于分布式系统来说，多个微服务同时竞争一个资源时，就会产生如上问题。对于该问题，我们的方案是用分布式锁来锁住该数据。</p>
<h2 id="使用redis来分布式锁。"><a href="#使用redis来分布式锁。" class="headerlink" title="使用redis来分布式锁。"></a>使用redis来分布式锁。</h2><p>　　分布式锁的本质是在redis里面占一个坑，当别的进程也要占时，却占不了了，只能等待，或者放弃。<br>　　命令如下setnx(set if not exists)只允许一个客户端占坑，然后del 则是删除这个锁。</p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>　　１．由于种种原因，比如程序执行到中间出了bug,导致这个del指令没有被调用，这样就会陷入死锁。<br>　　２．于是我们队这个setnx加了过期时间限制，比如setnx lock true; expire lock 5,使得过5秒自动过期。然后再删除。但是存在问题，当setnx和expire之间服务器突然挂掉了，会导致expire得不到执行，从而继续死锁。如果用redis事务来处理也不行，因为当setnx没有抢到锁时，expire是不该被执行的。而这个redis事务里面没有ifelse判断语句。后续redis2.8版本该作者加入了set指令的扩展参数，是的setnx和expire可以一起执行形成一个原子操作。彻底解决了这个问题。<br>　　３．存在超时问题：当一个进程获取到锁后，由于逻辑执行部分太长，以至于超出了锁的超时限制，那就出现了问题，因为第二个进程获取到了这个锁，接着第一个线程执行了业务逻辑，于是就释放了这个锁，那么第三个进程就会获取到这个锁。为了避免这个问题，redis分布式锁，一般不用于较长时间的任务，如果真的出现了，那会很麻烦。为了避免第一个进程删除第二个进程锁的问题。我们可以在加锁前，设置一个随机数，释放锁的时候就进行判断是否需要删除这个锁。这样就保证了自己删自己的锁。但是匹配value和删除可以不是一个原子操作，这就需要lua脚本处理了，因为lua脚本可以保证多个命令是原子操作的。可以将匹配和删除放在一起。<br>　　４．主从集群问题，当主节点挂掉了，从节点变成了主节点，但是从节点没有锁，其他进程就会请求加锁成功。为了解决这个问题，有些开源的library对其做了良好的封装。用户可以拿来就用。比如redlock-py,加锁时，它会向过半节点发送加锁命令，释放锁的时候，则是删除所有节点信息</p>
<h2 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h2><p>　　获取锁。要让其加锁和释放锁的是同一个线程，因此给这个key加了valu.第三个为nxxx，这个参数我们填的是NX，意思是SET IF NOT EXIST，即当key不存在时，我们进行set操作；若key已经存在，则不做任何操作.</p>
<pre><code>  /**
 * 尝试获取分布式锁
 * @param jedis Redis客户端
 * @param lockKey 锁
 * @param requestId 请求标识
 * @param expireTime 超期时间
 * @return 是否获取成功
 */
public static boolean tryGetDistributedLock(Jedis jedis, String lockKey, String requestId, int expireTime) {

    String result = jedis.set(lockKey, requestId, SET_IF_NOT_EXIST, SET_WITH_EXPIRE_TIME, expireTime);

    if (LOCK_SUCCESS.equals(result)) {
        return true;
    }
    return false;

}
</code></pre><p>　　释放锁。先判断value是否一致，看看自己是不是自己加的锁，让自己释放自己的锁。判断和删除要保证原子性，因此要使用lua脚本保证其原子性。</p>
<pre><code> /**
 * 释放分布式锁
 * @param jedis Redis客户端
 * @param lockKey 锁
 * @param requestId 请求标识
 * @return 是否释放成功
 */
public static boolean releaseDistributedLock(Jedis jedis, String lockKey, String requestId) {

    String script = &quot;if redis.call(&apos;get&apos;, KEYS[1]) == ARGV[1] then return redis.call(&apos;del&apos;, KEYS[1]) else return 0 end&quot;;
    Object result = jedis.eval(script, Collections.singletonList(lockKey), Collections.singletonList(requestId));

    if (RELEASE_SUCCESS.equals(result)) {
        return true;
    }
    return false;

}
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://skydh.github.io/2018/07/11/队列和栈/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="董航">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="why are you so happy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/11/队列和栈/" itemprop="url">栈和队列</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-11T14:31:47+08:00">
                2018-07-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>　　手动实现基于java栈和队列。<br>　　栈：</p>
<pre><code>package base_struct.hashmap;
public class DhStack &lt;K&gt;{
private class Data&lt;K&gt;{
    public K k;
    public Data(K k){
        this.k=k;
    }
}
private int size;
private int offet;
private Data&lt;K&gt;[] data;

public DhStack(int a)
{
    data=new Data[a];
    size=a;
    offet=0;    
}
public synchronized void put(K k)
{
    Data&lt;K&gt; temp=new Data&lt;K&gt;(k);
    data[offet]=temp;
    offet++;    
}
public synchronized K get()
{
    offet=offet-1;
    if(offet&lt;0)
    {
        return null;
    }
    K a=data[offet].k;

    return  data[offet].k;
}
}
</code></pre><p>　　对列：</p>
<pre><code>public class DhQueue&lt;K&gt; {
private class Data&lt;K&gt;{
    public K k;
    public Data&lt;K&gt; next;
    public Data(K k){
        this.k=k;
    }
}    
/*
 * 限制队列大小的参数
 */
private int size;
private int offet;
private Data&lt;K&gt; dataLinkedList;
public DhQueue(int a)
{

    size=a;


}
public synchronized void put(K k)
{
    if(offet&gt;=size-1)
    {
        throw new IllegalArgumentException();
    }
    Data&lt;K&gt; data=new Data&lt;K&gt;(k);


    Data&lt;K&gt; temp=dataLinkedList;
    if(dataLinkedList==null)
    {
        dataLinkedList=data;
    }else{
        while (temp.next != null) {

            temp = temp.next;
        }
        temp.next=data;
    }
    offet++;


}
public synchronized K get()
{
    if(offet&lt;=0)
    {
        return null;
    }
    K a=dataLinkedList.k;
    dataLinkedList=dataLinkedList.next;
    offet=offet-1;
    return a;    
}
}
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://skydh.github.io/2018/07/10/currentHashMap/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="董航">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="why are you so happy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/10/currentHashMap/" itemprop="url">concurrenthashmap</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-10T15:49:34+08:00">
                2018-07-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>　　１.7的ConcurrentHashMap最重要的一点就是Segment这个概念，每一个Segment就是一个小的HashMap，可以将这个理解为2级哈希表，一个总的Segment数组，每个数组里面存放一个类似Hashmap的结构，而加锁则是对Segment进行加锁。<br>   Segment继承自ReentrantLock，所以我们可以很方便的对每一个Segment上锁<br>　　1.8的则抛弃其冗余的设计，采用Node + CAS + Synchronized来保证并发安全进行实现，分析下其如何实现的吧。<br>　　点到ConcurrentHashMap的put方法里面，分析下源码：</p>
<pre><code>if (tab == null || (n = tab.length) == 0)
            tab = initTable();
</code></pre><p>　　当数组为空时，初始化数组。</p>
<pre><code>private final Node&lt;K,V&gt;[] initTable() {
    Node&lt;K,V&gt;[] tab; int sc;
    while ((tab = table) == null || tab.length == 0) {
        if ((sc = sizeCtl) &lt; 0)
            Thread.yield(); // lost initialization race; just spin
        else if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) {
            try {
                if ((tab = table) == null || tab.length == 0) {
                    int n = (sc &gt; 0) ? sc : DEFAULT_CAPACITY;
                    @SuppressWarnings(&quot;unchecked&quot;)
                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n];
                    table = tab = nt;
                    sc = n - (n &gt;&gt;&gt; 2);
                }
            } finally {
                sizeCtl = sc;
            }
            break;
        }
    }
    return tab;
}
</code></pre><p>　　初始化部分全部使用了CAS来完成线程安全。</p>
<pre><code>else if ((f = tabAt(tab, i = (n - 1) &amp; hash)) == null) {
           if (casTabAt(tab, i, null,
                        new Node&lt;K,V&gt;(hash, key, value, null)))
               break;                   // no lock when adding to empty bin
       }
</code></pre><p>　　如果相应位置的Node还未初始化，则通过CAS插入相应的数据<br>　　然后判断其数组不为空，那么就对这个节点加锁，然后插入数据</p>
<pre><code>synchronized (f) {
               if (tabAt(tab, i) == f) {
                   if (fh &gt;= 0) {
                       binCount = 1;
                       for (Node&lt;K,V&gt; e = f;; ++binCount) {
                           K ek;
                           if (e.hash == hash &amp;&amp;
                               ((ek = e.key) == key ||
                                (ek != null &amp;&amp; key.equals(ek)))) {
                               oldVal = e.val;
                               if (!onlyIfAbsent)
                                   e.val = value;
                               break;
                           }
                           Node&lt;K,V&gt; pred = e;
                           if ((e = e.next) == null) {
                               pred.next = new Node&lt;K,V&gt;(hash, key,
                                                         value, null);
                               break;
                           }
                       }
                   }
                   else if (f instanceof TreeBin) {
                       Node&lt;K,V&gt; p;
                       binCount = 2;
                       if ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,
                                                      value)) != null) {
                           oldVal = p.val;
                           if (!onlyIfAbsent)
                               p.val = value;
                       }
                   }
               }
           }
</code></pre><p>　　判断，链表就用链表的方式添加，红黑树就用红黑树的方式添加。</p>
<pre><code>if (binCount != 0) {
               if (binCount &gt;= TREEIFY_THRESHOLD)
                   treeifyBin(tab, i);
               if (oldVal != null)
                   return oldVal;
               break;
           }
</code></pre><p>如果大于了一个阈值，就将链表转换为数组。<br>嗯就这样，也就是说，1.8的HashMap和ConcurrentHashMap都是大致一样的数据结构，只是其中是否加锁。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://skydh.github.io/2018/07/10/hashmap/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="董航">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="why are you so happy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/10/hashmap/" itemprop="url">hashmap</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-10T10:44:58+08:00">
                2018-07-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h2><p>　　HashMap可以接受null键值和值，而Hashtable则不能；HashMap是非synchronized;HashMap很快；以及HashMap储存的是键值对。</p>
<h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><p>　　１．当两个对象的hashcode相同会发生什么？<br>　　因为hashcode相同，所以它们的bucket位置相同，‘碰撞’会发生。因为HashMap使用链表存储对象，这个Entry(包含有键值对的Map.Entry对象)会存储在链表中。<br>　　２．如果两个键的hashcode相同，你如何获取值对象？<br>　　找到bucket位置之后，会调用keys.equals()方法去找到链表中正确的节点，最终找到要找的值对象。<br>　　３．如果HashMap的大小超过了负载因子(load factor)定义的容量，怎么办？<br>　　默认的负载因子大小为0.75，也就是说，当一个map填满了75%的bucket时候，和其它集合类(如ArrayList等)一样，将会创建原来HashMap大小的两倍的bucket数组，来重新调整map的大小，并将原来的对象放入新的bucket数组中。这个过程叫作rehashing，因为它调用hash方法找到新的bucket位置。<br>　　４．为什么String, Interger这样的wrapper类适合作为键？<br>　　Ｓtring, Interger这样的wrapper类作为HashMap的键是再适合不过了，而且String最为常用。因为String是不可变的，也是final的，而且已经重写了equals()和hashCode()方法了。其他的wrapper类也有这个特点。不可变性是必要的，因为为了要计算hashCode()，就要防止键值改变，如果键值在放入时和获取时返回不同的hashcode的话，那么就不能从HashMap中找到你想要的对象。不可变性还有其他的优点如线程安全。如果你可以仅仅通过将某个field声明成final就能保证hashCode是不变的，那么请这么做吧。因为获取对象的时候要用到equals()和hashCode()方法，那么键对象正确的重写这两个方法是非常重要的。如果两个不相等的对象返回不同的hashcode的话，那么碰撞的几率就会小些，这样就能提高HashMap的性能。</p>
<h2 id="简单实现一个hashmap"><a href="#简单实现一个hashmap" class="headerlink" title="简单实现一个hashmap"></a>简单实现一个hashmap</h2><pre><code>package base_struct.hashmap;

/**
     * 基于链表数组的实现
     * @author dh
     * @param &lt;V&gt;
     * @param &lt;K&gt;
     *
*/
public class DhHashMap&lt;K, V&gt; {
private class Entry&lt;K,V&gt;{
    int hash;
    K key;
    V value;
    Entry&lt;K,V&gt; next;
    Entry(int hash, K key, V value, Entry&lt;K, V&gt; next) {
        this.hash = hash;
        this.key = key;
        this.value = value;
        this.next = next;
    }
}
private static final int DEFAULT_CAPACITY = 1 &lt;&lt; 4;

private Entry&lt;K, V&gt;[] table;

private int capacity;

private int size;
public DhHashMap(int capacity) {
    if (capacity &lt; 0) {
        throw new IllegalArgumentException();
    } else {
        table = new Entry[capacity];
        size = 0;
        this.capacity = capacity;
    }
}
public int size() {
    return size;
}
public boolean isEmpty() {
    return size == 0 ? true : false;}

/**
 * 这个hash算法采用位运算提高了效率,由于采用位运算，因此默认长度最好是2的幂最好
 * @param key
 * @return
 */
private int hash(Object key) {
    return (key == null) ? 0 : key.hashCode()&amp;(capacity-1);
}

/**
 * 按照以前邏輯，默认key一样则只修改value,
 * @param key
 * @param value
 */
public void put(K key, V value) {
    if (key == null) {
        throw new IllegalArgumentException();
    }
    int hash = hash(key);
    Entry&lt;K, V&gt; nEntry = new Entry&lt;K, V&gt;(hash, key, value, null);
    Entry&lt;K, V&gt; entry = table[hash];
    while (entry != null) {
        if (entry.key.equals(key)) {
            entry.value = value;
            return;
        }
        entry = entry.next;
    }
    nEntry.next = table[hash];
    table[hash] = nEntry;
    size++;
}
/**
 * h很简单的逻辑，找到确认的hash值后，一个个遍历
 * @param key
 * @return
 */
public V get(K key) {
    if (key == null) {
        throw new IllegalArgumentException();
    }
    int hash = hash(key);
    Entry&lt;K, V&gt; entry = table[hash];
    while (entry != null) {
        if (entry.key.equals(key)) {
            return entry.value;
        }
        entry = entry.next;
    }
    return null;
}
}
</code></pre><h2 id="gt-gt-gt-操作符"><a href="#gt-gt-gt-操作符" class="headerlink" title="&gt;&gt;&gt;操作符"></a>&gt;&gt;&gt;操作符</h2><p>　这个操作符的作用是将当前整数，转换为２进制后，右移。比如<br>２&gt;&gt;&gt;1,就是10右移1位剩下了一个1，就是1。<br>　　案例如下：<br>    public static void main(String [] args)<br>    {<br>        System.out.println(4&gt;&gt;&gt; 1);<br>    }<br>　　结果是２．<br>    public static void main(String [] args)<br>    {<br>        System.out.println(4&gt;&gt;&gt; 2);<br>    }<br>　　结果是１</p>
<h2 id="1-8增加了对其优化。"><a href="#1-8增加了对其优化。" class="headerlink" title="1.8增加了对其优化。"></a>1.8增加了对其优化。</h2><p>　　其原因是hash的的平均分布可能有问题，有可能导致链表过长，从而使得效率变的很低。因此加了一个新的结构红黑树，如果说1.8之前的hashMap是数组+链表，那么现在版本的就是数组+链表+红黑树。当链表长度<8时，默认以前的方式加元素，也就是数组+链表，当链表>8时则将链表转换为红黑树。（红黑树是一个自平衡的二叉查找树，其插入删除时为了保持红黑树的平衡特征，回自旋来保证，可以将其理解为一个具有自平衡的查找2叉树）</8时，默认以前的方式加元素，也就是数组+链表，当链表></p>
<h2 id="hashmap线程不安全"><a href="#hashmap线程不安全" class="headerlink" title="hashmap线程不安全"></a>hashmap线程不安全</h2><p>　　hashmap没有做加锁处理，举个简单例子，2个线程插入一个数据，其hashcode都是一样的，在极端情况下，可能导致插入少了一个数据。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://skydh.github.io/2018/07/09/CountDownLatch/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="董航">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="why are you so happy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/09/CountDownLatch/" itemprop="url">CountDownLatch 用法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-09T15:13:26+08:00">
                2018-07-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <pre><code>package test;
import java.util.concurrent.CountDownLatch;
public class Test {
 public static void main(String[] args) {   
     final CountDownLatch latch = new CountDownLatch(2)；
     new Thread(){
         public void run() {
             try {
                 System.out.println(&quot;子线程&quot;+Thread.currentThread().getName()+&quot;正在执行&quot;);
                Thread.sleep(3000);
                System.out.println(&quot;子线程&quot;+Thread.currentThread().getName()+&quot;执行完毕&quot;);
                latch.countDown();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
         };
     }.start();

     new Thread(){
         public void run() {
             try {
                 System.out.println(&quot;子线程&quot;+Thread.currentThread().getName()+&quot;正在执行&quot;);
                 Thread.sleep(3000);
                 System.out.println(&quot;子线程&quot;+Thread.currentThread().getName()+&quot;执行完毕&quot;);
                 latch.countDown();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
         };
     }.start();

     try {
         System.out.println(&quot;等待2个子线程执行完毕...&quot;);
        latch.await();
        System.out.println(&quot;2个子线程已经执行完毕&quot;);
        System.out.println(&quot;继续执行主线程&quot;);
            } catch (InterruptedException e) {
        e.printStackTrace();
        }
     }
}
</code></pre><p>　　对于这个类来说，这就是个计数器，设置了一个值，这个值不为０则调用其await()方法时，其线程将持续等待。这个功能的作用就是在一个方法里面可以异步的启动一个线程让异步从而加快运行。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://skydh.github.io/2018/07/02/spring mvc流程分析 /">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="董航">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="why are you so happy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/02/spring mvc流程分析 /" itemprop="url">spring mvc 流程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-02T10:21:42+08:00">
                2018-07-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="什么是spring-mvc"><a href="#什么是spring-mvc" class="headerlink" title="什么是spring mvc"></a>什么是spring mvc</h2><p>　　Spring MVC本质上还是一个Servlet,他封装了一套通用的方案，使得我们开发时只需要写核心的业务逻辑，不需要写Servlet。而Servlet也是对底层Socket的封装，使得我们开发变得简单。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://skydh.github.io/2018/06/25/es入门/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="董航">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="why are you so happy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/25/es入门/" itemprop="url">Elasticsearch入门</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-25T09:31:00+08:00">
                2018-06-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Elasticsearch-和-solr"><a href="#Elasticsearch-和-solr" class="headerlink" title="Elasticsearch 和 solr"></a>Elasticsearch 和 solr</h2><p>　　Elasticsearch更加精简，大多高级功能是依靠插件完成的。而solr很全面，包含了大部分的高级功能，可以从下载大小就可以看出来。<br>　　２者都是基于Lucene这个基于java的搜索类库。<br>　　根据文档（未测试）Elasticsearch的实时搜索效率明显高于solr。<br>　　由于小且精简，因此入门简单。</p>
<h2 id="Elasticsearch-安装"><a href="#Elasticsearch-安装" class="headerlink" title="Elasticsearch 安装"></a>Elasticsearch 安装</h2><p>　　本次安装基于Windows10。<br>　　官网下载：<a href="https://www.elastic.co/downloads/elasticsearch" target="_blank" rel="noopener">https://www.elastic.co/downloads/elasticsearch</a>。<br>　　下载的zip包，下载解压，然后运行bin\elasticsearch.bat这个Windows批处理文件。<br>　　然后打开浏览器输入　<a href="http://localhost:9200/" target="_blank" rel="noopener">http://localhost:9200/</a>。看看是否返回了有效信息。<br>　　安装node.js，grunt(网上搜索)。<br>　　下载head插件。<a href="https://github.com/mobz/elasticsearch-head" target="_blank" rel="noopener">https://github.com/mobz/elasticsearch-head</a><br>　　修改Elasticsearch的配置文件config/elasticsearch.yml<br>　　修改一下ES的监听地址，这样别的机器也可以访问<br>　　network.host: 0.0.0.0<br>　　增加新的参数，这样head插件可以访问es<br>　　http.cors.enabled: true<br>　　http.cors.allow-origin: “*”<br>　　然后在下载的head插件的解压文件夹的根路径下，运行，npm install 安装其所依赖的各种插件。<br>　　最后启动　grunt server。访问<a href="http://localhost:9100/" target="_blank" rel="noopener">http://localhost:9100/</a><br>　　安装完毕。</p>
<h2 id="面向文档（Nosql）"><a href="#面向文档（Nosql）" class="headerlink" title="面向文档（Nosql）"></a>面向文档（Nosql）</h2><p>　　Elasticsearch 是 面向文档 的，意味着它是以文档来进行存储数据的。Elasticsearch 不仅存储文档，而且能索引每个文档的内容使之可以被检索。在 Elasticsearch 中，你是对文档进行索引、检索、排序和过滤–而不是对行列数据（关系数据库）。这是一种完全不同的思考数据的方式，也是 Elasticsearch 能支持复杂全文检索的原因。</p>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>　　在Elasticsearch里面，索引有很多个意思。<br>　　１．名词：一个索引就是类似于关系数据库的一个数据库，是一个存储关系型文档的地方。<br>　　２．动词：索引一个文档就是存储一个文档到索引（名词）中以便于它可以被检索和查询到，类似于关系数据库的insert关键字。<br>　　３．倒排索引：如果说关系数据库的索引的数据结构是B+树，那么Elasticsearch采用了一个叫倒排索引的结构达到相同的目的。</p>
<h2 id="创建和基本查询"><a href="#创建和基本查询" class="headerlink" title="创建和基本查询"></a>创建和基本查询</h2><p>　　打开Elasticsearch的head插件，然后连接Elasticsearch。在复合查询中，输入url <a href="http://localhost:9200/megacorp/employee/3/,提交方式选择put,内容：{}(json)。即可创建一个索引文档。其中" target="_blank" rel="noopener">http://localhost:9200/megacorp/employee/3/,提交方式选择put,内容：{}(json)。即可创建一个索引文档。其中</a> <a href="http://localhost:9200" target="_blank" rel="noopener">http://localhost:9200</a> 是Elasticsearch的地址。而megacorp上上面提到的名词索引。employee是类型。3为该数据的特定id。<br>　　插入成功后，可以GET /megacorp/employee/３　查询出你插入的数据。<br>　　往里面多插入几条数据，以便于学习测试。<br>　　 /megacorp/employee/_search　这个就是查出这个索引这个类型的所有数据。<br>　　在head这个插件的复合查询里面，有2个行，第一行就是输入上面的url,下面的行，加入查询参数：?q=last_name:Smith<br>　　后面有更加复杂的ELS查询：<br>　　<a href="http://localhost:9200/" target="_blank" rel="noopener">http://localhost:9200/</a><br>　　megacorp/employee/_search/<br>　　post<br>　　{<br>    “query” : {<br>        “bool”: {<br>            “must”: {<br>                “match” : {<br>                    “last_name” : “smith”<br>                }<br>            },<br>            “filter”: {<br>                “range” : {<br>                    “age” : { “gt” : 30 }<br>                }<br>            }<br>        }<br>    }<br>}<br>　　也可以用上面的方式(match)实现全文检索。结果会按照匹配度按顺序排下来。但是想要不全文检索，具体查询，那么就用这个（match_phrase）</p>
<h2 id="文档的更新"><a href="#文档的更新" class="headerlink" title="文档的更新"></a>文档的更新</h2><p>  在 Elasticsearch 中文档是 不可改变 的，不能修改它们。 相反，如果想要更新现有的文档，需要 重建索引 或者进行替换，在内部，Elasticsearch 已将旧文档标记为已删除，并增加一个全新的文档。 尽管你不能再对旧版本的文档进行访问，但它并不会立即消失。当继续索引更多的数据，Elasticsearch 会在后台清理这些已删除文档。删除逻辑也是。这点和mysql的删除很类似，都是逻辑删除！但是意义不一样~~~</p>
<h2 id="冲突处理"><a href="#冲突处理" class="headerlink" title="冲突处理"></a>冲突处理</h2><p>　　当多个端同时处理一个文档的值的时候，可能出现值丢失的情况。因此我们需要加锁，就像对mysql的处理一样。有2个方式，第一个就是悲观加锁，要获取这个数据，那么你要先获得锁，但是效率存在问题，第二个就是用乐观锁，类似java原子类的CAS的思想，我假设你没有变化。有变化，我就重新获取值进行处理，而我们的文档存在一个叫version的字段，可以用来判断。我们可以通过api来指定version来确认。</p>
<pre><code>PUT /website/blog/1?version=1 
{
  &quot;title&quot;: &quot;My first blog entry&quot;,
  &quot;text&quot;:  &quot;Starting to get the hang of this...&quot;
}
</code></pre><p>　　当然大部分情况下，我们使用mysql作为主要的数据存储，而Elasticsearch主要作为检索用的，如果多个进程进行数据同步，就会出现那个问题。我们在数据库里面就有了版本号，那么我们也可以用这个版本号作为判断条件，是否更新。</p>
<h2 id="请求合并"><a href="#请求合并" class="headerlink" title="请求合并"></a>请求合并</h2><p>　　es可以将多个请求合并成一个，避免单独处理每个请求花费的网络延时和开销。 如果你需要从 Elasticsearch 检索很多文档，那么使用 multi-get 或者 mget API 来将这些检索请求放在一个请求中，将比逐个文档请求更快地检索到全部文档。</p>
<pre><code>_mget
{
       &quot;docs&quot; : [
  {
     &quot;_index&quot; : &quot;website&quot;,
     &quot;_type&quot; :  &quot;blog&quot;,
     &quot;_id&quot; :    2
  },
  {
     &quot;_index&quot; : &quot;website&quot;,
     &quot;_type&quot; :  &quot;pageviews&quot;,
     &quot;_id&quot; :    1,
     &quot;_source&quot;: &quot;views&quot;
  }
       ]
}
</code></pre><h2 id="分布式存储"><a href="#分布式存储" class="headerlink" title="分布式存储"></a>分布式存储</h2><p>　　我们知道我们一个索引对应多个分片，每个分片又有多个副本，那么我们索引一个文档时，文档会被存储到主分片里面，但是应该存到具体哪个分片里面呢？是有个hash算法，根据id计算出一个值，然后对分片数取模，即可。</p>
<p>　　以下是在主副分片和任何副本分片上面 成功新建，索引和删除文档所需要的步骤顺序：<br>　　１．客户端向 Node 1 发送新建、索引或者删除请求。<br>　　２．节点使用文档的 _id 确定文档属于分片 0 。请求会被转发到 Node 3<code>，因为分片 0 的主分片目前被分配在</code>Node 3 上。<br>　　３．Node 3 在主分片上面执行请求。如果成功了，它将请求并行转发到 Node 1 和 Node 2 的副本分片上。一旦所有的副本分片都报告成功, Node 3 将向协调节点报告成功，协调节点向客户端报告成功。</p>
<p>　　以下是从主分片或者副本分片检索文档的步骤顺序：</p>
<p>　　1、客户端向 Node 1 发送获取请求。</p>
<p>　　2、节点使用文档的 _id 来确定文档属于分片 0 。分片 0 的副本分片存在于所有的三个节点上。 在这种情况下，它将请求转发到 Node2 。</p>
<p>　　3、Node 2 将文档返回给 Node 1 ，然后将文档返回给客户端。</p>
<p>　　在处理读取请求时，协调结点在每次请求的时候都会通过轮询所有的副本分片来达到负载均衡。</p>
<p>　　在文档被检索时，已经被索引的文档可能已经存在于主分片上但是还没有复制到副本分片。 在这种情况下，副本分片可能会报告文档不存在，但是主分片可能成功返回文档。 一旦索引请求成功返回给用户，文档在主分片和副本分片都是可用的。</p>
<p>　　以下是部分更新一个文档的步骤：</p>
<p>　　１．客户端向 Node 1 发送更新请求。<br>　　２．它将请求转发到主分片所在的 Node 3 。<br>　　３．Node 3 从主分片检索文档，修改 _source 字段中的 JSON ，并且尝试重新索引主分片的文档。 如果文档已经被另一个进程修改，它会重试步骤 3 ，超过 retry_on_conflict 次后放弃。<br>　　４．如果 Node 3 成功地更新文档，它将新版本的文档并行转发到 Node 1 和 Node 2 上的副本分片，重新建立索引。 一旦所有副本分片都返回成功， Node 3 向协调节点也返回成功，协调节点向客户端返回成功。</p>
<h2 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h2><p>　　Elasticsearch可以垂直扩展（购买性能更好的机器），也可以水平扩展（扩展多个节点），一个运行中的Elasticsearch实例就是一个节点，具有多个相同cluster.name配置的节点组成。其共同承担数据和负载的压力。<br>　　集群有个叫集群健康的值，3个状态。<br>　　green：所有主分片和副分片都正常。<br>　　yellow:所有主分片正常，但是副分片有的不正常。<br>　　red:存在主分片不正常。<br>　　我们上面提到的名词索引实际上指向一个或者多个分片。一个分片是底层的工作单元，保存了全部数据的一部分，Elasticsearch利用分片将数据分发到集群各处的，分片是数据的容器，文档保存在分片中。分片分配到集群的各个节点里面。<br>　　一个分片可以是主分片和副本分片，索引内的任何一个文档都是属于主分片的，所以主分片决定了索引能保存的最大数据量。副本分片是主分片的copy，为了保障数据安全的。<br>　　水平扩容后，分片后自动重新分配的。<br>　　一个Elasticsearch实例就是一个节点。一个索引默认五个主分片，五个副分片。<br>　　当你只有一个节点的时候，创建一个索引的集群健康值一定是黄色。因为副本分片都是 unassigned —— 它们都没有被分配到任何节点。 在同一个节点上既保存原始数据又保存副本是没有意义的，因为一旦失去了那个节点，我们也将丢失该节点上的所有副本数据。当你再启动一个名字一样的节点的时候，集群健康值就是绿色了。<br>　　然后我们在启动第三个节点，发现一个索引的１０个分片均匀分配到３个节点里面了。<br>   因此我们发现Elasticsearch的动态扩展能力极强。<br>　　写操作我们只能通过主分片进行，读操作我们可以从主副分片都可以。当我们创建的节点吵过１０个后，我们可以将副本重新设置，来获取更大的并发量。</p>
<h2 id="java-操作-Elasticsearch"><a href="#java-操作-Elasticsearch" class="headerlink" title="java 操作 Elasticsearch"></a>java 操作 Elasticsearch</h2><p>　　代码如下：<br>　　maven依赖：</p>
<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;org.elasticsearch.client&lt;/groupId&gt;
    &lt;artifactId&gt;transport&lt;/artifactId&gt;
    &lt;version&gt;6.3.0&lt;/version&gt;
&lt;/dependency&gt;
</code></pre><p>　　代码：</p>
<pre><code>import java.net.InetAddress;
import org.elasticsearch.action.get.GetResponse;
import org.elasticsearch.client.transport.TransportClient;
import org.elasticsearch.common.settings.Settings;
import org.elasticsearch.common.transport.TransportAddress;
import org.elasticsearch.transport.client.PreBuiltTransportClient;
public class TestEsClient {
    public static void main(String[] args) {
        try {
            Settings settings = Settings.builder().put(&quot;cluster.name&quot;, &quot;elasticsearch&quot;).build();
            // 创建client
            TransportClient client = new PreBuiltTransportClient(settings)
                    .addTransportAddress(new TransportAddress(InetAddress.getByName(&quot;127.0.0.1&quot;), 9300));
            // 搜索数据
            GetResponse response = client.prepareGet(&quot;megacorp&quot;, &quot;employee&quot;, &quot;1&quot;).execute().actionGet();
            // 输出结果
            System.out.println(response.getSourceAsString());
            // 关闭client
            client.close();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
</code></pre><p>　　结果输出：</p>
<pre><code>{&quot;first_name&quot;:&quot;John&quot;,&quot;last_name&quot;:&quot;Smith&quot;,&quot;age&quot;:25,&quot;about&quot;:&quot;I love to go rock climbing&quot;,&quot;interests&quot;:[&quot;sports&quot;,&quot;music&quot;]}
</code></pre><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>　　大致这样，具体要用的时候细看吧。ps:关于java代码操作Elasticsearch，要切记，maven版本和Elasticsearch版本不能差距太大哦，不然是连不上的</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://skydh.github.io/2018/06/19/BigDecimal计算精度问题/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="董航">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="why are you so happy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/19/BigDecimal计算精度问题/" itemprop="url">BigDecimal精度问题</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-19T20:41:46+08:00">
                2018-06-19
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>　　１．商业计算使用BigDecimal。<br>　　２．使用参数为String的构造函数。<br>　　３．BigDecimal都是不可变的，每一步的运算时，都会产生一个新的对象。所以在做加减乘除后千万要保存操作后的值。</p>
<h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p>　　代码１：</p>
<pre><code>public class Test001 {
    public static void main(String args[]) {
        BigDecimal a = new BigDecimal(1.5);
        BigDecimal a1 = new BigDecimal(329.530);
        System.out.println(a.multiply(a1).setScale(2, BigDecimal.ROUND_HALF_UP));
    }
}
</code></pre><p>　　输出：</p>
<pre><code>494.29
</code></pre><p>　　代码２：</p>
<pre><code>public class Test001 {
    public static void main(String args[]) {
        BigDecimal a = new BigDecimal(&quot;1.5&quot;);
    　　BigDecimal a1 = new BigDecimal(&quot;329.530&quot;);
        System.out.println(a.multiply(a1).setScale(2, BigDecimal.ROUND_HALF_UP));
    }
}
</code></pre><p>　　输出：</p>
<pre><code>494.30
</code></pre><p>  计算器输出结果：</p>
<pre><code>489.30
</code></pre><p>　　原因解析：<br>　　JDK的描述：参数为dubbo的构造方法的结果具有一定的不可预知性，认为java在写入new BigDecimal(0.1)中这个0.1不是标准的0.1可能是一个无限趋近于0.1的一个小数，虽然表面上等于他。</p>
<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><pre><code>public BigDecimal multiply(BigDecimal multiplicand) {
    int productScale = checkScale((long) scale + multiplicand.scale);
    if (this.intCompact != INFLATED) {
        if ((multiplicand.intCompact != INFLATED)) {
            return multiply(this.intCompact, multiplicand.intCompact, productScale);
        } else {
            return multiply(this.intCompact, multiplicand.intVal, productScale);
        }
    } else {
        if ((multiplicand.intCompact != INFLATED)) {
            return multiply(multiplicand.intCompact, this.intVal, productScale);
        } else {
            return multiply(this.intVal, multiplicand.intVal, productScale);
        }
    }
}
</code></pre><p>　　在这个地方就是判断是不是字符串的，这个this.intCompact 是获取到参数的整数值，如果获取到时一大串数字，那就是dubbo参数传进来的，这里进行判断，从而获取到不同的值。进入到不同的方法进行运算。其实运算原理大致说下，小数转换为整数计算，最后除以１０的ｎ次方即可。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://skydh.github.io/2018/06/19/ControllerAdvice注解/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="董航">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="why are you so happy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/19/ControllerAdvice注解/" itemprop="url">ControllerAdvice用法解析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-19T20:32:58+08:00">
                2018-06-19
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>　　通过@ControllerAdvice注解可以将对于控制器的全局配置放在同一个位置。<br>　　注解了@Controller的类的方法可以使用@ExceptionHandler、@InitBinder、@ModelAttribute注解到方法上。<br>　　@ControllerAdvice注解将作用在所有注解了@RequestMapping的控制器的方法上<br>　　@ExceptionHandler：用于全局处理控制器里的异常。</p>
<h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><pre><code>@ControllerAdvice
@ResponseBody
public class BusinessExceptionHandler {
    @ExceptionHandler(value = Exception.class)
    public JsonBackData exceptionHandler(HttpServletRequest request, Exception e) {
        e.printStackTrace();
        JsonBackData back = new JsonBackData();
        if (e instanceof BusinessException) {
            BusinessException ex = (BusinessException) e;
            back.setSuccess(false);
            back.setBackMsg(ex.getMessage());
        }
        return back;
    }
</code></pre><p>　　加了这个全局配置的Bean后，以前我的代码是这样的：</p>
<pre><code>@RequestMapping(value = &quot;queryDetail&quot;)
@ResponseBody
public JsonBackData queryDetail(@RequestParam String id) {
    JsonBackData back = new JsonBackData();
    try {
        OpenSourceThrottleAdjustVO vo = openSourceThrottlePlanQueryService.findById(id);
        back.setBackData(vo);
        back.setSuccess(true);
        back.setBackMsg(&quot;查询详细信息成功&quot;);
    } catch (BusinessException e) {
        back.setSuccess(false);
        back.setBackMsg(&quot;查询详细信息失败:&quot; + e.getMessage());
    }
    return back;
}
</code></pre><p> 　多了很多无关信息。几乎每个类都要try catch一下，代码极度冗余。<br>但是加了上面的全局处理控制器的异常处理后。代码就变成了下面的了。</p>
<pre><code>@RequestMapping(value = &quot;queryDetail&quot;)
@ResponseBody
public JsonBackData queryDetail(@RequestParam String id) {
    JsonBackData back = new JsonBackData();
    OpenSourceThrottleAdjustVO vo = openSourceThrottlePlanQueryService.findById(id);
    back.setBackData(vo);
    back.setSuccess(true);
    back.setBackMsg(&quot;查询详细信息成功&quot;);
    return back;
}
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://skydh.github.io/2018/06/12/原因/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="董航">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="why are you so happy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/12/原因/" itemprop="url">原因</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-12T17:24:50+08:00">
                2018-06-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>　　最近帮女朋友做毕设写论文，又要上班，没时间写了。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/4/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><a class="extend next" rel="next" href="/page/6/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">董航</p>
              <p class="site-description motion-element" itemprop="description">clear 航</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">100</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            

          </nav>

          

          <div class="links-of-author motion-element">
            
          </div>

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">董航</span>

  
</div>


<div class="powered-by">
<i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv">
  本站访客数:<span id="busuanzi_value_site_uv"></span>
</span>
</div>

  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.3</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.3"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
