<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="clear 航">
<meta property="og:type" content="website">
<meta property="og:title" content="why are you so happy">
<meta property="og:url" content="https://skydh.github.io/page/6/index.html">
<meta property="og:site_name" content="why are you so happy">
<meta property="og:description" content="clear 航">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="why are you so happy">
<meta name="twitter:description" content="clear 航">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://skydh.github.io/page/6/"/>





  <title>why are you so happy</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">why are you so happy</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">clear 航</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://skydh.github.io/2018/09/10/redis限流/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="董航">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="why are you so happy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/10/redis限流/" itemprop="url">redis之简单限流</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-10T09:31:48+08:00">
                2018-09-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="什么是接口限流"><a href="#什么是接口限流" class="headerlink" title="什么是接口限流"></a>什么是接口限流</h2><p>　　为什么要有接口限流？场景如下：１．接口限流，比如我们对外一个接口，我们要限制一个用户单位时间访问次数？２．系统要限定用户的某个行为在指定的时间A里只能允许发生 N 次。</p>
<h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><p>　　我们用zset来实现这个方案。我们将用户id和事件id生成这个zset的容器id,当发生一次时，我们将当前时间作为score,同时也作为value,放到集合里面。然后删除这个元素加入前限定时间A之外的数据。然后将集合的所有数据设置为过了A时间就过期.然后取出这个集合有多少数据，判断是否超标。</p>
<pre><code>public boolean isActionAllowed(String userId, String     actionKey, int period, int maxCount) {
    String key = String.format(&quot;hist:%s:%s&quot;, userId, actionKey);
    long nowTs = System.currentTimeMillis();
    Pipeline pipe = jedis.pipelined();
    pipe.multi();
    pipe.zadd(key, nowTs, &quot;&quot; + nowTs);
    pipe.zremrangeByScore(key, 0, nowTs - period * 1000);
    Response&lt;Long&gt; count = pipe.zcard(key);
    pipe.expire(key, period + 1);
    pipe.exec();
    pipe.close();
    return count.get() &lt;= maxCount;
</code></pre><p>  }</p>
<h2 id="漏斗限流策略"><a href="#漏斗限流策略" class="headerlink" title="漏斗限流策略"></a>漏斗限流策略</h2><pre><code>public class FunnelRateLimiter {
static class Funnel {
int capacity;//容量
float leakingRate;//漏水速度
int leftQuota;//剩余容量
long leakingTs;//上次漏水时间

public Funnel(int capacity, float leakingRate) {
  this.capacity = capacity;
  this.leakingRate = leakingRate;
  this.leftQuota = capacity;
  this.leakingTs = System.currentTimeMillis();
}

void makeSpace() {
  long nowTs = System.currentTimeMillis();
  long deltaTs = nowTs - leakingTs;
  int deltaQuota = (int) (deltaTs * leakingRate);
  if (deltaQuota &lt; 0) { // 间隔时间太长，整数数字过大溢出
    this.leftQuota = capacity;
    this.leakingTs = nowTs;
    return;
  }
  if (deltaQuota &lt; 1) { // 腾出空间太小，最小单位是1
    return;
  }
  this.leftQuota += deltaQuota;
  this.leakingTs = nowTs;
  if (this.leftQuota &gt; this.capacity) {
    this.leftQuota = this.capacity;
  }
}
boolean watering(int quota) {
  makeSpace();
  if (this.leftQuota &gt;= quota) {
    this.leftQuota -= quota;
    return true;
  }
  return false;
}
}
private Map&lt;String, Funnel&gt; funnels = new HashMap&lt;&gt;();
public boolean isActionAllowed(String userId, String actionKey, int capacity, float leakingRate) {
String key = String.format(&quot;%s:%s&quot;, userId, actionKey);
Funnel funnel = funnels.get(key);
if (funnel == null) {
  funnel = new Funnel(capacity, leakingRate);
  funnels.put(key, funnel);
}
return funnel.watering(1); // 需要1个quota
}
}
</code></pre><p>　　<br>　　Funnel 对象的 make_space 方法是漏斗算法的核心，其在每次灌水前都会被调用以触发漏水，给漏斗腾出空间来。能腾出多少空间取决于过去了多久以及流水的速率。Funnel 对象占据的空间大小不再和行为的频率成正比，它的空间占用是一个常量。<br>　　我们观察 Funnel 对象的几个字段，我们发现可以将 Funnel 对象的内容按字段存储到一个 hash 结构中，灌水的时候将 hash 结构的字段取出来进行逻辑运算后，再将新值回填到 hash 结构中就完成了一次行为频度的检测。</p>
<h2 id="新方案"><a href="#新方案" class="headerlink" title="新方案"></a>新方案</h2><p>　　redis4.0出了一个新的模块。叫redis-cell。该模块也使用了漏斗算法，且提供了限流指令。<br>　　cl.throttle sd:sd 15 30 60<br>　　意思是15的容量，每60秒就丢弃30个元素。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://skydh.github.io/2018/09/06/redis布隆过滤器/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="董航">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="why are you so happy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/06/redis布隆过滤器/" itemprop="url">redis之布隆过滤器</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-06T11:06:22+08:00">
                2018-09-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="由来"><a href="#由来" class="headerlink" title="由来"></a>由来</h2><p>　　情景：当我们使用新闻客户端看新闻时，他会不断推送新的内容，他每次推荐时都要去重，那么问题来了，客户端如何实现推送去重呢？<br>　　当然不会采用记录用户看过的内容，第一数据量大，第二不断exists消耗性能太多。缓存也不行，时间久了数据量太大。<br>　　这个时候布隆过滤器出现了。</p>
<h2 id="什么是布隆过滤器"><a href="#什么是布隆过滤器" class="headerlink" title="什么是布隆过滤器"></a>什么是布隆过滤器</h2><p>　　这是一个不怎么精确地set结构，当你使用它的contains方法判断某个数据是否存在时，他可能误判，布隆过滤器是不精确的。只要参数设置合理，那么其精确度是可控的。其判断一个值存在时，其可能不存在，判断一个值不存在时，那么一定不存在。</p>
<h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p>　　bf.add 添加元素，bf.exists,查询元素是否存在，其用法和set集合差不多，批量命令是bf.madd指令，批量查询则是bf.mexists指令。我们创建的布隆过滤器都是默认的过滤器，在我们第一次add的时候自动创建。，但是为了提供高精确率。我们可以用bf.reserve指令来修改其参数即可。第一个为其名字，第二个为<br>     client.createFilter(“codehole”, 50000, 0.001);第二个参数为预计存放数据量，第三个为误差率。误差率越低，需要空间越大。</p>
<h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>　　底层是一个大型的位数组，和几个无偏的hash函数（无偏就是让hash值分布均匀）。添加值的时候，会用多个hash函数对key进行hash运算，然后对应数组上不同点，再把这些点全部置为1。询问key是否存在时，和add一样，也是用hash算法吧这些位置都计算出来，看看是否都为1，只要有一个为0，那么这个值不存在。当然如果都是1，也不一定都存在，可能是其他计算的点正好都覆盖了。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://skydh.github.io/2018/09/05/HypeLogLog/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="董航">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="why are you so happy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/05/HypeLogLog/" itemprop="url">redis之HyperLogLog</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-05T11:53:10+08:00">
                2018-09-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="由来"><a href="#由来" class="headerlink" title="由来"></a>由来</h2><p>　　PV和UV,统计pv很简单，对每个网页加一个独立的redis计数器即可，这个计数器+当天的日期，每来一个请求，就incrby一次即可。但是UV不一样要求一个用户只能算一次，或许你想到了可以用set,把每一个页面放到set里面，当一个请求来了，就将其sadd进去，也可以通过scard取出这个集合的大小，但是有个问题，那就是访问量很大的时候，这个set集合就会很大。而这个redis提供的HyperLogLog数据结构来解决该问题。该数据结构提供一个不精确去重计数方案。</p>
<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>　　HyperLogLog提供了2个指令pfadd,pfcount 根据字面意思很好理解，一个是增加计数，一个是获取计数，pfadd的用法和set集合的asdd一样的，pfcount和scard用法一样的，直接获取计数值。pfmerge将２个HyperLogLog合并。<br>　　pfadd codehole user1<br>　　其底层实现是稠密矩阵。一个我也不懂的数据结构
　　</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://skydh.github.io/2018/09/05/redis位图/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="董航">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="why are you so happy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/05/redis位图/" itemprop="url">redis 位图</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-05T09:09:13+08:00">
                2018-09-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>ps：读掘金小册笔记</p>
<h2 id="位图的产生和作用"><a href="#位图的产生和作用" class="headerlink" title="位图的产生和作用"></a>位图的产生和作用</h2><p>　　开发时我们常常需要存储一些bool型数据类型，比如用户的签到记录，签了为1，没签为0，如果用普通的key/value，每个用户要记录365个，当用户多的时候，需要的存储太多，为了解决这个问题，redis提供了位图数据结构，每天的签到记录只占据一个位，365天就是365位，也就是46个字节，其内容也是普通的字符串，也就是byte数组，可以用get,set获取和设置整个数组，也可以用getbite/setbite来将其作为数组来操作。</p>
<h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><p>　　setbit a 1 1;这个就是设置这个a这个数组第二位位1，getbite a 1,获取a这个byte数组的第二位的数字，如果直接用get a 则是获得到这个byte数组对应的Ascll值，用时我们也可以先set字符，然后getbite 其数组。总之，这2套操作是互通的。</p>
<h2 id="统计查找"><a href="#统计查找" class="headerlink" title="统计查找"></a>统计查找</h2><p>　　redis提供了位图统计指令bitcount和位图查找指令bitpos,bitcount是统计指定位置范围内1的个数，bitpos用来查找指定范围内出现的第一个0或者1。后面的2个参数指的是字符索引。比如bitcount w 0 0,表示w字节数组第一个字符中1的位数。比如bitcount w 0 1,则是查询前2个字符中1的位数。bitpos w 0,表示查询w这个字节数组第一个出现0的位置，bitpop w 1 2 2,表示查询第三个字符中第一个1出现的位置。</p>
<h2 id="批量处理"><a href="#批量处理" class="headerlink" title="批量处理"></a>批量处理</h2><p>　　１．前面getite都是单个单个执行的。如果想批量执行，就要用bitfield这个指令。<br>　　比如：bitfield w get u4 0,从第一个位置开始取4个数，结果是无符号数（u）,bitfield w get i3 2,从第三个数开始取3个数，结果是有符号数（i）.所谓有符号就是第一位是符号位，有符号数最多可以获取64位，无符号只能63位（redis协议中integer就是有符号数）<br>　　 bitfield w set u8 8 97 这个就是把第二个字符改成ａ，因为ａ的ASCII码的值是97.这就可以批量修改字节数组的值。</p>
<p>　　bitfield w incrby u4 2 1  这个就是从第三个位开始，对接下来的无符号数＋１，既然是自增操作，那么就可能出现溢出如果增加了正数就会上溢，如果增加的负数就会下溢出，redis默认的方法时折返，如果出现了溢出，就将溢出的符号位丢了。关于溢出，默认是折返<br>　　还有其他策略，饱和截断超过了范围就停留在最大值最小值那里，失败报错不执行。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://skydh.github.io/2018/09/04/redis消息队列/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="董航">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="why are you so happy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/04/redis消息队列/" itemprop="url">redis消息队列</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-04T16:53:36+08:00">
                2018-09-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>ps：读掘金小册笔记</p>
<h2 id="简单的异步消息队列"><a href="#简单的异步消息队列" class="headerlink" title="简单的异步消息队列"></a>简单的异步消息队列</h2><p>　　对于一些只有一组消费者的消息队列，使用redis可以轻松解决，redis的list结构可以很好的处理，这个list的基本操作rpush，lpush,rpop,lpop即可处理队列。</p>
<h2 id="队列为空怎么破"><a href="#队列为空怎么破" class="headerlink" title="队列为空怎么破"></a>队列为空怎么破</h2><p>　　客户端通过pop操作来获取消息，从而消费，如果队列空了，客户端就会进入pop的死循环，由于没数据，不停的pop，这种空循环不但对客户端影响很大，对redis的qps也有影响，我们则是通过sleep来解决这个问题，让线程睡一下即可，也就是暂停一秒左右。</p>
<h2 id="队列延迟"><a href="#队列延迟" class="headerlink" title="队列延迟"></a>队列延迟</h2><p>　　这个让线程休眠会导致消息延迟变高，有个办法可以避免这个问题，不用让线程睡眠，那就是用blpop/brpop阻塞读，阻塞读在队列没有数据的时候，会进入到休眠状态，一旦数据到来，就会立刻醒过来。</p>
<h2 id="空闲连接自动断开"><a href="#空闲连接自动断开" class="headerlink" title="空闲连接自动断开"></a>空闲连接自动断开</h2><p>　　如果这个线程一直阻塞在哪里，redis的客户端连接就会变成限制连接，服务器会主动断开，减少资源占用，这个时候blpop/brpop就会抛出异常。，因此编写客户端的时候要注意捕捉异常。</p>
<h2 id="锁冲突处理"><a href="#锁冲突处理" class="headerlink" title="锁冲突处理"></a>锁冲突处理</h2><p>　　请求加锁失败时：<br>　　１．直接抛出异常。２．sleep一会再试。3.将请求移动到延时队列，过一会再试试。实现如下：<br>　　通过zset来实现延时队列，我们将消息序列化为value,到期时间作为score，然后多个线程轮训获取到期任务处理。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://skydh.github.io/2018/09/03/redis分布式锁/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="董航">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="why are you so happy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/03/redis分布式锁/" itemprop="url">redis分布式锁</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-03T17:47:45+08:00">
                2018-09-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="什么是分布式锁"><a href="#什么是分布式锁" class="headerlink" title="什么是分布式锁"></a>什么是分布式锁</h2><p>　　一个重要资源被多个jvm进程竞争，会发生数据安全问题，对于分布式系统来说，多个微服务同时竞争一个资源时，就会产生如上问题。对于该问题，我们的方案是用分布式锁来锁住该数据。</p>
<h2 id="使用redis来分布式锁。"><a href="#使用redis来分布式锁。" class="headerlink" title="使用redis来分布式锁。"></a>使用redis来分布式锁。</h2><p>　　分布式锁的本质是在redis里面占一个坑，当别的进程也要占时，却占不了了，只能等待，或者放弃。<br>　　命令如下setnx(set if not exists)只允许一个客户端占坑，然后del 则是删除这个锁。</p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>　　１．由于种种原因，比如程序执行到中间出了bug,导致这个del指令没有被调用，这样就会陷入死锁。</p>
<p>　　２．于是我们队这个setnx加了过期时间限制，比如setnx lock true; expire lock 5,使得过5秒自动过期。然后再删除。但是存在问题，当setnx和expire之间服务器突然挂掉了，会导致expire得不到执行，从而继续死锁。如果用redis事务来处理也不行，因为当setnx没有抢到锁时，expire是不该被执行的。而这个redis事务里面没有ifelse判断语句。后续redis2.8版本该作者加入了set指令的扩展参数，是的setnx和expire可以一起执行形成一个原子操作。彻底解决了这个问题。</p>
<p>　　３．存在超时问题：当一个进程获取到锁后，由于逻辑执行部分太长，以至于超出了锁的超时限制。<br>　　<br>　　那就出现了问题，因为第二个进程获取到了这个锁，接着第一个线程执行了业务逻辑，于是就释放了这个锁，那么第三个进程就会获取到这个锁。<br>　　　<br>　　为了避免这个问题，redis分布式锁，一般不用于较长时间的任务，如果真的出现了，那会很麻烦。为了避免第一个进程删除第二个进程锁的问题。我们可以在加锁前，设置一个随机数，释放锁的时候就进行判断是否需要删除这个锁。这样就保证了自己删自己的锁。但是匹配value和删除可以不是一个原子操作，这就需要lua脚本处理了，因为lua脚本可以保证多个命令是原子操作的。可以将匹配和删除放在一起。</p>
<p>　　４．主从集群问题，当主节点挂掉了，从节点变成了主节点，但是从节点没有锁，其他进程就会请求加锁成功。为了解决这个问题，有些开源的library对其做了良好的封装。用户可以拿来就用。比如redlock-py,加锁时，它会向过半节点发送加锁命令，释放锁的时候，则是删除所有节点信息</p>
<h2 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h2><p>　　获取锁。要让其加锁和释放锁的是同一个线程，因此给这个key加了valu.第三个为nxxx，这个参数我们填的是NX，意思是SET IF NOT EXIST，即当key不存在时，我们进行set操作；若key已经存在，则不做任何操作.</p>
<pre><code>  /**
 * 尝试获取分布式锁
 * @param jedis Redis客户端
 * @param lockKey 锁
 * @param requestId 请求标识
 * @param expireTime 超期时间
 * @return 是否获取成功
 */
public static boolean tryGetDistributedLock(Jedis jedis, String lockKey, String requestId, int expireTime) {

    String result = jedis.set(lockKey, requestId, SET_IF_NOT_EXIST, SET_WITH_EXPIRE_TIME, expireTime);

    if (LOCK_SUCCESS.equals(result)) {
        return true;
    }
    return false;

}
</code></pre><p>　　释放锁。先判断value是否一致，看看自己是不是自己加的锁，让自己释放自己的锁。判断和删除要保证原子性，因此要使用lua脚本保证其原子性。</p>
<pre><code> /**
 * 释放分布式锁
 * @param jedis Redis客户端
 * @param lockKey 锁
 * @param requestId 请求标识
 * @return 是否释放成功
 */
public static boolean releaseDistributedLock(Jedis jedis, String lockKey, String requestId) {

    String script = &quot;if redis.call(&apos;get&apos;, KEYS[1]) == ARGV[1] then return redis.call(&apos;del&apos;, KEYS[1]) else return 0 end&quot;;
    Object result = jedis.eval(script, Collections.singletonList(lockKey), Collections.singletonList(requestId));

    if (RELEASE_SUCCESS.equals(result)) {
        return true;
    }
    return false;

}
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://skydh.github.io/2018/07/11/队列和栈/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="董航">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="why are you so happy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/11/队列和栈/" itemprop="url">栈和队列</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-11T14:31:47+08:00">
                2018-07-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>　　手动实现基于java栈和队列。<br>　　栈：</p>
<pre><code>package base_struct.hashmap;
public class DhStack &lt;K&gt;{
private class Data&lt;K&gt;{
    public K k;
    public Data(K k){
        this.k=k;
    }
}
private int size;
private int offet;
private Data&lt;K&gt;[] data;

public DhStack(int a)
{
    data=new Data[a];
    size=a;
    offet=0;    
}
public synchronized void put(K k)
{
    Data&lt;K&gt; temp=new Data&lt;K&gt;(k);
    data[offet]=temp;
    offet++;    
}
public synchronized K get()
{
    offet=offet-1;
    if(offet&lt;0)
    {
        return null;
    }
    K a=data[offet].k;

    return  data[offet].k;
}
}
</code></pre><p>　　对列：</p>
<pre><code>public class DhQueue&lt;K&gt; {
private class Data&lt;K&gt;{
    public K k;
    public Data&lt;K&gt; next;
    public Data(K k){
        this.k=k;
    }
}    
/*
 * 限制队列大小的参数
 */
private int size;
private int offet;
private Data&lt;K&gt; dataLinkedList;
public DhQueue(int a)
{

    size=a;


}
public synchronized void put(K k)
{
    if(offet&gt;=size-1)
    {
        throw new IllegalArgumentException();
    }
    Data&lt;K&gt; data=new Data&lt;K&gt;(k);


    Data&lt;K&gt; temp=dataLinkedList;
    if(dataLinkedList==null)
    {
        dataLinkedList=data;
    }else{
        while (temp.next != null) {

            temp = temp.next;
        }
        temp.next=data;
    }
    offet++;


}
public synchronized K get()
{
    if(offet&lt;=0)
    {
        return null;
    }
    K a=dataLinkedList.k;
    dataLinkedList=dataLinkedList.next;
    offet=offet-1;
    return a;    
}
}
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://skydh.github.io/2018/07/10/currentHashMap/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="董航">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="why are you so happy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/10/currentHashMap/" itemprop="url">concurrenthashmap</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-10T15:49:34+08:00">
                2018-07-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>　　１.7的ConcurrentHashMap最重要的一点就是Segment这个概念，每一个Segment就是一个小的HashMap，可以将这个理解为2级哈希表，一个总的Segment数组，每个数组里面存放一个类似Hashmap的结构，而加锁则是对Segment进行加锁。<br>   Segment继承自ReentrantLock，所以我们可以很方便的对每一个Segment上锁<br>　　1.8的则抛弃其冗余的设计，采用Node + CAS + Synchronized来保证并发安全进行实现，分析下其如何实现的吧。<br>　　点到ConcurrentHashMap的put方法里面，分析下源码：</p>
<pre><code>if (tab == null || (n = tab.length) == 0)
            tab = initTable();
</code></pre><p>　　当数组为空时，初始化数组。</p>
<pre><code>private final Node&lt;K,V&gt;[] initTable() {
    Node&lt;K,V&gt;[] tab; int sc;
    while ((tab = table) == null || tab.length == 0) {
        if ((sc = sizeCtl) &lt; 0)
            Thread.yield(); // lost initialization race; just spin
        else if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) {
            try {
                if ((tab = table) == null || tab.length == 0) {
                    int n = (sc &gt; 0) ? sc : DEFAULT_CAPACITY;
                    @SuppressWarnings(&quot;unchecked&quot;)
                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n];
                    table = tab = nt;
                    sc = n - (n &gt;&gt;&gt; 2);
                }
            } finally {
                sizeCtl = sc;
            }
            break;
        }
    }
    return tab;
}
</code></pre><p>　　初始化部分全部使用了CAS来完成线程安全。</p>
<pre><code>else if ((f = tabAt(tab, i = (n - 1) &amp; hash)) == null) {
           if (casTabAt(tab, i, null,
                        new Node&lt;K,V&gt;(hash, key, value, null)))
               break;                   // no lock when adding to empty bin
       }
</code></pre><p>　　如果相应位置的Node还未初始化，则通过CAS插入相应的数据<br>　　然后判断其数组不为空，那么就对这个节点加锁，然后插入数据</p>
<pre><code>synchronized (f) {
               if (tabAt(tab, i) == f) {
                   if (fh &gt;= 0) {
                       binCount = 1;
                       for (Node&lt;K,V&gt; e = f;; ++binCount) {
                           K ek;
                           if (e.hash == hash &amp;&amp;
                               ((ek = e.key) == key ||
                                (ek != null &amp;&amp; key.equals(ek)))) {
                               oldVal = e.val;
                               if (!onlyIfAbsent)
                                   e.val = value;
                               break;
                           }
                           Node&lt;K,V&gt; pred = e;
                           if ((e = e.next) == null) {
                               pred.next = new Node&lt;K,V&gt;(hash, key,
                                                         value, null);
                               break;
                           }
                       }
                   }
                   else if (f instanceof TreeBin) {
                       Node&lt;K,V&gt; p;
                       binCount = 2;
                       if ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,
                                                      value)) != null) {
                           oldVal = p.val;
                           if (!onlyIfAbsent)
                               p.val = value;
                       }
                   }
               }
           }
</code></pre><p>　　判断，链表就用链表的方式添加，红黑树就用红黑树的方式添加。</p>
<pre><code>if (binCount != 0) {
               if (binCount &gt;= TREEIFY_THRESHOLD)
                   treeifyBin(tab, i);
               if (oldVal != null)
                   return oldVal;
               break;
           }
</code></pre><p>如果大于了一个阈值，就将链表转换为数组。<br>嗯就这样，也就是说，1.8的HashMap和ConcurrentHashMap都是大致一样的数据结构，只是其中是否加锁。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://skydh.github.io/2018/07/10/hashmap/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="董航">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="why are you so happy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/10/hashmap/" itemprop="url">hashmap</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-10T10:44:58+08:00">
                2018-07-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h2><p>　　HashMap可以接受null键值和值，而Hashtable则不能；HashMap是非synchronized;HashMap很快；以及HashMap储存的是键值对。</p>
<h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><p>　　１．当两个对象的hashcode相同会发生什么？<br>　　因为hashcode相同，所以它们的bucket位置相同，‘碰撞’会发生。因为HashMap使用链表存储对象，这个Entry(包含有键值对的Map.Entry对象)会存储在链表中。<br>　　２．如果两个键的hashcode相同，你如何获取值对象？<br>　　找到bucket位置之后，会调用keys.equals()方法去找到链表中正确的节点，最终找到要找的值对象。<br>　　３．如果HashMap的大小超过了负载因子(load factor)定义的容量，怎么办？<br>　　默认的负载因子大小为0.75，也就是说，当一个map填满了75%的bucket时候，和其它集合类(如ArrayList等)一样，将会创建原来HashMap大小的两倍的bucket数组，来重新调整map的大小，并将原来的对象放入新的bucket数组中。这个过程叫作rehashing，因为它调用hash方法找到新的bucket位置。<br>　　４．为什么String, Interger这样的wrapper类适合作为键？<br>　　Ｓtring, Interger这样的wrapper类作为HashMap的键是再适合不过了，而且String最为常用。因为String是不可变的，也是final的，而且已经重写了equals()和hashCode()方法了。其他的wrapper类也有这个特点。不可变性是必要的，因为为了要计算hashCode()，就要防止键值改变，如果键值在放入时和获取时返回不同的hashcode的话，那么就不能从HashMap中找到你想要的对象。不可变性还有其他的优点如线程安全。如果你可以仅仅通过将某个field声明成final就能保证hashCode是不变的，那么请这么做吧。因为获取对象的时候要用到equals()和hashCode()方法，那么键对象正确的重写这两个方法是非常重要的。如果两个不相等的对象返回不同的hashcode的话，那么碰撞的几率就会小些，这样就能提高HashMap的性能。</p>
<h2 id="简单实现一个hashmap"><a href="#简单实现一个hashmap" class="headerlink" title="简单实现一个hashmap"></a>简单实现一个hashmap</h2><pre><code>package base_struct.hashmap;

/**
     * 基于链表数组的实现
     * @author dh
     * @param &lt;V&gt;
     * @param &lt;K&gt;
     *
*/
public class DhHashMap&lt;K, V&gt; {
private class Entry&lt;K,V&gt;{
    int hash;
    K key;
    V value;
    Entry&lt;K,V&gt; next;
    Entry(int hash, K key, V value, Entry&lt;K, V&gt; next) {
        this.hash = hash;
        this.key = key;
        this.value = value;
        this.next = next;
    }
}
private static final int DEFAULT_CAPACITY = 1 &lt;&lt; 4;

private Entry&lt;K, V&gt;[] table;

private int capacity;

private int size;
public DhHashMap(int capacity) {
    if (capacity &lt; 0) {
        throw new IllegalArgumentException();
    } else {
        table = new Entry[capacity];
        size = 0;
        this.capacity = capacity;
    }
}
public int size() {
    return size;
}
public boolean isEmpty() {
    return size == 0 ? true : false;}

/**
 * 这个hash算法采用位运算提高了效率,由于采用位运算，因此默认长度最好是2的幂最好
 * @param key
 * @return
 */
private int hash(Object key) {
    return (key == null) ? 0 : key.hashCode()&amp;(capacity-1);
}

/**
 * 按照以前邏輯，默认key一样则只修改value,
 * @param key
 * @param value
 */
public void put(K key, V value) {
    if (key == null) {
        throw new IllegalArgumentException();
    }
    int hash = hash(key);
    Entry&lt;K, V&gt; nEntry = new Entry&lt;K, V&gt;(hash, key, value, null);
    Entry&lt;K, V&gt; entry = table[hash];
    while (entry != null) {
        if (entry.key.equals(key)) {
            entry.value = value;
            return;
        }
        entry = entry.next;
    }
    nEntry.next = table[hash];
    table[hash] = nEntry;
    size++;
}
/**
 * h很简单的逻辑，找到确认的hash值后，一个个遍历
 * @param key
 * @return
 */
public V get(K key) {
    if (key == null) {
        throw new IllegalArgumentException();
    }
    int hash = hash(key);
    Entry&lt;K, V&gt; entry = table[hash];
    while (entry != null) {
        if (entry.key.equals(key)) {
            return entry.value;
        }
        entry = entry.next;
    }
    return null;
}
}
</code></pre><h2 id="gt-gt-gt-操作符"><a href="#gt-gt-gt-操作符" class="headerlink" title="&gt;&gt;&gt;操作符"></a>&gt;&gt;&gt;操作符</h2><p>　这个操作符的作用是将当前整数，转换为２进制后，右移。比如<br>２&gt;&gt;&gt;1,就是10右移1位剩下了一个1，就是1。<br>　　案例如下：<br>    public static void main(String [] args)<br>    {<br>        System.out.println(4&gt;&gt;&gt; 1);<br>    }<br>　　结果是２．<br>    public static void main(String [] args)<br>    {<br>        System.out.println(4&gt;&gt;&gt; 2);<br>    }<br>　　结果是１</p>
<h2 id="1-8增加了对其优化。"><a href="#1-8增加了对其优化。" class="headerlink" title="1.8增加了对其优化。"></a>1.8增加了对其优化。</h2><p>　　其原因是hash的的平均分布可能有问题，有可能导致链表过长，从而使得效率变的很低。因此加了一个新的结构红黑树，如果说1.8之前的hashMap是数组+链表，那么现在版本的就是数组+链表+红黑树。当链表长度<8时，默认以前的方式加元素，也就是数组+链表，当链表>8时则将链表转换为红黑树。（红黑树是一个自平衡的二叉查找树，其插入删除时为了保持红黑树的平衡特征，回自旋来保证，可以将其理解为一个具有自平衡的查找2叉树）</8时，默认以前的方式加元素，也就是数组+链表，当链表></p>
<h2 id="hashmap线程不安全"><a href="#hashmap线程不安全" class="headerlink" title="hashmap线程不安全"></a>hashmap线程不安全</h2><p>　　hashmap没有做加锁处理，举个简单例子，2个线程插入一个数据，其hashcode都是一样的，在极端情况下，可能导致插入少了一个数据。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://skydh.github.io/2018/07/09/CountDownLatch/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="董航">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="why are you so happy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/09/CountDownLatch/" itemprop="url">CountDownLatch 用法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-09T15:13:26+08:00">
                2018-07-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <pre><code>package test;
import java.util.concurrent.CountDownLatch;
public class Test {
 public static void main(String[] args) {   
     final CountDownLatch latch = new CountDownLatch(2)；
     new Thread(){
         public void run() {
             try {
                 System.out.println(&quot;子线程&quot;+Thread.currentThread().getName()+&quot;正在执行&quot;);
                Thread.sleep(3000);
                System.out.println(&quot;子线程&quot;+Thread.currentThread().getName()+&quot;执行完毕&quot;);
                latch.countDown();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
         };
     }.start();

     new Thread(){
         public void run() {
             try {
                 System.out.println(&quot;子线程&quot;+Thread.currentThread().getName()+&quot;正在执行&quot;);
                 Thread.sleep(3000);
                 System.out.println(&quot;子线程&quot;+Thread.currentThread().getName()+&quot;执行完毕&quot;);
                 latch.countDown();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
         };
     }.start();

     try {
         System.out.println(&quot;等待2个子线程执行完毕...&quot;);
        latch.await();
        System.out.println(&quot;2个子线程已经执行完毕&quot;);
        System.out.println(&quot;继续执行主线程&quot;);
            } catch (InterruptedException e) {
        e.printStackTrace();
        }
     }
}
</code></pre><p>　　对于这个类来说，这就是个计数器，设置了一个值，这个值不为０则调用其await()方法时，其线程将持续等待。这个功能的作用就是在一个方法里面可以异步的启动一个线程让异步从而加快运行。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/5/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><a class="extend next" rel="next" href="/page/7/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">董航</p>
              <p class="site-description motion-element" itemprop="description">clear 航</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">115</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            

          </nav>

          

          <div class="links-of-author motion-element">
            
          </div>

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">董航</span>

  
</div>


<div class="powered-by">
<i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv">
  本站访客数:<span id="busuanzi_value_site_uv"></span>
</span>
</div>

  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.3</div>




        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.3"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
