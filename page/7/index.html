<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="clear 航">
<meta property="og:type" content="website">
<meta property="og:title" content="why are you so happy">
<meta property="og:url" content="https://skydh.github.io/page/7/index.html">
<meta property="og:site_name" content="why are you so happy">
<meta property="og:description" content="clear 航">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="why are you so happy">
<meta name="twitter:description" content="clear 航">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://skydh.github.io/page/7/"/>





  <title>why are you so happy</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">why are you so happy</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">clear 航</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://skydh.github.io/2018/07/10/hashmap/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="董航">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="why are you so happy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/10/hashmap/" itemprop="url">hashmap</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-10T10:44:58+08:00">
                2018-07-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h2><p>　　HashMap可以接受null键值和值，而Hashtable则不能；HashMap是非synchronized;HashMap很快；以及HashMap储存的是键值对。</p>
<h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><p>　　１．当两个对象的hashcode相同会发生什么？<br>　　因为hashcode相同，所以它们的bucket位置相同，‘碰撞’会发生。因为HashMap使用链表存储对象，这个Entry(包含有键值对的Map.Entry对象)会存储在链表中。<br>　　２．如果两个键的hashcode相同，你如何获取值对象？<br>　　找到bucket位置之后，会调用keys.equals()方法去找到链表中正确的节点，最终找到要找的值对象。<br>　　３．如果HashMap的大小超过了负载因子(load factor)定义的容量，怎么办？<br>　　默认的负载因子大小为0.75，也就是说，当一个map填满了75%的bucket时候，和其它集合类(如ArrayList等)一样，将会创建原来HashMap大小的两倍的bucket数组，来重新调整map的大小，并将原来的对象放入新的bucket数组中。这个过程叫作rehashing，因为它调用hash方法找到新的bucket位置。<br>　　４．为什么String, Interger这样的wrapper类适合作为键？<br>　　Ｓtring, Interger这样的wrapper类作为HashMap的键是再适合不过了，而且String最为常用。因为String是不可变的，也是final的，而且已经重写了equals()和hashCode()方法了。其他的wrapper类也有这个特点。不可变性是必要的，因为为了要计算hashCode()，就要防止键值改变，如果键值在放入时和获取时返回不同的hashcode的话，那么就不能从HashMap中找到你想要的对象。不可变性还有其他的优点如线程安全。如果你可以仅仅通过将某个field声明成final就能保证hashCode是不变的，那么请这么做吧。因为获取对象的时候要用到equals()和hashCode()方法，那么键对象正确的重写这两个方法是非常重要的。如果两个不相等的对象返回不同的hashcode的话，那么碰撞的几率就会小些，这样就能提高HashMap的性能。</p>
<h2 id="简单实现一个hashmap"><a href="#简单实现一个hashmap" class="headerlink" title="简单实现一个hashmap"></a>简单实现一个hashmap</h2><pre><code>package base_struct.hashmap;

/**
     * 基于链表数组的实现
     * @author dh
     * @param &lt;V&gt;
     * @param &lt;K&gt;
     *
*/
public class DhHashMap&lt;K, V&gt; {
private class Entry&lt;K,V&gt;{
    int hash;
    K key;
    V value;
    Entry&lt;K,V&gt; next;
    Entry(int hash, K key, V value, Entry&lt;K, V&gt; next) {
        this.hash = hash;
        this.key = key;
        this.value = value;
        this.next = next;
    }
}
private static final int DEFAULT_CAPACITY = 1 &lt;&lt; 4;

private Entry&lt;K, V&gt;[] table;

private int capacity;

private int size;
public DhHashMap(int capacity) {
    if (capacity &lt; 0) {
        throw new IllegalArgumentException();
    } else {
        table = new Entry[capacity];
        size = 0;
        this.capacity = capacity;
    }
}
public int size() {
    return size;
}
public boolean isEmpty() {
    return size == 0 ? true : false;}

/**
 * 这个hash算法采用位运算提高了效率,由于采用位运算，因此默认长度最好是2的幂最好
 * @param key
 * @return
 */
private int hash(Object key) {
    return (key == null) ? 0 : key.hashCode()&amp;(capacity-1);
}

/**
 * 按照以前邏輯，默认key一样则只修改value,
 * @param key
 * @param value
 */
public void put(K key, V value) {
    if (key == null) {
        throw new IllegalArgumentException();
    }
    int hash = hash(key);
    Entry&lt;K, V&gt; nEntry = new Entry&lt;K, V&gt;(hash, key, value, null);
    Entry&lt;K, V&gt; entry = table[hash];
    while (entry != null) {
        if (entry.key.equals(key)) {
            entry.value = value;
            return;
        }
        entry = entry.next;
    }
    nEntry.next = table[hash];
    table[hash] = nEntry;
    size++;
}
/**
 * h很简单的逻辑，找到确认的hash值后，一个个遍历
 * @param key
 * @return
 */
public V get(K key) {
    if (key == null) {
        throw new IllegalArgumentException();
    }
    int hash = hash(key);
    Entry&lt;K, V&gt; entry = table[hash];
    while (entry != null) {
        if (entry.key.equals(key)) {
            return entry.value;
        }
        entry = entry.next;
    }
    return null;
}
}
</code></pre><h2 id="gt-gt-gt-操作符"><a href="#gt-gt-gt-操作符" class="headerlink" title="&gt;&gt;&gt;操作符"></a>&gt;&gt;&gt;操作符</h2><p>　这个操作符的作用是将当前整数，转换为２进制后，右移。比如<br>２&gt;&gt;&gt;1,就是10右移1位剩下了一个1，就是1。<br>　　案例如下：<br>    public static void main(String [] args)<br>    {<br>        System.out.println(4&gt;&gt;&gt; 1);<br>    }<br>　　结果是２．<br>    public static void main(String [] args)<br>    {<br>        System.out.println(4&gt;&gt;&gt; 2);<br>    }<br>　　结果是１</p>
<h2 id="1-8增加了对其优化。"><a href="#1-8增加了对其优化。" class="headerlink" title="1.8增加了对其优化。"></a>1.8增加了对其优化。</h2><p>　　其原因是hash的的平均分布可能有问题，有可能导致链表过长，从而使得效率变的很低。因此加了一个新的结构红黑树，如果说1.8之前的hashMap是数组+链表，那么现在版本的就是数组+链表+红黑树。当链表长度<8时，默认以前的方式加元素，也就是数组+链表，当链表>8时则将链表转换为红黑树。（红黑树是一个自平衡的二叉查找树，其插入删除时为了保持红黑树的平衡特征，回自旋来保证，可以将其理解为一个具有自平衡的查找2叉树）</8时，默认以前的方式加元素，也就是数组+链表，当链表></p>
<h2 id="hashmap线程不安全"><a href="#hashmap线程不安全" class="headerlink" title="hashmap线程不安全"></a>hashmap线程不安全</h2><p>　　hashmap没有做加锁处理，举个简单例子，2个线程插入一个数据，其hashcode都是一样的，在极端情况下，可能导致插入少了一个数据。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://skydh.github.io/2018/07/09/CountDownLatch/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="董航">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="why are you so happy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/09/CountDownLatch/" itemprop="url">CountDownLatch 用法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-09T15:13:26+08:00">
                2018-07-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <pre><code>package test;
import java.util.concurrent.CountDownLatch;
public class Test {
 public static void main(String[] args) {   
     final CountDownLatch latch = new CountDownLatch(2)；
     new Thread(){
         public void run() {
             try {
                 System.out.println(&quot;子线程&quot;+Thread.currentThread().getName()+&quot;正在执行&quot;);
                Thread.sleep(3000);
                System.out.println(&quot;子线程&quot;+Thread.currentThread().getName()+&quot;执行完毕&quot;);
                latch.countDown();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
         };
     }.start();

     new Thread(){
         public void run() {
             try {
                 System.out.println(&quot;子线程&quot;+Thread.currentThread().getName()+&quot;正在执行&quot;);
                 Thread.sleep(3000);
                 System.out.println(&quot;子线程&quot;+Thread.currentThread().getName()+&quot;执行完毕&quot;);
                 latch.countDown();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
         };
     }.start();

     try {
         System.out.println(&quot;等待2个子线程执行完毕...&quot;);
        latch.await();
        System.out.println(&quot;2个子线程已经执行完毕&quot;);
        System.out.println(&quot;继续执行主线程&quot;);
            } catch (InterruptedException e) {
        e.printStackTrace();
        }
     }
}
</code></pre><p>　　对于这个类来说，这就是个计数器，设置了一个值，这个值不为０则调用其await()方法时，其线程将持续等待。这个功能的作用就是在一个方法里面可以异步的启动一个线程让异步从而加快运行。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://skydh.github.io/2018/07/02/spring mvc流程分析 /">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="董航">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="why are you so happy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/02/spring mvc流程分析 /" itemprop="url">spring mvc 流程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-02T10:21:42+08:00">
                2018-07-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="什么是spring-mvc"><a href="#什么是spring-mvc" class="headerlink" title="什么是spring mvc"></a>什么是spring mvc</h2><p>　　Spring MVC本质上还是一个Servlet,他封装了一套通用的方案，使得我们开发时只需要写核心的业务逻辑，不需要写Servlet。而Servlet也是对底层Socket的封装，使得我们开发变得简单。</p>
<h2 id="一个简单mvc-流程"><a href="#一个简单mvc-流程" class="headerlink" title="一个简单mvc 流程"></a>一个简单mvc 流程</h2><ul>
<li>首先浏览器向服务器发送一个请求。</li>
<li>服务器接受到连接创建一个socket线程和浏览器建立连接，紧接着创建request,reponse对象，然后交接给Servlet容器。</li>
<li>打断下，预先知识，DispatcherServlet类继承实现 FrameworkServlet抽象类， FrameworkServlet抽象类继承HttpServlet抽象类。HttpServlet抽象类最终实现Servlet接口，因此最顶级的接口是Servlet接口。</li>
<li>下面说的方法本质上都是DispatcherServlet类的，然后进入service方法（ FrameworkServlet抽象类实现的），然后调用父类的service方法（HttpServlet），在这个方法里面从HttpServletRequest对象里面获取到http请求方式，比如get，post等，在这些方法里面。统一调用了processRequest方法（FrameworkServlet抽象类实现的）在这个方法里面，LocaleContext，ServletRequestAttributes这2个从HttpServletRequest对象取出来，放到</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://skydh.github.io/2018/06/25/es入门/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="董航">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="why are you so happy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/25/es入门/" itemprop="url">Elasticsearch入门</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-25T09:31:00+08:00">
                2018-06-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Elasticsearch-和-solr"><a href="#Elasticsearch-和-solr" class="headerlink" title="Elasticsearch 和 solr"></a>Elasticsearch 和 solr</h2><p>　　Elasticsearch更加精简，大多高级功能是依靠插件完成的。而solr很全面，包含了大部分的高级功能，可以从下载大小就可以看出来。<br>　　２者都是基于Lucene这个基于java的搜索类库。<br>　　根据文档（未测试）Elasticsearch的实时搜索效率明显高于solr。<br>　　由于小且精简，因此入门简单。</p>
<h2 id="Elasticsearch-安装"><a href="#Elasticsearch-安装" class="headerlink" title="Elasticsearch 安装"></a>Elasticsearch 安装</h2><p>　　本次安装基于Windows10。<br>　　官网下载：<a href="https://www.elastic.co/downloads/elasticsearch" target="_blank" rel="noopener">https://www.elastic.co/downloads/elasticsearch</a>。<br>　　下载的zip包，下载解压，然后运行bin\elasticsearch.bat这个Windows批处理文件。<br>　　然后打开浏览器输入　<a href="http://localhost:9200/" target="_blank" rel="noopener">http://localhost:9200/</a>。看看是否返回了有效信息。<br>　　安装node.js，grunt(网上搜索)。<br>　　下载head插件。<a href="https://github.com/mobz/elasticsearch-head" target="_blank" rel="noopener">https://github.com/mobz/elasticsearch-head</a><br>　　修改Elasticsearch的配置文件config/elasticsearch.yml<br>　　修改一下ES的监听地址，这样别的机器也可以访问<br>　　network.host: 0.0.0.0<br>　　增加新的参数，这样head插件可以访问es<br>　　http.cors.enabled: true<br>　　http.cors.allow-origin: “*”<br>　　然后在下载的head插件的解压文件夹的根路径下，运行，npm install 安装其所依赖的各种插件。<br>　　最后启动　grunt server。访问<a href="http://localhost:9100/" target="_blank" rel="noopener">http://localhost:9100/</a><br>　　安装完毕。</p>
<h2 id="面向文档（Nosql）"><a href="#面向文档（Nosql）" class="headerlink" title="面向文档（Nosql）"></a>面向文档（Nosql）</h2><p>　　Elasticsearch 是 面向文档 的，意味着它是以文档来进行存储数据的。Elasticsearch 不仅存储文档，而且能索引每个文档的内容使之可以被检索。在 Elasticsearch 中，你是对文档进行索引、检索、排序和过滤–而不是对行列数据（关系数据库）。这是一种完全不同的思考数据的方式，也是 Elasticsearch 能支持复杂全文检索的原因。</p>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>　　在Elasticsearch里面，索引有很多个意思。<br>　　１．名词：一个索引就是类似于关系数据库的一个数据库，是一个存储关系型文档的地方。<br>　　２．动词：索引一个文档就是存储一个文档到索引（名词）中以便于它可以被检索和查询到，类似于关系数据库的insert关键字。<br>　　３．倒排索引：如果说关系数据库的索引的数据结构是B+树，那么Elasticsearch采用了一个叫倒排索引的结构达到相同的目的。</p>
<h2 id="创建和基本查询"><a href="#创建和基本查询" class="headerlink" title="创建和基本查询"></a>创建和基本查询</h2><p>　　打开Elasticsearch的head插件，然后连接Elasticsearch。在复合查询中，输入url <a href="http://localhost:9200/megacorp/employee/3/,提交方式选择put,内容：{}(json)。即可创建一个索引文档。其中" target="_blank" rel="noopener">http://localhost:9200/megacorp/employee/3/,提交方式选择put,内容：{}(json)。即可创建一个索引文档。其中</a> <a href="http://localhost:9200" target="_blank" rel="noopener">http://localhost:9200</a> 是Elasticsearch的地址。而megacorp上上面提到的名词索引。employee是类型。3为该数据的特定id。<br>　　插入成功后，可以GET /megacorp/employee/３　查询出你插入的数据。<br>　　往里面多插入几条数据，以便于学习测试。<br>　　 /megacorp/employee/_search　这个就是查出这个索引这个类型的所有数据。<br>　　在head这个插件的复合查询里面，有2个行，第一行就是输入上面的url,下面的行，加入查询参数：?q=last_name:Smith<br>　　后面有更加复杂的ELS查询：<br>　　<a href="http://localhost:9200/" target="_blank" rel="noopener">http://localhost:9200/</a><br>　　megacorp/employee/_search/<br>　　post<br>　　{<br>    “query” : {<br>        “bool”: {<br>            “must”: {<br>                “match” : {<br>                    “last_name” : “smith”<br>                }<br>            },<br>            “filter”: {<br>                “range” : {<br>                    “age” : { “gt” : 30 }<br>                }<br>            }<br>        }<br>    }<br>}<br>　　也可以用上面的方式(match)实现全文检索。结果会按照匹配度按顺序排下来。但是想要不全文检索，具体查询，那么就用这个（match_phrase）</p>
<h2 id="文档的更新"><a href="#文档的更新" class="headerlink" title="文档的更新"></a>文档的更新</h2><p>  在 Elasticsearch 中文档是 不可改变 的，不能修改它们。 相反，如果想要更新现有的文档，需要 重建索引 或者进行替换，在内部，Elasticsearch 已将旧文档标记为已删除，并增加一个全新的文档。 尽管你不能再对旧版本的文档进行访问，但它并不会立即消失。当继续索引更多的数据，Elasticsearch 会在后台清理这些已删除文档。删除逻辑也是。这点和mysql的删除很类似，都是逻辑删除！但是意义不一样~~~</p>
<h2 id="冲突处理"><a href="#冲突处理" class="headerlink" title="冲突处理"></a>冲突处理</h2><p>　　当多个端同时处理一个文档的值的时候，可能出现值丢失的情况。因此我们需要加锁，就像对mysql的处理一样。有2个方式，第一个就是悲观加锁，要获取这个数据，那么你要先获得锁，但是效率存在问题，第二个就是用乐观锁，类似java原子类的CAS的思想，我假设你没有变化。有变化，我就重新获取值进行处理，而我们的文档存在一个叫version的字段，可以用来判断。我们可以通过api来指定version来确认。</p>
<pre><code>PUT /website/blog/1?version=1 
{
  &quot;title&quot;: &quot;My first blog entry&quot;,
  &quot;text&quot;:  &quot;Starting to get the hang of this...&quot;
}
</code></pre><p>　　当然大部分情况下，我们使用mysql作为主要的数据存储，而Elasticsearch主要作为检索用的，如果多个进程进行数据同步，就会出现那个问题。我们在数据库里面就有了版本号，那么我们也可以用这个版本号作为判断条件，是否更新。</p>
<h2 id="请求合并"><a href="#请求合并" class="headerlink" title="请求合并"></a>请求合并</h2><p>　　es可以将多个请求合并成一个，避免单独处理每个请求花费的网络延时和开销。 如果你需要从 Elasticsearch 检索很多文档，那么使用 multi-get 或者 mget API 来将这些检索请求放在一个请求中，将比逐个文档请求更快地检索到全部文档。</p>
<pre><code>_mget
{
       &quot;docs&quot; : [
  {
     &quot;_index&quot; : &quot;website&quot;,
     &quot;_type&quot; :  &quot;blog&quot;,
     &quot;_id&quot; :    2
  },
  {
     &quot;_index&quot; : &quot;website&quot;,
     &quot;_type&quot; :  &quot;pageviews&quot;,
     &quot;_id&quot; :    1,
     &quot;_source&quot;: &quot;views&quot;
  }
       ]
}
</code></pre><h2 id="分布式存储"><a href="#分布式存储" class="headerlink" title="分布式存储"></a>分布式存储</h2><p>　　我们知道我们一个索引对应多个分片，每个分片又有多个副本，那么我们索引一个文档时，文档会被存储到主分片里面，但是应该存到具体哪个分片里面呢？是有个hash算法，根据id计算出一个值，然后对分片数取模，即可。</p>
<p>　　以下是在主副分片和任何副本分片上面 成功新建，索引和删除文档所需要的步骤顺序：<br>　　１．客户端向 Node 1 发送新建、索引或者删除请求。<br>　　２．节点使用文档的 _id 确定文档属于分片 0 。请求会被转发到 Node 3<code>，因为分片 0 的主分片目前被分配在</code>Node 3 上。<br>　　３．Node 3 在主分片上面执行请求。如果成功了，它将请求并行转发到 Node 1 和 Node 2 的副本分片上。一旦所有的副本分片都报告成功, Node 3 将向协调节点报告成功，协调节点向客户端报告成功。</p>
<p>　　以下是从主分片或者副本分片检索文档的步骤顺序：</p>
<p>　　1、客户端向 Node 1 发送获取请求。</p>
<p>　　2、节点使用文档的 _id 来确定文档属于分片 0 。分片 0 的副本分片存在于所有的三个节点上。 在这种情况下，它将请求转发到 Node2 。</p>
<p>　　3、Node 2 将文档返回给 Node 1 ，然后将文档返回给客户端。</p>
<p>　　在处理读取请求时，协调结点在每次请求的时候都会通过轮询所有的副本分片来达到负载均衡。</p>
<p>　　在文档被检索时，已经被索引的文档可能已经存在于主分片上但是还没有复制到副本分片。 在这种情况下，副本分片可能会报告文档不存在，但是主分片可能成功返回文档。 一旦索引请求成功返回给用户，文档在主分片和副本分片都是可用的。</p>
<p>　　以下是部分更新一个文档的步骤：</p>
<p>　　１．客户端向 Node 1 发送更新请求。<br>　　２．它将请求转发到主分片所在的 Node 3 。<br>　　３．Node 3 从主分片检索文档，修改 _source 字段中的 JSON ，并且尝试重新索引主分片的文档。 如果文档已经被另一个进程修改，它会重试步骤 3 ，超过 retry_on_conflict 次后放弃。<br>　　４．如果 Node 3 成功地更新文档，它将新版本的文档并行转发到 Node 1 和 Node 2 上的副本分片，重新建立索引。 一旦所有副本分片都返回成功， Node 3 向协调节点也返回成功，协调节点向客户端返回成功。</p>
<h2 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h2><p>　　Elasticsearch可以垂直扩展（购买性能更好的机器），也可以水平扩展（扩展多个节点），一个运行中的Elasticsearch实例就是一个节点，具有多个相同cluster.name配置的节点组成。其共同承担数据和负载的压力。<br>　　集群有个叫集群健康的值，3个状态。<br>　　green：所有主分片和副分片都正常。<br>　　yellow:所有主分片正常，但是副分片有的不正常。<br>　　red:存在主分片不正常。<br>　　我们上面提到的名词索引实际上指向一个或者多个分片。一个分片是底层的工作单元，保存了全部数据的一部分，Elasticsearch利用分片将数据分发到集群各处的，分片是数据的容器，文档保存在分片中。分片分配到集群的各个节点里面。<br>　　一个分片可以是主分片和副本分片，索引内的任何一个文档都是属于主分片的，所以主分片决定了索引能保存的最大数据量。副本分片是主分片的copy，为了保障数据安全的。<br>　　水平扩容后，分片后自动重新分配的。<br>　　一个Elasticsearch实例就是一个节点。一个索引默认五个主分片，五个副分片。<br>　　当你只有一个节点的时候，创建一个索引的集群健康值一定是黄色。因为副本分片都是 unassigned —— 它们都没有被分配到任何节点。 在同一个节点上既保存原始数据又保存副本是没有意义的，因为一旦失去了那个节点，我们也将丢失该节点上的所有副本数据。当你再启动一个名字一样的节点的时候，集群健康值就是绿色了。<br>　　然后我们在启动第三个节点，发现一个索引的１０个分片均匀分配到３个节点里面了。<br>   因此我们发现Elasticsearch的动态扩展能力极强。<br>　　写操作我们只能通过主分片进行，读操作我们可以从主副分片都可以。当我们创建的节点吵过１０个后，我们可以将副本重新设置，来获取更大的并发量。</p>
<h2 id="java-操作-Elasticsearch"><a href="#java-操作-Elasticsearch" class="headerlink" title="java 操作 Elasticsearch"></a>java 操作 Elasticsearch</h2><p>　　代码如下：<br>　　maven依赖：</p>
<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;org.elasticsearch.client&lt;/groupId&gt;
    &lt;artifactId&gt;transport&lt;/artifactId&gt;
    &lt;version&gt;6.3.0&lt;/version&gt;
&lt;/dependency&gt;
</code></pre><p>　　代码：</p>
<pre><code>import java.net.InetAddress;
import org.elasticsearch.action.get.GetResponse;
import org.elasticsearch.client.transport.TransportClient;
import org.elasticsearch.common.settings.Settings;
import org.elasticsearch.common.transport.TransportAddress;
import org.elasticsearch.transport.client.PreBuiltTransportClient;
public class TestEsClient {
    public static void main(String[] args) {
        try {
            Settings settings = Settings.builder().put(&quot;cluster.name&quot;, &quot;elasticsearch&quot;).build();
            // 创建client
            TransportClient client = new PreBuiltTransportClient(settings)
                    .addTransportAddress(new TransportAddress(InetAddress.getByName(&quot;127.0.0.1&quot;), 9300));
            // 搜索数据
            GetResponse response = client.prepareGet(&quot;megacorp&quot;, &quot;employee&quot;, &quot;1&quot;).execute().actionGet();
            // 输出结果
            System.out.println(response.getSourceAsString());
            // 关闭client
            client.close();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
</code></pre><p>　　结果输出：</p>
<pre><code>{&quot;first_name&quot;:&quot;John&quot;,&quot;last_name&quot;:&quot;Smith&quot;,&quot;age&quot;:25,&quot;about&quot;:&quot;I love to go rock climbing&quot;,&quot;interests&quot;:[&quot;sports&quot;,&quot;music&quot;]}
</code></pre><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>　　大致这样，具体要用的时候细看吧。ps:关于java代码操作Elasticsearch，要切记，maven版本和Elasticsearch版本不能差距太大哦，不然是连不上的</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://skydh.github.io/2018/06/19/BigDecimal计算精度问题/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="董航">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="why are you so happy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/19/BigDecimal计算精度问题/" itemprop="url">BigDecimal精度问题</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-19T20:41:46+08:00">
                2018-06-19
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>　　１．商业计算使用BigDecimal。<br>　　２．使用参数为String的构造函数。<br>　　３．BigDecimal都是不可变的，每一步的运算时，都会产生一个新的对象。所以在做加减乘除后千万要保存操作后的值。</p>
<h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p>　　代码１：</p>
<pre><code>public class Test001 {
    public static void main(String args[]) {
        BigDecimal a = new BigDecimal(1.5);
        BigDecimal a1 = new BigDecimal(329.530);
        System.out.println(a.multiply(a1).setScale(2, BigDecimal.ROUND_HALF_UP));
    }
}
</code></pre><p>　　输出：</p>
<pre><code>494.29
</code></pre><p>　　代码２：</p>
<pre><code>public class Test001 {
    public static void main(String args[]) {
        BigDecimal a = new BigDecimal(&quot;1.5&quot;);
    　　BigDecimal a1 = new BigDecimal(&quot;329.530&quot;);
        System.out.println(a.multiply(a1).setScale(2, BigDecimal.ROUND_HALF_UP));
    }
}
</code></pre><p>　　输出：</p>
<pre><code>494.30
</code></pre><p>  计算器输出结果：</p>
<pre><code>489.30
</code></pre><p>　　原因解析：<br>　　JDK的描述：参数为dubbo的构造方法的结果具有一定的不可预知性，认为java在写入new BigDecimal(0.1)中这个0.1不是标准的0.1可能是一个无限趋近于0.1的一个小数，虽然表面上等于他。</p>
<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><pre><code>public BigDecimal multiply(BigDecimal multiplicand) {
    int productScale = checkScale((long) scale + multiplicand.scale);
    if (this.intCompact != INFLATED) {
        if ((multiplicand.intCompact != INFLATED)) {
            return multiply(this.intCompact, multiplicand.intCompact, productScale);
        } else {
            return multiply(this.intCompact, multiplicand.intVal, productScale);
        }
    } else {
        if ((multiplicand.intCompact != INFLATED)) {
            return multiply(multiplicand.intCompact, this.intVal, productScale);
        } else {
            return multiply(this.intVal, multiplicand.intVal, productScale);
        }
    }
}
</code></pre><p>　　在这个地方就是判断是不是字符串的，这个this.intCompact 是获取到参数的整数值，如果获取到时一大串数字，那就是dubbo参数传进来的，这里进行判断，从而获取到不同的值。进入到不同的方法进行运算。其实运算原理大致说下，小数转换为整数计算，最后除以１０的ｎ次方即可。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://skydh.github.io/2018/06/19/ControllerAdvice注解/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="董航">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="why are you so happy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/19/ControllerAdvice注解/" itemprop="url">ControllerAdvice用法解析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-19T20:32:58+08:00">
                2018-06-19
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>　　通过@ControllerAdvice注解可以将对于控制器的全局配置放在同一个位置。<br>　　注解了@Controller的类的方法可以使用@ExceptionHandler、@InitBinder、@ModelAttribute注解到方法上。<br>　　@ControllerAdvice注解将作用在所有注解了@RequestMapping的控制器的方法上<br>　　@ExceptionHandler：用于全局处理控制器里的异常。</p>
<h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><pre><code>@ControllerAdvice
@ResponseBody
public class BusinessExceptionHandler {
    @ExceptionHandler(value = Exception.class)
    public JsonBackData exceptionHandler(HttpServletRequest request, Exception e) {
        e.printStackTrace();
        JsonBackData back = new JsonBackData();
        if (e instanceof BusinessException) {
            BusinessException ex = (BusinessException) e;
            back.setSuccess(false);
            back.setBackMsg(ex.getMessage());
        }
        return back;
    }
</code></pre><p>　　加了这个全局配置的Bean后，以前我的代码是这样的：</p>
<pre><code>@RequestMapping(value = &quot;queryDetail&quot;)
@ResponseBody
public JsonBackData queryDetail(@RequestParam String id) {
    JsonBackData back = new JsonBackData();
    try {
        OpenSourceThrottleAdjustVO vo = openSourceThrottlePlanQueryService.findById(id);
        back.setBackData(vo);
        back.setSuccess(true);
        back.setBackMsg(&quot;查询详细信息成功&quot;);
    } catch (BusinessException e) {
        back.setSuccess(false);
        back.setBackMsg(&quot;查询详细信息失败:&quot; + e.getMessage());
    }
    return back;
}
</code></pre><p> 　多了很多无关信息。几乎每个类都要try catch一下，代码极度冗余。<br>但是加了上面的全局处理控制器的异常处理后。代码就变成了下面的了。</p>
<pre><code>@RequestMapping(value = &quot;queryDetail&quot;)
@ResponseBody
public JsonBackData queryDetail(@RequestParam String id) {
    JsonBackData back = new JsonBackData();
    OpenSourceThrottleAdjustVO vo = openSourceThrottlePlanQueryService.findById(id);
    back.setBackData(vo);
    back.setSuccess(true);
    back.setBackMsg(&quot;查询详细信息成功&quot;);
    return back;
}
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://skydh.github.io/2018/06/12/原因/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="董航">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="why are you so happy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/12/原因/" itemprop="url">原因</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-12T17:24:50+08:00">
                2018-06-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>　　最近帮女朋友做毕设写论文，又要上班，没时间写了。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://skydh.github.io/2018/06/08/秒杀/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="董航">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="why are you so happy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/08/秒杀/" itemprop="url">秒杀</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-08T15:58:41+08:00">
                2018-06-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://skydh.github.io/2018/05/21/dubbo zookeeper/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="董航">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="why are you so happy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/21/dubbo zookeeper/" itemprop="url">dubbo+zookeeper</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-21T09:29:45+08:00">
                2018-05-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p>　　先搭建一个dubbo+zookeeper的demo，然后根据demo来细说。<br>　　第一步：从dubbo官网下载dubbo-master.zip文件，从zookeeper官网下载zookeeper.tar.gz文件。<br>　　第二步：解压zookeeper.tar.gz文件，在解压\zookeeper-3.4.10\bin路径下，点击zkServer.cmd(本案例是直接在windows下运行),成功启动，发现其绑定了端口号2181。<br>　　第三步：解压dubbo-master.zip文件，然后在用eclipse导入其项目空间。发现dubbo的注入地址默认配置的是zookeeper://127.0.0.1:2181这个地址，不用修改，然后将其放到tomcat下启动。（且记先启动zookeeper在启动dubbo，不然dubbo启动连接不到zookeeper，启动失败的。）<br>　　第四步：打开<a href="http://localhost:8088/dubbo-admin-2.5.8/，然后输入账号密码，登录到dubbo管理界面。（确切地址是多少，看你的配置）。这样4步，dubbo管理平台就已经搭建好了。" target="_blank" rel="noopener">http://localhost:8088/dubbo-admin-2.5.8/，然后输入账号密码，登录到dubbo管理界面。（确切地址是多少，看你的配置）。这样4步，dubbo管理平台就已经搭建好了。</a><br>　　第五步：在写一个消费者和生产者来同步dubbo来进行通信。先创建一个生产者。这里不详细说了，大部分都是maven工程的创建修改，直接给上代码，供大家测试调试<a href="https://github.com/skydh/provide-test" target="_blank" rel="noopener">生产者</a>。<br>　　第六步：写一个消费者来消费生产者的服务。这里也是直接提供代码让大家来进行调试。<a href="https://github.com/skydh/spring-mvc-test/" target="_blank" rel="noopener">消费者</a>。<br>　　第七步：输入<a href="http://localhost:8089/spring-mvc/hello/dh1，发现调用已经成功，同时发现dubbo管理界面出现了一个生成者，一个消费者。" target="_blank" rel="noopener">http://localhost:8089/spring-mvc/hello/dh1，发现调用已经成功，同时发现dubbo管理界面出现了一个生成者，一个消费者。</a></p>
<h2 id="什么是zookeeper"><a href="#什么是zookeeper" class="headerlink" title="什么是zookeeper　　"></a>什么是zookeeper　　</h2><p>　　Zookeeper是Hadoop的一个子项目，它是分布式系统中的协调系统，可提供的服务有：配置服务，名字服务，分布式同步，组服务等。</p>
<h3 id="zookeeper配置文件"><a href="#zookeeper配置文件" class="headerlink" title="zookeeper配置文件"></a>zookeeper配置文件</h3><p>　　我们可以通过修改Zookeeper的配置文件来修改Zookeeper的启动信息。<br>        tickTime=2000<br>        initLimit=10<br>        syncLimit=5<br>        dataDir=/opt/zookeeper-data/<br>        clientPort=2181<br>　　tickTime：指定了ZooKeeper的基本时间单位（以毫秒为单位）；<br>　　initLimit：指定了启动zookeeper时，zookeeper实例中的随从实例同步到领导实例的初始化连接时间限制，超出时间限制则连接失败（以tickTime为时间单位）；<br>　　syncLimit：指定了zookeeper正常运行时，主从节点之间同步数据的时间限制，若超过这个时间限制，那么随从实例将会被丢弃；<br>　　dataDir：zookeeper存放数据的目录；<br>　　clientPort：用于连接客户端的端口。</p>
<h3 id="zookeeper存储模型"><a href="#zookeeper存储模型" class="headerlink" title="zookeeper存储模型"></a>zookeeper存储模型</h3><p>　　Zookeeper的存储结构采用的是结构化存储，很像数据结构当中的树，也很像文件系统的目录。树是由节点所组成，Zookeeper的数据存储也同样是基于节点，这里称之为znode。但是，不同于树的节点，Znode的引用方式是路径引用，类似于文件路径：/a/b。<br>　　Znode包含4个信息。<br>　　data:Znode存储的数据信息。<br>　　ACL:记录Znode的访问权限，哪些ip那些人可以访问本节点。<br>　　stat:包含Znode的各种元数据，比如事务id,大小，时间戳等。<br>　　child:当前节点的子节点引用。</p>
<h3 id="zookeeper的基本操作"><a href="#zookeeper的基本操作" class="headerlink" title="zookeeper的基本操作"></a>zookeeper的基本操作</h3><p>　　create：创建节点。<br>　　delete:删除节点。<br>　　exists:判断是否存在节点。<br>　　getData:获取一个节点的数据。<br>　　setData：设置一个节点的数据。<br>　　getChildren：获取节点下所有的子节点。<br>　　其中exist,getData.getChildren 都是读操作。客户端在请求读操作时可以设置是否watch（该效果是当Znode发生改变时，如增删改时，请求watch的客户端将会接收到异步通知，也就是说当一个节点被watch后，就会在对应的哈希表里面插入被watch的Znode路径以及watch列表）。</p>
<h3 id="zookeeper的一致性"><a href="#zookeeper的一致性" class="headerlink" title="zookeeper的一致性"></a>zookeeper的一致性</h3><p>　　Zookeeper身为分布式系统的协调服务，如果自身挂了怎么办呢？为了防止单机挂掉，ZooKeeper维护了一个集群。这个集群是一主多从结构。更新数据时，首先更新到主节点（这里的节点指的是服务器节点，不是Znode），再同步到从节点。为了保证主从节点数据一致性，zookeeper采用了ZAB协议。<br>　　ZAB协议定义了3种节点状态。<br>　　Looking:选举状态。<br>　　Following:从节点所处的状态。<br>　　Leading：Leader节点（主节点）所处的状态。<br>　　最大ZXID的概念：<br>　　最大ZXID也就是节点本地的最新事务编号，包含epoch和计数两部分。epoch是纪元的意思，相当于Raft算法选主时候的term。<br>　　从节点挂了没有任何影响。如果主节点挂了，那么集群就会进行崩溃恢复。分为３个阶段。<br>　　第一阶段，所有节点变成Looking状态。这些节点会各自向其他节点发起投票，投票信息包含自身服务器ID和最新事务ID.(ZXID)。接下来，节点会用自身的ZXID和从其他节点接受到的ZXID比较，如果别的节点比自己大，那就重新投票，投给接受到节点最大的ZXID的节点的票。<br>　　每次投完票后，服务器都会统计投票数量，判断是否存在半数以上的投票，如果存在这样的节点，那么这个节点将会成为准Leader节点，状态也会变成Leading，其他节点就会从Looking转换为Following。<br>　　第二阶段：发现阶段，用于在从节点中发现最新的ZXID和事务日志，因为可能存在Leader的ZIXD不一定是最新的，有可能意外情况，导致最新的ZXID不是最新的。<br>　　所以这个阶段，Leader集思广益，接收所有Follower发过来的epoch值，Leader从中选出最大的值，基于此值加一，生成最新的epoch分给各个Follower.各个Follower收到全新的epoch后，返回ACK给Leader，带上各自最大的ZXID和历史事务日志，Leader选出最大的ZXID,并更新自身历史日志。<br>　　第三阶段：同步阶段，将Leader刚接收到的最新历史事务日志，同步给集群所有的Follower。只有半数Follower同步成功，这个准Leader才能正式成为leader.</p>
<h3 id="zookeeper的数据写入"><a href="#zookeeper的数据写入" class="headerlink" title="zookeeper的数据写入"></a>zookeeper的数据写入</h3><p>　　<br>　　１．客户端发出写出请求给任意的Follower。<br>　　２．Follower把写入数据的请求转发给Leader。<br>　　３．Leader采用二段提交的方式，先发送Propose广播给Follower。<br>　　４．Follower接受到Propose消息，写入日志成功后，返回ACk消息给Leader。<br>　　５．Leader接到半数以上ACK消息，返回成功给客户端，并且广播Commit请求给Follower。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://skydh.github.io/2018/05/16/线程安全和锁优化/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="董航">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="why are you so happy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/16/线程安全和锁优化/" itemprop="url">线程安全和锁优化</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-16T11:52:32+08:00">
                2018-05-16
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="线程安全的实现方法"><a href="#线程安全的实现方法" class="headerlink" title="线程安全的实现方法"></a>线程安全的实现方法</h2><h3 id="互斥同步"><a href="#互斥同步" class="headerlink" title="互斥同步"></a>互斥同步</h3><p>　　这是个常见的并发正确性保障手段，同步是指多个线程并发访问数据时，该数据同一时刻只有一个线程使用，而互斥则是实现同步的方式之一，临界区，互斥量，信号量都是实现互斥的方式。互斥是方法，同步是目的。<br>　　在java中，实现同步的方式是synchronized关键字。这个关键字需要一个对象参数，来指明要锁住的对象，如果没有明确指定，那就根据synchronized修饰的实例方法或者类方法来取得相应的对象实例或者Class对象作为锁对象。获取到锁对象时，把锁的计数器加一，退出时把锁的计数器减一。前面说过java的线程是映射到操作系统的原生线程上的，如果阻塞和唤醒其他线程，都需要操作系统帮忙。需要从用户态转换到核心态，这种状态转换会很消耗时间，因此这个关键字是重量级操作。当然虚拟机自身也做了锁优化。<br>　　出了synchronized这个关键字，还可以使用java.util.concurrent包下的重入锁来实现同步。特性都一样，都具有线程重入性，但是代码上有些区别，一个是API曾变的互斥锁，lock(),unlock()配合try finally使用，一个是原生语法上的，但是相对于synchronized，多了些特性：<br>　　１．等待可中断：当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃，改为处理其他事情。<br>　　２．公平锁，指的是多个线程等待同一个锁时，必须按照申请锁的时间顺序来获取锁，但是非公平的不是按照时间申请顺序来的，他是随机的，synchronized是非公平的，ReentrantLock默认也是非公平的，但是可以通过构造函数来改变。<br>　　３．锁绑定多个条件：一个ReentrantLock对象可以绑定多个Condition对象，但是synchronized的wait和notify是一对一的<br>　　性能对比：<br>　　在jdk1.5，synchronized关键字效率比ReentrantLock要低，随之线程数目的增多，但是在1.6之后，2者就差不多了。</p>
<h3 id="非阻塞同步"><a href="#非阻塞同步" class="headerlink" title="非阻塞同步"></a>非阻塞同步</h3><p>　　上面的都是阻塞同步，阻塞同步是悲观的并发策略，认为不加锁，一定会出现问题。而非阻塞则是乐观加锁，先操作。如果没有线程冲突，成功，有冲突，不断重试。但是这个需要硬件指令的原子操作才能完成。现代处理器出现了　CAS（比较并交换）这是一个原子操作。来帮助实现了非阻塞加锁。就是需要写入时，先比较这个值是否变化，若是没变化就写，有变化不写。<br>　　在jdk1.5之后，java才可以，比如原子类之类的，里面的加减操作都是原子操作。就是，对这个变脸不加锁，谁用都可以，但是你要写入的时候，就要对比，是不是你原来读取的旧值，是的话就写入，不是，就不写入，当然这是针对自身的值变化操作，比如自增之类的。当然这个还是有bug的，比如ABA问题。前面的文章写过了，这里就不多说了。但是JUC包加了一个带标记的原子引用类，来控制变量的版本来保证CAS的正确性，当然，如果可能发生ABA，那么还不如用互斥同步操作来的高效。</p>
<h2 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h2><p>　　在JDK1.6有个重大改进，就是虚拟机实现了大量的锁优化技术，比如，适应性自旋，锁清楚，锁粗化，轻量级锁，偏向锁等。</p>
<h3 id="自旋锁和自适应锁"><a href="#自旋锁和自适应锁" class="headerlink" title="自旋锁和自适应锁"></a>自旋锁和自适应锁</h3><p>　　我们在前面说到，同步互斥对性能最大的影响是阻塞的实现，因为阻塞需要将操作转到内核去完成，这些操作很耗时，也对系统的并发性能有压力。但是虚拟机开发团队发现，共享数据的锁只会持续很短的一段时间。为了这么短的时间去挂起和恢复线程划不来。自旋锁就是如果物理机器上有１个以上的处理器，能让２个以上的线程并行执行，我们可以让后面请求锁的线程稍等一下，但是不放弃处理器的执行时间，看看持有锁的线程是否释放锁，我们只需要让线程执行一个忙循环（自旋），这就是自旋锁。<br>　　自旋锁不能代替同步阻塞，１，处理器数量，２，占用处理器时间。但是如果锁占用时间极短，那么自旋效果就很好了，如果时间长，就不好了，因此要设置一个值，来判断自旋次数，如果在次数内，没话说，超过次数了，那么就只能按照传统的方式去挂起线程了，默认是１０次，可以通过参数修改。<br>　　在ＪＤＫ１．６之后引入了自适应自旋锁。自适应那就是说时间不固定了，由前一次同一个锁上的自旋时间以及锁的拥有者的状态决定的，如果同一个锁对象，自旋刚成功过，那么虚拟机认为这次自旋也可能成功，进而允许自旋锁自旋更长的时间。如果一个锁自旋很少成功，那么虚拟机可能自动忽略这个自旋过程。</p>
<h3 id="锁清除"><a href="#锁清除" class="headerlink" title="锁清除"></a>锁清除</h3><p>　　就是对一些代码上要求同步，但是被检测到不可能存在共享数据存在数据竞争的锁进行消除。</p>
<h3 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h3><p>　　原则上，建议同步块的作用范围越小越好，但是也有例外。就是对同一个对象反复加锁和解锁，甚至加锁操作是出现在循环体中。</p>
<h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><p>　　传统的互斥锁就是重量级锁，轻量级锁不是来代替重量级锁的，他的本意是在没有多线程竞争的前提下，减少传统重量级锁使用操作系统互斥量产生的性能消耗。<br>　　这就涉及到对象头了，对象头分为２部分信息，第一部分是存储对象自身运行时数据，一部分是指向方法区对象类型的指针。第一部分有个锁标志位，当代码进入到同步块时，如果该对象没有被锁定，虚拟机将在当前线程的栈帧里面建立一个锁空间，用于存放目前对象的对象头的第一部分的ｃｏｐｙ称为Lock Record，然后将这个对象头的第一部分跟新为指向Lock Record的指针，且锁标志位跟新为00，,如果失败就是被其他线程抢占了，如果有2个以上的线程争取一个锁，那么轻量级锁无效。<br>　　其实就是在无竞争的情况下用ＣＡＳ来消除互斥量。</p>
<h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p> 　　意思就是如果该锁没有被其他线程获取，那持有偏向锁的线程永远不需要同步。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>　　偏向锁、轻量级锁、用于不同的并发场景：<br>　　偏向锁：无实际竞争，且将来只有第一个申请锁的线程会使用锁。<br>　　轻量级锁：无实际竞争，多个线程交替使用锁；允许短时间的锁竞争</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/6/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><span class="page-number current">7</span><a class="page-number" href="/page/8/">8</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><a class="extend next" rel="next" href="/page/8/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">董航</p>
              <p class="site-description motion-element" itemprop="description">clear 航</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">117</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            

          </nav>

          

          <div class="links-of-author motion-element">
            
          </div>

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">董航</span>

  
</div>


<div class="powered-by">
<i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv">
  本站访客数:<span id="busuanzi_value_site_uv"></span>
</span>
</div>

  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.3</div>




        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.3"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
