<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="clear 航">
<meta property="og:type" content="website">
<meta property="og:title" content="why are you so happy">
<meta property="og:url" content="https://skydh.github.io/page/10/index.html">
<meta property="og:site_name" content="why are you so happy">
<meta property="og:description" content="clear 航">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="why are you so happy">
<meta name="twitter:description" content="clear 航">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://skydh.github.io/page/10/"/>





  <title>why are you so happy</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">why are you so happy</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">clear 航</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://skydh.github.io/2018/03/12/mybatis简介/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="董航">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="why are you so happy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/12/mybatis简介/" itemprop="url">mybatis简介</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-12T11:26:20+08:00">
                2018-03-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="优点和缺点"><a href="#优点和缺点" class="headerlink" title="优点和缺点"></a>优点和缺点</h2><p>　　sql和代码分离，利于管理和优化，但是sql代码量大，有些不好处理。MyBatis支持普通sql查询，存储过程，高级映射，其消除了所有的JDBC代码和参数的手工设置以及结果集的检索，使用简单的XML和注解来配置映射关系。恩，还有动态sql,避免了sql注入。</p>
<h2 id="mybatis缓存机制"><a href="#mybatis缓存机制" class="headerlink" title="mybatis缓存机制"></a>mybatis缓存机制</h2><p>　　Mybatis缓存是分为2级缓存。<br>　　一级缓存是一个sqlSession级别的。就是一个sqlSession里面sql和参数一样的sql就会从从缓存里面取出来，默认开启。<br>　　二级缓存：，多个SqlSession使用同一个Mapper的sql语句去操作数据库，得到的数据会存在二级缓存区域，它同样是使用HashMapper进行数据存储，相比一级缓存SqlSession，二级缓存的范围更大，多个SqlSession可以共用二级缓存，二级缓存是跨SqlSession的。默认不开启</p>
<p><pre><br>    mybatis-config<br>    <settings><br>        <setting name="cacheEnabled" value="true"><br>    </setting></settings><br>    <!-- 开启当前mapper的namespace下的二级缓存 --><br>    <cache eviction="LRU" flushinterval="60000" size="512" readonly="true"><br></cache></pre><br>　　对于缓存数据更新机制，当某一个作用域(一级缓存Session/二级缓存Namespaces)的进行了 C/U/D 操作后，默认该作用域下所有 select 中的缓存将被clear。</p>
<h2 id="和-的区别是什么？"><a href="#和-的区别是什么？" class="headerlink" title="#{}和${}的区别是什么？"></a>#{}和${}的区别是什么？</h2><p>   第一个是解析传递进来的参数数据，是预编译处理，<br>第二个是对传递进来的参数原样拼接在SQL中，是字符串替换。<br>使用#{}可以有效的防止SQL注入，提高系统安全性。<br>看看案例实现</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://skydh.github.io/2018/03/11/spring mvc简介/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="董航">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="why are you so happy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/11/spring mvc简介/" itemprop="url">spring mvc介绍和demo</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-11T15:07:15+08:00">
                2018-03-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>　　DispatcherServlet:这个就类似于前端分发器。用于分发前端的请求到具体的Controller。然后获取数据到前端。<br>　　Controller:就是控制层。<br>　　HandlerAdapter:Handler是DispacherServlet使用的，是controller的一个表现形式。我们的DispatcherServlet调用Controller就是以调用Handle来调用的，而HanDlerAdapter则是将不同类型的类适配为我们这个DispacherServlet可以使用的类。<br>　　handleInterceptor:就是拦截器，就是在Handle上加上一些拦截器。<br>　　HandleMapping：顾名思义，Handle是DispacherServlet调用Controller的一个过渡中间对象，那么这个就是前段访问对应那个Controller。以及这个Controller的拦截器。<br>　　HandlerExecutionChain:调用的Controller按照拦截器的模式前置拦截，以及后置拦截器等拦截器的链条。<br>　　ModelAndView:这就是model的显示类型。<br>　　ViewResolve：视图解析器。根据配置找到确切的视图对象告诉DispacherServlet。<br>　　View：界面显示。<br><img src="https://raw.githubusercontent.com/skydh/picture/master/springmvc.png" alt="aaa"><br><img src="https://raw.githubusercontent.com/skydh/picture/master/springmvc2.png" alt="aaa"><br>　　请求从浏览器发送经过DispacherServlet的HandleMapping找到对应的Controller以及其拦截器。从而生成一个Handle给DispacherServlet，让其调用，生成一个model就是数据模型，然后DispacherServlet调用ViewResolve找到view，吧数据model注入进去，并且把这个view返回给Response。</p>
<h2 id="配置解析"><a href="#配置解析" class="headerlink" title="配置解析"></a>配置解析</h2><p>　　web.xml文件解析。<br>　　这个文件是用来加载初始化信息的，当服务容器开始启动时，先加载web.xml文件。里面的元素配置信息加载顺序为：context-param&gt;listener&gt;filter&gt;servlet<br>　　第一步，获取到context-param的值，然后创建这个web项目的上下文，然后创建listener的实例，从而获取到相关信息。最后则是加载filter的实例。<br>　　web.xml文件启动大致分为2个部分。<br>　　ContextLoad而Listener的初始化，实例化话ioc,并且将这个ioc注册到application中。<br>　　DispacherServlet的初始化。<br>　　我们知道Spring容器加载配置文件后，会生成一个上下文，而springmvc加载配置文件后也会生成一个上下文，为什么这样划分呢？？？这样的，我们的应用可能给不同类型的人分发请求，那么就会有多个DispacherServlet，呢么就有多个上下文，而spring的上下文则是公共的，那么就会少加载初始化一些类。</p>
<h2 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h2><p><img src="https://raw.githubusercontent.com/skydh/picture/master/spring-mvc.png" alt="aaa"><br>　　这里配置多个拦截器如下所示。<br><img src="https://raw.githubusercontent.com/skydh/picture/master/spring-mvc1.png" alt="aaa"></p>
<h2 id="demo样例"><a href="#demo样例" class="headerlink" title="demo样例"></a>demo样例</h2><p>　　可以自己下载运行调试。<br>　　<a href="https://github.com/skydh/spring-mvc-test.git" target="_blank" rel="noopener">点我一下就到了</a></p>
<p>　　</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://skydh.github.io/2018/03/02/消息中间件/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="董航">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="why are you so happy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/02/消息中间件/" itemprop="url">java消息中间件入门</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-02T10:55:54+08:00">
                2018-03-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="消息中间件来解耦服务调用"><a href="#消息中间件来解耦服务调用" class="headerlink" title="消息中间件来解耦服务调用"></a>消息中间件来解耦服务调用</h2><p>　　比如１个登录系统，登录的话需要调用很多系统的其他服务，如果中间调用失败，可能会导致登录信息一致无法返回，同时也增加了系统的耦合度。而用消息中间件的话，则是不发送服务到其他系统，而是发送服务到消息中间件，发完消息就直接返回结果，完美。而消息中间件则是自己吧消息发送给那些服务。</p>
<h2 id="什么是中间件"><a href="#什么是中间件" class="headerlink" title="什么是中间件"></a>什么是中间件</h2><p>　　非底层操作系统软件。非业务应用软件，不是直接给用户的，不能给客户带来直接价值的软件叫中间件。</p>
<h2 id="什么是消息中间件"><a href="#什么是消息中间件" class="headerlink" title="什么是消息中间件"></a>什么是消息中间件</h2><p>　　关注与数据的发送和接受，利用高效可靠的异步消息传递机制集成分布式系统。</p>
<h2 id="什么是JMS"><a href="#什么是JMS" class="headerlink" title="什么是JMS"></a>什么是JMS</h2><p>　　java消息服务即是JMS,是一个java平台中关于面向消息中间件的API,用于2个程序啊件进行异步通信。就是一个规范。</p>
<h2 id="什么是AMQP"><a href="#什么是AMQP" class="headerlink" title="什么是AMQP"></a>什么是AMQP</h2><p>　　一个提供统一消息服务的应用层标准高级消息队列协议,是应用层协议的一个开放标准,为面向消息的中间件设计。和JMS想对。</p>
<h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>　　第一步，下载安装activemq,第二步，编写发送端和接收端。<br>　　下载后可以修改这个消息队列的配置文件，来修改持久化方式，有文件持久化，数据库持久化等。发送端发送消息给消息队列，接收端从消息队列中获取消息。有２个方式来消费消息，一个是队列方式，一个是主体模式。队列模式就是现有的消费者们平均或者按照一定规则消费队列里面的消息。主题模式则是每个消费者完整的消费消息队列里面的消息。<br>　　这里写了一个案例来显示<br>　　生产者代码</p>
<p><pre><br>    public class Producer {<br>        public static final String url = “tcp://127.0.0.1:61616”;<br>        public static final String queueName = “dh-test-queue”;<br>        public static void main(String[] args) throws JMSException {<br>            ConnectionFactory connectionFactory = new ActiveMQConnectionFactory(url);<br>            Connection connection = connectionFactory.createConnection();<br>            connection.start();<br>            Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);<br>            Destination destination = session.createQueue(queueName);<br>            MessageProducer mp = session.createProducer(destination);<br>            for (int i = 0; i &lt; 100; i++) {<br>                TextMessage textMessage = session.createTextMessage(“test” + i);<br>                mp.send(textMessage);<br>                System.out.println(“发送消息” + textMessage.getText());<br>            }<br>            connection.close();</pre></p>
<pre><code>}
</code></pre><p><br>　　这个是先根据url生成一个连接工厂，然后根据这个工厂类生成一个连接。然后根据这个连接创建一个session，然后根据这个session创建一个目的地，这个就是消息队列上你的消息队列的名字，然后根据session和这个目的地，创建一个消息发送者，就可以发送消息到消息队列了。</p>
<p>　　消费者代码</p>
<p><pre><br>    public class ConsumerApp {<br>        public static final String url = “tcp://127.0.0.1:61616”;<br>        public static final String queueName = “dh-test-queue”;<br>        public static void main(String[] args) throws JMSException {<br>            ConnectionFactory connectionFactory = new ActiveMQConnectionFactory(url);<br>            Connection connection = connectionFactory.createConnection();<br>            connection.start();<br>            Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);<br>            Destination destination = session.createQueue(queueName);<br>            MessageConsumer mc= session.createConsumer(destination);<br>            mc.setMessageListener(new MessageListener() {<br>                @Override<br>                public void onMessage(Message message)<br>                    TextMessage textMessage=(TextMessage) message;<br>                    try {<br>                        System.out.println(textMessage.getText());<br>                    } catch (JMSException e) {<br>                        // TODO Auto-generated catch block<br>                        e.printStackTrace();<br>                    }<br>                }<br>            });<br>            //connection.close();</pre></p>
<pre><code>}
</code></pre><p><br>　　前面代码都大致一样，后面不同的就是根据session和目的地生成一个消费者，然后用这个消费者调用一个监听器持续监听来自消息队列的消息，从而获取消息。</p>
<h2 id="rabbitmq"><a href="#rabbitmq" class="headerlink" title="rabbitmq"></a>rabbitmq</h2><h3 id="生产者到消息队列确认机制，以及为何发生消息重复"><a href="#生产者到消息队列确认机制，以及为何发生消息重复" class="headerlink" title="生产者到消息队列确认机制，以及为何发生消息重复"></a>生产者到消息队列确认机制，以及为何发生消息重复</h3><p>　　定义几个概念：<br>　　A=生成者-&gt;消息队列,发送消息到消费者。<br>　　B=消息队列加入消息持久化，<br>　　C=消息队列-&gt;生产者。回复ack，<br>　　D=消息队列-&gt;消费者，发送消息到消费者。<br>　　E=消费者-&gt;消息队列，回复ack，<br>　　F=消息队列删除消息，持久化。<br>　　基本可以分为这几个步骤。<br>　　１.第一个是前３个回合。<br>　　生产端要维护一个消息发送的表，消息发送的时候记录消息id，这个消息id是消息队列自己生产的id,唯一。在消息成功落地broker磁盘并且进行回调确认（ack）的时候，根据本地消息表和回调确认的消息id进行对比，然后删除。如果这个表里面存在没有收到ack的消息，且超时了，那么生产者会再次发送。且消息id不变。<br>　　我们分析，前面３个步骤Ａ，Ｂ，Ｃ无论哪个出了问题，生产者都没有收到ack,那么都会发送再次发送消息到消息队列，那么势必造成重复，但是消息队列对这个做了去重处理，根据消息id.<br>　　第二个回合就是后面３个回合了。<br>　　对于消息队列来说，必须收到ack，我才会进行进行删除，不然我会持续发送，但是存在一个情况就是E的时候网络断了，但是消息是确实消费了，消息队列却没有删除，再次消费，则会造成消息重复，这个需要我们自己去处理。<br>　　因此第一个回合消息是幂等的，第二个回合消息不是幂等的。</p>
<h3 id="四种交换机"><a href="#四种交换机" class="headerlink" title="四种交换机"></a>四种交换机</h3><p>　　１．扇形交换机<br>　　广播模式，将消息发送到绑定到该交换机的所有队列上。<br>　　２．直连交换机<br>　　每个队列绑定到一个交换机上面，同时有个routing_key对应这个队列到交换机。同时消息也携带一个routing_key。交换机根据这个routing_key将消息指定到对应队列里面。如果希望一个消息发送到多个队列里面，那么就要发送多次.这里面的routing_key是写死的，比如某个队列绑定到交换机的routing_key=back,那么携带back的消息就会被路由分配到这个队列里面。<br>　　３．主题交换机<br>　　这个是上面直连交换机的加强版。不过routing_key加强了，可以用一部分规则了。规则如下。*：一个单词。#：任意单词。我们队列的routing_key=com.hehe.#，那么任何以com.hehe开头的消息都会被分配到这里。<br>　　４．首部交换机<br>　　首部交换机个人觉得类似于主题交换机，只不过规则变了，是基于hash了，队列和交换机绑定的时候声明一个hash数据结构，当消息发送的时候，会携带一个hash数组，然后进行匹配，如果匹配成功就会写入到相对应的队列。</p>
<h2 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h2><p>　　为了保证rabbitMq的可靠性，保证消息的可靠性。需要将quene,exchange,message都持久化。</p>
<p>　　quene持久化就是将quene的持久化标示设置为true,当服务重启后，之前存在quene会被重洗放到rabbitmq里面。</p>
<p>　　message持久化：quene持久化，如果message不持久化，那么重启后quene里面的没消费的消息会丢失。设置了队列和消息的持久化之后，当broker服务重启的之后，消息依旧存在。单只设置队列持久化，重启之后消息会丢失；单只设置消息的持久化，重启之后队列消失，既而消息也丢失。单单设置消息持久化而不设置队列的持久化显得毫无意义。<br>　　exchange持久化：这个持久化与否没什么影响，但是建议持久化，不然重启后交换机就会丢失。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>　　大致了解了一些消息队列，以及做出了一个简单demo，目前没有用到，用到在细看。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://skydh.github.io/2018/03/02/spring aop/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="董航">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="why are you so happy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/02/spring aop/" itemprop="url">浅析spring aop</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-02T10:54:52+08:00">
                2018-03-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="解决了什么"><a href="#解决了什么" class="headerlink" title="解决了什么"></a>解决了什么</h2><p>　　１，解决了代码的重复度。<br>　　２，业务分离，就是把非业务代码抽离出来，可以集中管理，增加了可维护性。（比如缓存控制，事务控制，日志，权限，异常等）。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://skydh.github.io/2018/02/24/spring ioc/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="董航">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="why are you so happy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/24/spring ioc/" itemprop="url">spring ioc浅析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-24T17:03:22+08:00">
                2018-02-24
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="什么是ioc"><a href="#什么是ioc" class="headerlink" title="什么是ioc"></a>什么是ioc</h2><p>　　IOC是spring这个轻量级框架的核心内容，中文叫做控制反转。也叫作依赖注入，这里我们将其看作为一个概念。普通获取类对象时是我们主动获取也就是主动去new。但是IOC则是让我们不用去new这个对象直接去获取，因为我们想要得到这个对象也是调用这个对象所对应的服务。无论这个对象时容器给我们的还是我们自己new的都行。容器给我们的话就会方便很多，也利于管理和维护。</p>
<h2 id="3种注入方法"><a href="#3种注入方法" class="headerlink" title="3种注入方法"></a>3种注入方法</h2><p>　　构造方法注入：就是被注入对象可以通过在其构造方法中声明依赖对象的参数列表让spring容器知道它需要哪些依赖对象。<br>　　setter方法注入，通过其对应的setter方法来注入，更加灵活点。<br>　　接口注入：被注入对象想要spring为其注入依赖对象必须要实现某个接口，这个接口提供一个方法用来为其注入依赖对象。</p>
<h2 id="IOC-service-privider"><a href="#IOC-service-privider" class="headerlink" title="IOC service privider"></a>IOC service privider</h2><p>　　作用是对象的构建管理以及其对象之间的相互依赖<br>　　这个是如何管理对象之间的相互依赖呢？<br>　　１.直接编码<br>　　在容器启动前，我们通过代码的形式将被注入对象和依赖对象注册到容器中，并且明确它们之间的依赖注入关系。<br>　　２．配置文件方式<br>　　我们可以通过spring的配置文件来完成对象之间的关联，在容器启动时在加载到容器中。<br>　　３.元数据方式<br>　　这个是java1.5之后的元数据结合的，个人觉得也是直接代码但是多了元数据这个方便的用法。</p>
<h2 id="Spring-的ICO-Service-Privider"><a href="#Spring-的ICO-Service-Privider" class="headerlink" title="Spring 的ICO Service Privider"></a>Spring 的ICO Service Privider</h2><p>　　Spring ICO容器包含了IOC Service Privider,AOP,线程管理等很多方面。因为他还是个容器。<br>　　Spring ICO容器有2个类型：<br>　　BeanFactory：基础类型的IOC容器，提供基本的IOC支持，默认为延迟加载机制，也就是只有当客户端对象需要访问容器里面的对象时才对受管理的对象进行初始化和注入操作，因此容器启动较快。<br>　　ApplicationContext：这个是在BeanFactory的基础上构建的，是相对其高级的实现，提供了一些额外的高级特性。其这个容器在启动时会初始化加载绑定所有托管的对象。因此启动较慢。继承了BeanFactory这个接口。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://skydh.github.io/2018/02/24/tomcat 浅析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="董航">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="why are you so happy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/24/tomcat 浅析/" itemprop="url">Tomcat浅析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-24T15:31:37+08:00">
                2018-02-24
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Tomcat结构"><a href="#Tomcat结构" class="headerlink" title="Tomcat结构"></a>Tomcat结构</h2><p>　　Tomcat最顶层的容器叫做server。代表整个服务器，Server中至少包含一个Service用于提供服务。而Service主要包含以下2个。Connector：用于处理连接相关的事情，且提供Socket和request，response的装换。<br>　　Container则是用于封装和管理Servlet以及具体处理request请求。一个Tomcat只能有一个Server，一个Server可以包含多个Service，一个Service中只有一个Container，但是可以有多个Connectors（因为一个服务可以有多个连接）。<br>　　Tomcat中的管理类是Catalina,它用来管理Server。其有3个方法来管理Server的整个生命周期。<br>　　load方法用于根据conf/server.xml文件创建Server并调用Server的init方法来进行初始化。<br>　　start方法用于启动服务器。stop方法用于停止服务器。这些方法会逐层调用其下级的方法来启动整个服务器。比如，Server的stat方法调用所有的Service的stat方法，Service的stat方法调用Connectors和Container的stat方法。<br>　　Tomcat的入口main不在CatAlina类里。在BootStrap里。</p>
<h2 id="tomcat启动过程"><a href="#tomcat启动过程" class="headerlink" title="tomcat启动过程"></a>tomcat启动过程</h2><h3 id="BootStrap"><a href="#BootStrap" class="headerlink" title="BootStrap"></a>BootStrap</h3><p>　　启动Tomcat就是调用BootStrap的main方法。在这个main方法里面主要做了这么几个事情。新建BootStrap实例，然后赋值给catalinaDaemon变量。然后根据不同命令不同操作。<br>　　start:调用了3个方法setAwaut(true),load(args),start().这3个方法内部都会调用相应的Catalina进行具体处理执行。<br>　　Stop:调用StopServer方法。</p>
<h3 id="Catalina"><a href="#Catalina" class="headerlink" title="Catalina"></a>Catalina</h3><p>　　可以看到Catalina是上面BootStrap的3个方法来启动的，setAwait设置Server启动后是否进入等待状态（true是，false不是）。load方法用来加载配置文件。创建并且初始化Server，Start方法用来启动服务器。在这个方法里面主要是调用了server的start方法来启动服务器。</p>
<h3 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h3><p>　　Server接口包含了一个个的serveice，因此在server中，提供了addService(Service service),removeService(Service service)来添加和删除service。server的init，start方法则是循环调用了每个Service的init，start方法。来启动所有的service。<br>　　Server默认实现是StandardServer，StandardServer的上级父类有LifeCycleBase的类，init,start方法就定义在这个类里面，这个类的init和start方法调用的是initInternal方法和startinternal方法，而这2个方法是模板方法，由子类具体实现，因此调用StandardServer的init，stat方法就是执行StandardServer的initInternal方法和startinternal方法，而在<br>　　StandardServer的initInternal方法和startinternal方法中分别循环调用了每一个Service的start和init方法。在StandardServer实现了await方法，让服务器进入等待状态。</p>
<h3 id="service"><a href="#service" class="headerlink" title="service"></a>service</h3><p>　　Service的默认实现是StandardService。而这个类也继承了LifeCycleBase这个类，因此其init和stat方法最终也会调用其自身的initInternal方法和startinternal方法。在initInternal方法和startinternal方法的实现中，其主要是调用了其containner(容器)，executors(线程池)，mapperListener是Mapper的监听器，可以监听container的变化。connectors(连接器)的init和start方法。</p>
<h2 id="tomcat生命周期"><a href="#tomcat生命周期" class="headerlink" title="tomcat生命周期"></a>tomcat生命周期</h2><p>　　tomcat通过Lifecycle接口统一管理生命周期，所有生命周期组件都要实现这个接口。<br>　　做了４件事。<br>　　１．定义了１３个String类型的常量，用于LifecycleEvent事件的type属性中，作用是区分组件发出的lifecycleEvent事件的状态。<br>　　２．定义了3个管理监听器方法：addLifecycleListener,findLifecycleListener,removeLifecycleListener,用来添加，查找，删除LifecycleListener类型的监听器。<br>　　３．定义了４个生命周期的方法init,start,stop,destroy,用于执行生命周期的各个阶段的操作。<br>　　４．定义了getState,getStateName,用来获取当前状态，getState的返回值是LifecycleState的枚举类型。里面列举了生命周期的各个节点。而getStateName则是返回String类型的状态的名字。<br>　　lifecycle的默认实现是LifecycleBase,所有实现了生命周期的组件基本都是直接或者间接继承这个类，其为接口Lifecycle的接口方法都给了实现。<br>　　监听器的管理是LifecycleSupport类完成的，其定义了一个LifecycleListenner数组属性来保存所有的监听器。然后定义了添加，删除，查找，执行监听器的方法；</p>
<h2 id="Container简述"><a href="#Container简述" class="headerlink" title="Container简述"></a>Container简述</h2><p>　　容器：存放编写的代码。分为四层容器。<br>　　１．Wrapper:对应一个Servlet。<br>　　２．Context:对应一个应用。<br>　　３．Host：对应一个站点。<br>　　４．Engine对应引擎。每个service只有一个Engine。</p>
<h2 id="Connector简述"><a href="#Connector简述" class="headerlink" title="Connector简述"></a>Connector简述</h2><p>　　负责处理网络连接相关的事情，比如，Socket连接，将其根据HTTP协议，TCP/IP协议封装为Request,Response来具体处理，将其交给Container进行处理，Container就是Servlet的容器。Container处理完就返回给Connector,而Connector使用Socket将处理结果返回给客户端。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://skydh.github.io/2018/02/24/java nio/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="董航">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="why are you so happy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/24/java nio/" itemprop="url">java NIO.</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-24T09:15:41+08:00">
                2018-02-24
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="阻塞和非阻塞"><a href="#阻塞和非阻塞" class="headerlink" title="阻塞和非阻塞"></a>阻塞和非阻塞</h2><p>　　阻塞是函数没有返回结果就一直等待，知道得到返回结果。非阻塞则是函数没有返回结果自己不用等待可以去干别的事情，这是函数内部的的实现区别，也就是函数未就绪时是直接返回结果。
　　</p>
<h2 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h2><p>　　同步是指主动请求并且等待结果。当数据就绪后在读写时必须阻塞，异步则是请求到数据后可以继续处理其他任务，随后等待结果，这可以使得进程读写时不阻塞。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>　　所以说，阻塞，非阻塞和同步，异步是不一样的概念，阻塞和非阻塞是函数的实现方式就是未就绪时是否直接返回结果，阻塞和非阻塞在程序中也算是同步的，而异步则是不管是不是直接返回结果，我都可以干别的事，等到返回结果再处理。</p>
<h2 id="java-NIO"><a href="#java-NIO" class="headerlink" title="java NIO"></a>java NIO</h2><p>　　java的最初io流是阻塞的BIO流,不适合于多连接的处理情况。因为多个连接就要多个线程。而NIO的出现解决了这个问题。而且NIO的操作方式类似于操作系统，因此效率会更加高一些。<br>　　io的操作是基于字节流和字符流，是单向的比如inputStreanm，只能读，而NIO则是基于Channel和Buffer，是双向，比如Channel是双向的既可以用来读也可以来写。<br>　　NIO是非阻塞的，IO则是阻塞的，一个线程调用read()方法时，如果没有操作完，该线程就会一直阻塞。对于这个线程而言，这时他不能干别的事了，因为程序时顺序执行的。NIO则是不一样的，无论是读取数据还是写入数据都不会使得这个线程阻塞下去。可以继续干自己的事情。</p>
<h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><p>　　直接代码示例吧，具体的Channel，Buffer，Selector的用法可以查询java官方api。</p>
<p>　　这里直接上几个代码案例，直接对比。</p>
<p><pre><br>public class Test {</pre></p>
<pre><code>public static void main(String[] args) throws Exception {
    File file = new File(&quot;data.txt&quot;);
    FileInputStream fileOutputStream = new FileInputStream(file);
    FileChannel fileChannel = fileOutputStream.getChannel();
    ByteBuffer byteBuffer = ByteBuffer.allocate(10);
    // String string = &quot;nio test&quot;;
    int a = fileChannel.read(byteBuffer);
    System.out.println(a);

    while (a != -1) {
        byteBuffer.flip();
        while (byteBuffer.hasRemaining()) {
            System.out.print((char) byteBuffer.get());
        }
        byteBuffer.compact();
        a = fileChannel.read(byteBuffer);
    }
}
</code></pre><p>}<br><br>　　这个代码是读取一个文件，并且运用NIO的方式输出出来。有了大概的印象，那么我们来看看在socket中，这些操作时怎么处理的，非阻塞机制到底怎么提高了这个的优化效率。<br>　　第一个是ｉｏ的服务器</p>
<p><pre><br> public class Snippet {<br>    public static void main(String[] args) {<br>        ServerSocket serverSocket = null;<br>        InputStream in = null;<br>        try {<br>            serverSocket = new ServerSocket(8088);<br>            int recvMsgSize = 0;<br>            byte[] recvBuf = new byte[1024];<br>            while (true) {<br>                Socket clntSocket = serverSocket.accept();<br>                SocketAddress clientAddress = clntSocket.getRemoteSocketAddress();<br>                System.out.println(“Handling client at “ + clientAddress);<br>                in = clntSocket.getInputStream();<br>                while ((recvMsgSize = in.read(recvBuf)) != -1) {<br>                    byte[] temp = new byte[recvMsgSize];<br>                    // System.arraycopy(recvBuf, 0, temp, 0, recvMsgSize);<br>                    System.out.println(new String(temp));<br>                }<br>            }<br>        } catch (IOException e) {<br>            e.printStackTrace();<br>        } finally {<br>            try {<br>                if (serverSocket != null) {<br>                    serverSocket.close();<br>                }<br>                if (in != null) {<br>                    in.close();<br>                }<br>            } catch (IOException e) {<br>                e.printStackTrace();<br>            }<br>        }<br>    }<br>}</pre></p>
<p><br>　　客户端代码直接用ＮＩＯ的模式写吧</p>
<p><pre><br> public class NioClient {<br>    public static void main(String[] args) {<br>        ByteBuffer buffer = ByteBuffer.allocate(1024);<br>        SocketChannel socketChannel = null;<br>        try {<br>            socketChannel = SocketChannel.open();<br>            socketChannel.configureBlocking(false);<br>            socketChannel.connect(new InetSocketAddress(“127.0.0.1”, 8088));<br>            System.out.println(“aaa”);</pre></p>
<pre><code>        if (socketChannel.finishConnect()) {
            int i = 0;
            while (i&lt;10) {
                TimeUnit.SECONDS.sleep(1);
                String info = &quot;I&apos;m &quot; + i++ + &quot;-th information from client&quot;;
                buffer.clear();
                buffer.put(info.getBytes());
                buffer.flip();
                while (buffer.hasRemaining()) {// 判断是否数据读完
                    System.out.println(buffer);
                    socketChannel.write(buffer);
                }
            }
        }
    } catch (IOException | InterruptedException e) {
        e.printStackTrace();
    } finally {
        try {
            if (socketChannel != null) {
                socketChannel.close();
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
</code></pre><p>}</p>
<p><br>　　假设服务器是这种代码，客户端有多个连接到来，那么一次只能连接一个，直到用完，或许有的小伙伴说，多线程啊，每个线程一个连接，线程池管理。恩，但是线程太消耗资源，而且线程转换也会消耗资源。那么ｎｉｏ来了，我们来看看Ｎｉｏ的实现。</p>
<pre><code>public class ServerConnect
{
    private static final int BUF_SIZE=1024;
    private static final int PORT = 8080;
    private static final int TIMEOUT = 3000;

    public static void main(String[] args)
    {
        selector();
    }

    public static void handleAccept(SelectionKey key) throws IOException{
        ServerSocketChannel ssChannel = (ServerSocketChannel)key.channel();
        SocketChannel sc = ssChannel.accept();
        sc.configureBlocking(false);
        sc.register(key.selector(), SelectionKey.OP_READ,ByteBuffer.allocateDirect(BUF_SIZE));
    }

    public static void handleRead(SelectionKey key) throws IOException{
        SocketChannel sc = (SocketChannel)key.channel();
        ByteBuffer buf = (ByteBuffer)key.attachment();
        long bytesRead = sc.read(buf);
        while(bytesRead&gt;0){
            buf.flip();
            while(buf.hasRemaining()){
                System.out.print((char)buf.get());
            }
            System.out.println();
            buf.clear();
            bytesRead = sc.read(buf);
        }
        if(bytesRead == -1){
            sc.close();
        }
    }

    public static void handleWrite(SelectionKey key) throws IOException{
        ByteBuffer buf = (ByteBuffer)key.attachment();
        buf.flip();
        SocketChannel sc = (SocketChannel) key.channel();
        while(buf.hasRemaining()){
            sc.write(buf);
        }
        buf.compact();
    }

    public static void selector() {
        Selector selector = null;
        ServerSocketChannel ssc = null;
        try{
            selector = Selector.open();
            ssc= ServerSocketChannel.open();
            ssc.socket().bind(new InetSocketAddress(PORT));
            ssc.configureBlocking(false);
            ssc.register(selector, SelectionKey.OP_ACCEPT);

            while(true){
                if(selector.select(TIMEOUT) == 0){
                    System.out.println(&quot;==&quot;);
                    continue;
                }
                Iterator&lt;SelectionKey&gt; iter = selector.selectedKeys().iterator();
                while(iter.hasNext()){
                    SelectionKey key = iter.next();
                    if(key.isAcceptable()){
                        handleAccept(key);
                    }
                    if(key.isReadable()){
                        handleRead(key);
                    }
                    if(key.isWritable() &amp;&amp; key.isValid()){
                        handleWrite(key);
                    }
                    if(key.isConnectable()){
                        System.out.println(&quot;isConnectable = true&quot;);
                    }
                    iter.remove();
                }
            }

        }catch(IOException e){
            e.printStackTrace();
        }finally{
            try{
                if(selector!=null){
                    selector.close();
                }
                if(ssc!=null){
                    ssc.close();
                }
            }catch(IOException e){
                e.printStackTrace();
            }
        }
    }
}
</code></pre><p>   Selector运行单线程处理多个Channel，如果你的应用打开了多个通道，但每个连接的流量都很低，使用Selector就会很方便。例如在一个聊天服务器中。要使用Selector, 得向Selector注册Channel，然后调用它的select()方法。这个方法会一直阻塞到某个注册的通道有事件就绪。一旦这个方法返回，线程就可以处理这些事件，事件的例子有如新的连接进来、数据接收。<br>　　我们在上面的代码里面将ServerSocketChannel注册到Selector里面，接受accept事件，每当有一个连接到来，select()就会有返回值，因为这个事件完成了，就会触发下面的操作，然后我们把这个新加入的连接也放到selector里面，等待读事件，或者写事件，当这个事件准备好了，就会启动返回。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://skydh.github.io/2018/02/24/servelet/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="董航">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="why are you so happy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/24/servelet/" itemprop="url">浅析Servlet协议</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-24T09:09:59+08:00">
                2018-02-24
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="什么是Servlet"><a href="#什么是Servlet" class="headerlink" title="什么是Servlet"></a>什么是Servlet</h2><p>　　Servelet是Server+Applet的缩写，表示一个服务器应用，是javaEE提出的一套规范。</p>
<h2 id="Servlet规范"><a href="#Servlet规范" class="headerlink" title="Servlet规范"></a>Servlet规范</h2><p><pre>public interface Servlet {<br>    //容器在启动的被调用,仅调用一次<br>    void init(ServletConfig var1) throws ServletException;<br>    //获取Servlet配置<br>    ServletConfig getServletConfig();<br>    //处理具体请求<br>    void service(ServletRequest var1, ServletResponse var2) throws ServletException, IOException;<br>    //获取Servlet的相关信息<br>    String getServletInfo();<br>    //Servlet销毁后释放资源<br>    void destroy();<br>}</pre><br>　　init方法是在容器启动时调用。只会调用一次。ServletConfig方法是获取Servelet配置信息。Service方法则是处理具体的请求。getServeletInfo方法是获取servelet相关信息，比如作者之类的要自己实现，默认返回为空字符串。destroy方法则是Servelet销毁时（一般是指关闭服务器）来释放一些资源，只会调用一次。<br>　　init方法在启动时会获取到一个容器的serveletConfig信息。我们在web.xml的配置的servelet的init-param参数配置的内容就是保存在serveletConfig的。<br>　　在tomcat容器中。Servelet的init是容器的类StandrdWrapper的initServelet方法调用的，serveletConfig传入的也是StandrdWrapper的门面类StandrdWrapperFacade.</p>
<h2 id="HTTPServelet"><a href="#HTTPServelet" class="headerlink" title="HTTPServelet"></a>HTTPServelet</h2><p>　　HttpServlet是我们写servelet常用的，他是继承了HTTP协议实现的</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://skydh.github.io/2018/02/09/http协议浅析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="董航">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="why are you so happy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/09/http协议浅析/" itemprop="url">浅析http协议</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-09T10:35:05+08:00">
                2018-02-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Http协议的报文结构"><a href="#Http协议的报文结构" class="headerlink" title="Http协议的报文结构"></a>Http协议的报文结构</h2><p>　　Http协议分为请求报文和响应报文。分为3部分：首行，头部，主体三部分。<br>　　首行：http版本，状态码，url等。<br>　　头部：保存的是一些键值对信息。<br>　　主体：保存的是具体内容。请求报文主体保存的是post请求参数信息,响应报文保存的是页面要显示的结果。首行，头部，主体用回车换行分割，林外头部和主体之间多了一个空行。<br>　　请求报文的方法有：GET,HEAD,POST,PUT,DELETE.<br>　　响应报文状态码大概有５类：<br>　　1XX:信息状态码。<br>　　2XX:成功状态码。如200表示成功<br>　　3XX:重定向状态码。如301表示重定向。<br>　　4XX:客户端错误状态码。如404表示没找到请求的资源。<br>　　5XX:服务端错误状态码。如500表示内部错误。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://skydh.github.io/2018/02/08/tcp ip协议/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="董航">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="why are you so happy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/08/tcp ip协议/" itemprop="url">tcp/ip协议</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-08T14:24:27+08:00">
                2018-02-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="什么是tcp-ip协议"><a href="#什么是tcp-ip协议" class="headerlink" title="什么是tcp/ip协议"></a>什么是tcp/ip协议</h2><p>　　tcp/ip是2个协议，tcp是运输端协议，ip是网络端协议，这2个协议一般一起使用的。ip协议是来确定和找到地址的，tcp则是具体的传输信息的工作。</p>
<h2 id="tcp的三次握手和四次挥手协议"><a href="#tcp的三次握手和四次挥手协议" class="headerlink" title="tcp的三次握手和四次挥手协议"></a>tcp的三次握手和四次挥手协议</h2><p>　　理解这个过程首先要知道tcp的2个序号和3个标志位的含义。<br>　　seq:表示传输数据的序号。tcp传输时每一个字节都有序号，发送时会把第一个序号发过去。接收端通过序号判断数据是否完整，如果不完整则重发。<br>　　ack:表示确认号，接受端表示数据已经完整接受，向发送端发送确认号。表示希望接受到数据的编号。一般为接受端报文最后的序号+1.<br>　　ACk：表示确认位。只有ACK=1时ack才会起作用。正常通信时ACK=1,第一次的话没有接收方确认是0.<br>　　SYN:这个是同步标志位，当SYN=1,ACK=0时表示这是个连接请求报文段，握手完成后SYN标志位为1<br>　　FIN:FIN=1表示数据已经发送完要求释放运输连接。</p>
<p><img src="https://raw.githubusercontent.com/skydh/picture/master/tcp_001.png" alt="aaa"><br><img src="https://raw.githubusercontent.com/skydh/picture/master/tcp_002.png" alt="aaa"><br>　　简述下３次握手和四次挥手<br>　　三次握手<br>　    1.客户端向服务端发送连接请求包，ACk位为0，SYN为1，seq=X,ACk是因为没有接受到确认信息故为0，因此需要同步标志位来确认其为有效连接。<br>　　２．服务端向客户端发送确认信息：标识位SYN=1，ACK=1，希望收到的下个信息的序号为ack=x+1;自身的seq序号为y.<br>　　３．客户端向服务端发送确认报文，ACK=1,SYN=1,ack=y+1,seq=x+1。<br>　　为何需要三次握手？<br>　　第一次，服务端知道自己接受数据没问题，第二次，客户端知道自己自己发送数据和接受数据没问题，第三次服务端知道自己发送数据没问题。然后，数据开始发送。<br>　　四次挥手<br>　　１．客户发送FIN=1,seq=x,来像服务器发送终止请求。<br>　　２．服务端接受到FIN后，发送一个ACK=1,seq=y,ACK=x+1.<br>　　３．关闭服务端到客户端的连接，且发送一个FIN给客户端。<br>　　４．客户端收到FIN后，且发送一个ACK=1,seq=x+1,ack=y+1.<br>　　简而言之这样的：<br>　　第一次客户端发送一个fin,表示自己数据发完了，服务端收到后，若是数据没有发送完，就发送一个ack，表示，已经收到你的请求，但是服务端数据没有发送完，继续发送数据，等到数据发送完了，就发送一个fin,客户端收到fin后就发送一个ack,表示确认收到，服务端就可以关闭连接了。但是客户端还是要等一个周期时间，如果客户端发送ack丢失了，服务端没有收到就会继续发送fin,直到收到信息后，才关闭，而客户端在一定周期内没有收到信号也关闭。<br>　　为何是结束是4次握手？<br>　　数据可能没有发送完。如果都是同时发送完了，那么也是3次握手，3次握手是由于没有数据传送<br>　　注意到每一次连接都要消耗3次握手和4次握手，<br>　　故有了tcp长连接和短连接，http的长连接和短连接实际上就是tcp的．</p>
<p>　　短连接：就是一次简单的tcp连接，数据发送完直接关闭。连接→数据传输→关闭连接</p>
<p>　　长连接：就是在一次连接内多次发送数据包，中间若是没有数据那么靠心跳保活协议维护， 连接→数据传输→保持连接(心跳)→数据传输→保持连接(心跳)→……→关闭连接<br>　　这样子就减少了多次连接所消耗的握手
　　</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/9/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><span class="page-number current">10</span><a class="page-number" href="/page/11/">11</a><a class="page-number" href="/page/12/">12</a><a class="extend next" rel="next" href="/page/11/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">董航</p>
              <p class="site-description motion-element" itemprop="description">clear 航</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">115</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            

          </nav>

          

          <div class="links-of-author motion-element">
            
          </div>

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">董航</span>

  
</div>


<div class="powered-by">
<i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv">
  本站访客数:<span id="busuanzi_value_site_uv"></span>
</span>
</div>

  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.3</div>




        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.3"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
