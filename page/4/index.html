<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="clear 航">
<meta property="og:type" content="website">
<meta property="og:title" content="why are you so happy">
<meta property="og:url" content="https://skydh.github.io/page/4/index.html">
<meta property="og:site_name" content="why are you so happy">
<meta property="og:description" content="clear 航">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="why are you so happy">
<meta name="twitter:description" content="clear 航">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://skydh.github.io/page/4/"/>





  <title>why are you so happy</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">why are you so happy</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">clear 航</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://skydh.github.io/2018/11/26/仿写简易rpc/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="董航">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="why are you so happy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/26/仿写简易rpc/" itemprop="url">仿写rpc</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-26T09:57:32+08:00">
                2018-11-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>　　为了了解rpc的原理，以及为何使用netty做为通信框架。</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>　　生产者：写好对外api接口以及实现类，然后在启动一个netty对外服务。<br>　　消费者：根据发过来的api接口，创建一个代理类，在代理类里面启动一个netty客户端，远程访问其服务，得到结果再返回。</p>
<h2 id="项目地址"><a href="#项目地址" class="headerlink" title="项目地址"></a>项目地址</h2><p>　　我也简单实现了一个仿写的rpc,demo如下：<br>　　<a href="https://github.com/skydh/rpc-try.git" target="_blank" rel="noopener">点我一下就到了</a><br>　　极其粗糙的实现了一次，如有时间，继续优化。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://skydh.github.io/2018/11/16/mysql入门之redolog binlog undolog/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="董航">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="why are you so happy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/16/mysql入门之redolog binlog undolog/" itemprop="url">mysql 入门redolo binlog undolog</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-16T10:19:48+08:00">
                2018-11-16
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="redolog"><a href="#redolog" class="headerlink" title="redolog"></a>redolog</h2><p>　　MySQL 里经常说到的 WAL 技术，意思就是数据先写日志，再写磁盘。这里面的日志就是innodb里面的redolog.当有一条记录需要更新的时候，InnoDB 引擎就会先把记录写redo log里面，并更新内存，这个时候更新就算完了，然后innodb引擎会在适当的时候将数据跟新到磁盘里面，这个跟新会在系统空闲的时候进行。<br>　　这个可以加速的原因是不用去索引磁盘里面的数据，直接添加到日志里面，等到最后清算，如此可以有效提高效率。<br>　　redolog是个循环日志，其大小固定为4g，存在2个指正来定位其是否已经满了。一个指正是当前读，一个指针是当前写，很类似java里面的bytebuffer。redolog本质上就是为了崩溃恢复用的。当内存的数据页要持久化到磁盘，这个脏页的操作和redolog无关。只有当崩溃恢复的时候才用，把数据修复为脏页数据。因为redolog记录的是数据页的变换信息。  redolog只是个保险。数据页只存在2个情况。内存中，那就一定是正确的结果，直接返回，另一种是数据文件上的，那就一定正确，读入内存后返回。</p>
<h2 id="binlog"><a href="#binlog" class="headerlink" title="binlog"></a>binlog</h2><p>　　这个是mysql自身的日志，叫做归档日志。和redolog大致3个不同点。<br>　　１．其为mysql自带的，redolog是innodb里面的。<br>　　２．redolog是物理日志，binlog是逻辑日志。<br>　　３．redolog是循环日志，binlog是增量日志。<br>　　对于我们来说，redolog主要针对系统崩溃，而binlog主要是针对系统恢复归档，因为redolog是循环的，无法持久太多。</p>
<h2 id="undolog"><a href="#undolog" class="headerlink" title="undolog"></a>undolog</h2><p>　　这个日志主要用来处理事务的隔离级别的<br>　　详细信息请看我的另一篇文章，关于mysql innodb的隔离级别的实现。因此我在这里说下长事务对其的影响，我们知道我那篇文章说了，innodb是基于mvcc的控制，undolog将会非常的大，因为这个日志的大小和最早事务相关，因此长事务会使其的undolog非常大。<br>　　大家也不想使用长事务，但是以下情况可能出现长事务。就是你<br>　　set autocommit=0那就是不自动提交，即使是一个select语句那也不会提交，因此我们要注意。<br>　　我们用这条语句来判断事务是否为长事务。<br>　　select * from information_schema.innodb_trx where TIME_TO_SEC(timediff(now(),trx_started))&gt;60</p>
<h2 id="change-buffer"><a href="#change-buffer" class="headerlink" title="change buffer"></a>change buffer</h2><p>　　这个东西主要是更新插入数据时用的哈，首先判断要更新的数据是否在内存，若在，直接更新内存，如不在，则是将其修改加入到change buffer里面，等到要查询这个数据的时候，再将其同步过去。或者等到一定时间通过定时器刷新过去。但是要用到这个东西不能加唯一索引，因为你加了唯一索引，那么就必须从磁盘读取到这个数据页来进行判断这个数据是否满足规范，因此要想用到这个change buffer就不能用唯一索引，只能用普通索引。那么这个change buffer和redo log的区别呢？在数据库的操作流程是这样的。假设这个数据不在内存里面，我们的操作流程是先写到change buffer里面，在写到redolog里面，当我们要读取这个数据的时候，我们从数据库里面读取到这个数据页，然后取出对应数据加上change buffer的东西。<br>　　<br>　　因此相对于redolog,change buffer主要是减少了随机读取的性能消耗，因为我们不用读取这个数据页，插入更新的时候，只有当我们真正需要读取数据的时候才进行读取数据。而redolog则是有效减少了随机写磁盘的消耗，我们只用顺序写到redolog里面，当到一定时间后则刷新到数据库磁盘里面。完美。ps:这都是针对2级索引，而主键索引是判断数据所在数据页的在哪的，因此考虑了其唯一性。</p>
<p>　　这么说吧，redolog 考虑的主要是大量的写的到来，直接顺序的写到redolog里面速度快且持久化过，有保证，其实这个数据页如果在内存里面，以后查询直接读取，如果不在且上面的写没有唯一索引时（没有唯一索引，那就把数据修改加到changbuff里面，在写入redolog，减少读取数据到内存的麻烦）那就把数据页读取出来，和changgbuffer来个merge。当内存不够时，需要把一部分磁盘页刷新到磁盘。完成持久化哦。同时当redolog满了时，也会把一部分内存数据页刷新到磁盘。而刷数据页到磁盘，会导致mysql系统卡顿。</p>
<h2 id="2阶段提交"><a href="#2阶段提交" class="headerlink" title="2阶段提交"></a>2阶段提交</h2><p>　　redolog,binlog保持强一致性。一起成功，或者一起失败。不然可能导致数据出现问题。</p>
<h2 id="一个更新语句的执行过程"><a href="#一个更新语句的执行过程" class="headerlink" title="一个更新语句的执行过程"></a>一个更新语句的执行过程</h2><p>　　１．先判断该数据对应的数据页是否在内存里面，如是在，则取出对应数据，若是不在，则从磁盘取出该数据页放入内存，并取出该数据。<br>　　<br>　　２．修改该数据，且将其更新到内存。</p>
<p>　　３．将其修改更新到redolog里面。且置状态为prepare。</p>
<p>　　４．写入binlog,且将状态改为commit.</p>
<h2 id="mysql-系统抖动"><a href="#mysql-系统抖动" class="headerlink" title="mysql 系统抖动"></a>mysql 系统抖动</h2><p>　　１．对于mysql来说，有时候你更新数据很快，有时候会很慢，很慢的时候就是发生了redolog写入磁盘的过程，对于mysql来说，我们的数据要么在内存，要么在磁盘，如果不在磁盘的数据，那么内存的数据是最新的，如果不在内存，那么磁盘的数据是最新的。为什么呢？因为，在redolog写磁盘的一个场景中。当读取量很大的时候，内存不够了，那么我们必须在内存里面淘汰一些数据页。当淘汰的数据页里面，存在脏页（内存和磁盘不匹配）在这种情况下，我们要淘汰磁盘页的同时，把redolog的数据页怼进磁盘里面。以下情况也会使得redolog写数据到磁盘里面。１redolog满了。2系统空闲。3.系统正常关闭。主要分析下，内存不够的情况。对于获取新的数据页，淘汰旧的数据页，我们如果淘汰的全部是脏页，那么性能消耗会大很多，因此我们要保证数据库脏页的比例。<br>　　innodb_io_capacity，我们通过这个参数去设定。我们通过你的磁盘读写能力来设定这个值的大小。如果设定很低，那么mysql就会默认你的系统很差，如果很高，反之。。。我们系统默认的脏页比例是0.75，我们要控制器脏页比例不能太高。mysql还有一个连坐机制，当发现刷的脏页，旁边也是脏页，那么也会连带清除掉。这对于机械硬盘来说是很大的优化，但是对于ssd来说确实非必要的。</p>
<p>ps：因此当读取数据时，要么从内存里面读取，要么从磁盘读取。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://skydh.github.io/2018/11/15/mysql 入门一条查询sql如何运行的/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="董航">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="why are you so happy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/15/mysql 入门一条查询sql如何运行的/" itemprop="url">mysql 入门一条查询sql如何运行的</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-15T16:03:42+08:00">
                2018-11-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="mysql的构成"><a href="#mysql的构成" class="headerlink" title="mysql的构成"></a>mysql的构成</h2><h3 id="server层"><a href="#server层" class="headerlink" title="server层"></a>server层</h3><h4 id="连接器"><a href="#连接器" class="headerlink" title="连接器"></a>连接器</h4><p>　　客户端连接到mysql数据库的时候，接待你的是连接器。连接器是连接器负责跟客户端建立连接、获取权限、维持和管理连接。在完成3次tcp握手后，通过账号密码进行身份验证，验证通过后从权限表里面读取权限，该链接后续的操作权限都是基于这个时候读取的权限。<br>　　数据库连接有长连接和短连接，和tcp的很类似，都是连接器长期持有这些连接。长连接是客户端有请求时长时间持有这个连接，而短连接则是短暂的处理之后就断掉，建议客户端使用连接池，来保持多个长连接，减少连接的成本。但是可能出现OOM异常，原因如下：mysql在执行过程中临时使用的内存是管理在连接对象里面的，这些资源会在连接断开才释放，一直保持长连接，可能导致内存占用太大。解决方案为当你执行一个大的操作时，通过执行 mysql_reset_connection 来重新初始化连接资源，这个过程不需要重连。<br>　　一个连接建立连接后，管理员修改了其权限，但是不会影响其现在的连接，权限的修改只能影响到新的连接。</p>
<h4 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h4><p>　　当你连接建立完毕后，使用select语句的时候，可以从查询缓存里面查询，因为在这个查询缓存里面 查询语句，结果，会以键值对的方式放到里面，当可以从查询缓存里面取出数据时返回，但是，你缓存表的数据出现问题时，缓存就会失效，因此很不划算，在mysql8已经取消查询缓存这个模块。</p>
<h4 id="分析器"><a href="#分析器" class="headerlink" title="分析器"></a>分析器</h4><p>　　真正的第二步。在这个步骤里面，mysql会对sql进行词法分析，词法分析器会对sql进行分析，判断其是否符合mysql语法。</p>
<h4 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h4><p>　　mysql的优化器是为了提高sql的效率，比如表里面有多个索引，用哪个索引（一条sql一个表只用一个索引），表连接，比如内连接，谁连接谁，优化器会采用优化策略，让有索引的放在右边边被连接，或者都有索引的，且高度一样的。小表放在左边，因为左边的表是必须全扫描的。对表连接感兴趣的可以看我的下面这个文章，关于表的连接算法。<br><a href="https://skydh.github.io/2018/03/19/mysql%E8%BF%9E%E6%8E%A5%E7%AE%97%E6%B3%95/">点我一下就到了</a></p>
<h4 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h4><p>　　经过优化器后，下一步就是执行，执行这个必须先判断你是否有这个权限，然后通过表的引擎来执行，比如查询，如果没有索引，那么就通过存储引擎读取第一行数据，执行器调用一次，扫描一次。比较，然后不断循环直到找到数据，或者循环完毕。使用索引同样的道理。我们以前查看explain查看扫描的行树，来看查询效率。但是在有些情况下，执行器执行一次，引擎扫描多行数据。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://skydh.github.io/2018/11/15/git 双库合并/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="董航">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="why are you so happy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/15/git 双库合并/" itemprop="url">git双库合并</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-15T14:58:41+08:00">
                2018-11-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>　　１．本项目ａ开发时基于其他项目组的一个项目ｂ进行扩展开发，但是ｂ项目没有开发完，我们也要赶进度，于是基于ｂ项目的主分支，copy出来后，新建了一个新的仓库，进行新的开发。然后，a,b项目都开发完了，现在a项目要发布到线上，需要合并b项目代码仓库的代码。</p>
<h2 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h2><p>　　1．添加b的代码的源，作为新的源，命名为other。<br>    git remote add other http://….</p>
<p>　　２．获取ｂ的代码<br>    git fetch other</p>
<p>　　３．新建一个分支存放ｂ的代码<br>    git checkout -b newbranch other/dev</p>
<p>　　４．在切换为dev分支<br>    git checkout dev</p>
<p>　　５．在合并代码<br>    git merge newbranch </p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>　　１．为何可以直接merge，本质上这2个库是有共同的祖先的。因此可以直接merge。调用git merge-base dev new,是有共同祖先的。<br>　　２．没有共同祖先怎么破，已经找不到了，直接使用git merge newbranch 时报错的，<br>　　那如何，使用命令如下：<br>　　git merge newbranch 　–allow-unrelated-histories<br>　　可以直接强行merge。只不过要解决冲突的文件更加多了。
　　</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://skydh.github.io/2018/10/24/微服务架构入门/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="董航">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="why are you so happy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/24/微服务架构入门/" itemprop="url">OAuth 2.0</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-10-24T11:33:23+08:00">
                2018-10-24
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="什么是OAuth2-0"><a href="#什么是OAuth2-0" class="headerlink" title="什么是OAuth2.0"></a>什么是OAuth2.0</h2><p>　　１．用于rest/api的代理请求框架。<br>　　２．解耦认证和授权<br>　　３．基于令牌Token的授权，在无需暴露用户密码的情况下，让应用能获得对用户数据的访问权限。<br>　　４．事实上的标准安全框架，支持多种用例场景。适用于，服务端webapp,单页spa,原生app，服务器服务器之间。</p>
<h2 id="OAuth2-0的优势"><a href="#OAuth2-0的优势" class="headerlink" title="OAuth2.0的优势"></a>OAuth2.0的优势</h2><p>　　１．易于实现。<br>　　２．更加安全，客户端不接触密码，服务端集中保护。本质上就是解决这个问题。<br>　　３．广泛传播并持续采用。<br>　　４．短寿命和封装的token。<br>　　５. 资源服务器和授权服务器解耦。一个负责授予token权限(客户端访问其，其返回页面给用户，判断是否同意授权，同意，则授予让其有资格访问我的数据)，一个负责判断请求是否具有token<br>　　６．集中授权<br>　　７．基于http/json，易于请求和传递token<br>　　８．考虑了多种客户端场景<br>　　９．客户端有多种信任级别。</p>
<h2 id="OAuth2-0的不足"><a href="#OAuth2-0的不足" class="headerlink" title="OAuth2.0的不足"></a>OAuth2.0的不足</h2><p>　　１.协议太宽泛了，因此各个实现版本兼容性不好。<br>　　２．和Oauth1.0不兼容。<br>　　３．Oauth2.0不是一个认证协议，他是个授权框架，他本省不会告诉你任何用户信息。是个授权协议。</p>
<h2 id="Oauth2-0主要角色术语"><a href="#Oauth2-0主要角色术语" class="headerlink" title="Oauth2.0主要角色术语"></a>Oauth2.0主要角色术语</h2><p>　　１．资源拥有者：资源的拥有者，用户。<br>　　２．客户应用：通常是一个web应用，想要访问收到保护的数据。比如微信用户数据等。<br>　　３．资源服务器：一个web站点或者service api,客户想要访问的数据在我这里。<br>　　４．授权服务器：客户想要访问受保护的数据，必须先到我这里来认证，来获取到access token。<br>　　５．客户凭证：在授权服务器上注册后获得的，客户的ClientId和密码用于认证客户。<br>　　６．令牌：授权服务器接受到客户端请求后，验证后颁发的访问令牌<br>　　７．作用域：客户请求访问令牌是，由资源额外指定的细分权限。</p>
<h2 id="Oauth2-0-令牌类型"><a href="#Oauth2-0-令牌类型" class="headerlink" title="Oauth2.0 令牌类型"></a>Oauth2.0 令牌类型</h2><p>　　１．access token：访问令牌用来代表一个用户或者服务直接去访问受保护的资源。<br>　　２．refresh token:刷新令牌，勇于去授权服务器获取一个新的令牌。（有时候访问令牌过期了，有的流程会支持获取到一个refreshtoken,我可以通过这个换取一个新的令牌）<br>　　３．Bearer Token：不管谁拿到token,都可以访问资源。<br>　　４．pop token:可以校验client是否对token的用友权。<br>　　５．Authorization Code Token:授权码，仅用于授权码授权类型。用于交换获取访问令牌和刷新令牌。</p>
<h2 id="Ouath2-0的误区"><a href="#Ouath2-0的误区" class="headerlink" title="Ouath2.0的误区"></a>Ouath2.0的误区</h2><p>　　１．该协议仅仅支持http协议。<br>　　２．Oauth 是个授权协议，不是认证协议。<br>　　３．oauth 没有定义token格式<br>　　４．没有定义加密算法<br>　　５．不是单个协议<br>　　６．没有定义授权处理机制<br>　　７．仅仅是个授权框架，用于授权代理
　　</p>
<h2 id="授权模式"><a href="#授权模式" class="headerlink" title="授权模式"></a>授权模式</h2><h3 id="授权码模式"><a href="#授权码模式" class="headerlink" title="授权码模式"></a>授权码模式</h3><p>  用下面转载自码农翻身的一张图来解释下</p>
<p><img src="https://raw.githubusercontent.com/skydh/picture/master/token_001.png" alt="aaa"></p>
<p>　　１．用户访问客户端，客户端将用户重定向到授权服务器。同时附上客户端凭证和处理完后要重定向的url。<br>　　２．用户选择是否给予客户端授权。<br>　　３．用户给予授权，授权服务器将用户导向客户端事先指定的”重定向URI”（redirection URI），同时附上一个授权码。<br>　　４．客户端收到授权码，附上早先的”重定向URI”，向认证服务器申请令牌。这一步是在客户端的后台的服务器上完成的，对用户不可见。<br>　　５．认证服务器核对了授权码和重定向URI，确认无误后，向客户端发送访问令牌（access token）和更新令牌（refresh token）。</p>
<h3 id="简化模式"><a href="#简化模式" class="headerlink" title="简化模式"></a>简化模式</h3><p>　　（A）客户端将用户导向认证服务器。<br>　　（B）用户决定是否给于客户端授权。<br>　　（C）假设用户给予授权，认证服务器将用户导向客户端指定的”重定向URI”，并在URI的Hash部分包含了访问令牌。<br>　　（D）浏览器向资源服务器发出请求，其中不包括上一步收到的Hash值。<br>　　（E）资源服务器返回一个网页，其中包含的代码可以获取Hash值中的令牌。<br>　　（F）浏览器执行上一步获得的脚本，提取出令牌。<br>　　（G）浏览器将令牌发给客户端。</p>
<h3 id="密码模式"><a href="#密码模式" class="headerlink" title="密码模式"></a>密码模式</h3><p>　　这个通常需要客户端是操作系统的一部分，或者是一个著名公司出品，而认证服务器无法授权处理才使用。<br>　　（A）用户向客户端提供用户名和密码。<br>　　（B）客户端将用户名和密码发给认证服务器，向后者请求令牌。<br>　　（C）认证服务器确认无误后，向客户端提供访问令牌。</p>
<h3 id="客户端模式"><a href="#客户端模式" class="headerlink" title="客户端模式"></a>客户端模式</h3><p>　　其实不存在授权问题，客户端自己向授权服务器拿令牌。<br>　　（A）客户端向认证服务器进行身份认证，并要求一个访问令牌。<br>　　（B）认证服务器确认无误后，向客户端提供访问令牌。</p>
<p>为何要加个授权码呢？<br>   为了避免把token透露给浏览器，最好是透明的，我们不希望处理到这个token暴露在浏览器里面，每次重定向都会经过浏览器的。因此如果直接返回token的话就会产生问题。因此我们一般使用授权码的方式。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://skydh.github.io/2018/09/27/redis 数据类型实现机制/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="董航">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="why are you so happy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/27/redis 数据类型实现机制/" itemprop="url">redis 数据类型实现机制</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-27T09:34:36+08:00">
                2018-09-27
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="redis-对象信息"><a href="#redis-对象信息" class="headerlink" title="redis 对象信息"></a>redis 对象信息</h2><pre><code>struct RedisObject {
int4 type; // 4bits 什么数据类型，比如字符串，hash，set之类的
int4 encoding; // 4bits 比如字符串用什么方式存储，比如emb,raw.
int24 lru; // 24bits 前文说过关于内存不够是采用的lru算法，这个是保存的是上一次使用的时间戳。
int32 refcount; // 4bytes 这个是对象的引用计数，当这个计数为0的时候，这个对象就要被回收。
void *ptr; // 8bytes，64-bit system 这个保存的实际上对象的存储位置。
} robj;
</code></pre><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><p>　　其实现是一个带长度信息的字节数组</p>
<pre><code>struct SDS&lt;T&gt; {
T capacity; // 数组容量
T len; // 数组长度
byte flags; // 特殊标识位，不理睬它
byte[] content; // 数组内容
}
</code></pre><p>　　很类似于java里面ArrayList的实现，一个动态数组。<br>　　redis字符串有2种存储方式，一个是长度小于44时用emb方式存储，当长度大于44时采用raw方式存储。<br>　　为何？<br>　　前面说了，每个对象头的数据结构大约是16字节，字符串自身数据结构是&gt;=3字节，字符串以\0结尾，一个字节，因此长度为20字节，内存分配器分配内存都是2的幂次，为了存储redis字符串，起码要32，稍微长点就是64，而redis认为大于64字节就是大字符，而64-20=44，因此当数据量小的时候采用emb,方式，就是对象头和sds放在一起，分配一次内存即可，当大约44时就采用raw模式，对象头和sds分开，分配2次内存即可。</p>
<h2 id="字典内部实现"><a href="#字典内部实现" class="headerlink" title="字典内部实现"></a>字典内部实现</h2><p>　　字典这个数据结构在redis里面用处很频繁，hash结构，所有的redis里面的key和value,带过期时间的key集合，zset里面value和score的集合</p>
<pre><code>struct RedisDb {
dict* dict; // all keys  key=&gt;value
dict* expires; // all expired keys key=&gt;long(timestamp)

}

struct zset {
    dict *dict; // all values  value=&gt;score
    zskiplist *zsl;
}
</code></pre><p>　　dict书籍结构包含2个hashtable,因为redis的扩容时渐进的。因此同时存在2个hashtable,这个迁移主要来自客户端的hset/hdel指令等，当然还有定时任务来配合。</p>
<h2 id="压缩列表"><a href="#压缩列表" class="headerlink" title="压缩列表"></a>压缩列表</h2><p>　　前面说过了，当hashmap,zset数据量小的时候回采用ziplist,这个压缩列表来存储，将2维变成一维。</p>
<pre><code>struct ziplist&lt;T&gt; {
int32 zlbytes; // 整个压缩列表占用字节数
int32 zltail_offset; // 最后一个元素距离压缩列表起始位置的偏移量，用于快速定位到最后一个节点
int16 zllength; // 元素个数
T[] entries; // 元素内容列表，挨个挨个紧凑存储
int8 zlend; // 标志压缩列表的结束，值恒为 0xFF
}

struct entry {
int&lt;var&gt; prevlen; // 前一个 entry 的字节长度
int&lt;var&gt; encoding; // 元素类型编码
optional byte[] content; // 元素内容
}
</code></pre><p>　　压缩列表为了支持双向遍历，所以才会有 ztail_offset 这个字段，用来快速定位到最后一个元素，然后倒着遍历。</p>
<p>　　当 set 集合容纳的元素都是整数并且元素个数较小时，Redis 会使用 intset 来存储结合元素。intset 是紧凑的数组结构，同时支持 16 位、32 位和 64 位整数</p>
<pre><code>struct intset&lt;T&gt; {
int32 encoding; // 决定整数位宽是 16 位、32 位还是 64 位
int32 length; // 元素个数
int&lt;T&gt; contents; // 整数数组，可以是 16 位、32 位和 64 位
}
</code></pre><h2 id="快速列表"><a href="#快速列表" class="headerlink" title="快速列表"></a>快速列表</h2><p>　　quicklist 是 ziplist 和 linkedlist 的混合体，它将 linkedlist 按段切分，每一段使用 ziplist 来紧凑存储，多个 ziplist 之间使用双向指针串接起来。</p>
<pre><code>struct ziplist {
...
}
struct ziplist_compressed {
int32 size;
byte[] compressed_data;
}
struct quicklistNode {
quicklistNode* prev;
quicklistNode* next;
ziplist* zl; // 指向压缩列表
int32 size; // ziplist 的字节总数
int16 count; // ziplist 中的元素数量
int2 encoding; // 存储形式 2bit，原生字节数组还是 LZF 压缩存储

}
struct quicklist {
quicklistNode* head;
quicklistNode* tail;
long count; // 元素总数
int nodes; // ziplist 节点的个数
int compressDepth; // LZF 算法压缩深度
...
}
</code></pre><p>　　quicklist 内部默认单个 ziplist 长度为 8k 字节，超出了这个字节数，就会新起一个 ziplist。ziplist 的长度由配置参数list-max-ziplist-size决定。</p>
<h2 id="zset——跳跃表"><a href="#zset——跳跃表" class="headerlink" title="zset——跳跃表"></a>zset——跳跃表</h2><p>　　个人觉得跳跃表的查找方式类似于Ｂ＋树。</p>
<pre><code>struct zslnode {
    string value;
    double score;
    zslnode*[] forwards;  // 多层连接指针
    zslnode* backward;  // 回溯指针
}

struct zsl {
    zslnode* header; // 跳跃列表头指针
    int maxLevel; // 跳跃列表当前的最高层
    map&lt;string, zslnode*&gt; ht; // hash 结构的所有键值对
}
</code></pre><p>　　每个节点 之间使用指针串起来形成了双向链表结构，它们是 有序 排列的，从小到大。不同的 节点 层高可能不一样，层数越高的 节点 越少。同一层的 节点 会使用指针串起来。每一个层元素的遍历都是从 节点header 出发。</p>
<h2 id="紧凑列表"><a href="#紧凑列表" class="headerlink" title="紧凑列表"></a>紧凑列表</h2><pre><code>struct listpack&lt;T&gt; {
int32 total_bytes; // 占用的总字节数
int16 size; // 元素个数
T[] entries; // 紧凑排列的元素列表
int8 end; // 同 zlend 一样，恒为 0xFF
}


struct lpentry {
int&lt;var&gt; encoding;
optional byte[] content;
int&lt;var&gt; length;//本元素大小
}
</code></pre><p>　　首先这个 listpack 跟 ziplist 的结构几乎一摸一样，只是少了一个zltail_offset字段。ziplist 通过这个字段来定位出最后一个元素的位置，用于逆序遍历。不过 listpack 可以通过其它方式来定位出最后一个元素的位置（这个位置可以通过total_bytes字段和最后一个元素的长度字段计算出来。首先通过total_bytes找到最后的标记位end,占一个字符,去除这个字符,前面就是最后一个元素,而元素length放在了后面,那end的前面就是entry的length,length又是通过固定编码方式存储,要读取出来并不难），所以zltail_offset字段就省掉了。</p>
<h2 id="基数树"><a href="#基数树" class="headerlink" title="基数树"></a>基数树</h2><p>　　你可以将一本英语字典看成一棵 radix tree，它所有的单词都是按照字典序进行排列，每个词汇都会附带一个解释，这个解释就是 key 对应的 value。有了这棵树，你就可以快速地检索单词，还可以查询以某个前缀开头的单词有哪些。你也可以将公安局的人员档案信息看成一棵 radix tree，它的 key 是每个人的身份证号，value 是这个人的履历。因为身份证号的编码的前缀是按照地区进行一级一级划分的，这点和单词非常类似。有了这棵树，你就可以快速地定位出人员档案，还可以快速查询出某个小片区都有哪些人。</p>
<p>　　Rax 被用在 Redis Stream 结构里面用于存储消息队列，在 Stream 里面消息 ID 的前缀是时间戳 + 序号，这样的消息可以理解为时间序列消息。使用 Rax 结构进行存储就可以快速地根据消息 ID 定位到具体的消息，然后继续遍历指定消息之后的所有消息。</p>
<p>　　Rax 被用在 Redis Cluster 中用来记录槽位和key的对应关系，这个对应关系的变量名成叫着slots_to_keys。这个raxNode的key是由槽位编号hashslot和key组合而成的。我们知道cluster的槽位数量是16384，它需要2个字节来表示，所以rax节点里存的key就是2个字节的hashslot和对象key拼接起来的字符串。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://skydh.github.io/2018/09/26/redis GeoHash scan/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="董航">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="why are you so happy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/26/redis GeoHash scan/" itemprop="url">redis GeoHash 和scan</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-26T11:41:19+08:00">
                2018-09-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="GeoHash的产生"><a href="#GeoHash的产生" class="headerlink" title="GeoHash的产生"></a>GeoHash的产生</h2><p>　　我们用x,y坐标轴表示你的位置，当我们查看附近的人这个功能的时候，就要对一定范围的人查询，如果放在数据里面，这么算的。</p>
<pre><code>select id from positions where x0-r &lt; x &lt; x0+r and y0-r &lt; y &lt; y0+r
</code></pre><p>　　但是当数据量大，并发量大的时候就会存在性能瓶颈。<br>　　<br>　　业界有个算法将经纬度２维坐标转换为一维整数，当我们想要计算附近的人的时候，我们只要计算这个线上的点就好了。编码后，二维坐标变成了整数，但是同时整数也可以重新还原坐标。GeoHash算法会对整数进行编码，生成一个字符串，然后放到zset里面。这个字符串作为score，value是元素的key.</p>
<p>　　geoadd company 116.48105 39.996794 juejin<br>　　我们用这个geoadd来加入到zset里面，redis会按照上面的算法将其2个数字转换为一个score，然后存进去。<br>　　 geodist company juejin ireader km<br>　　这个是计算２个地点的距离。<br>   georadiusbymember company ireader 20 km count 3 asc<br>　　这个是查询company这个zset里面 ireader,20km范围内最多3个元素的正排序，包括自身。</p>
<h2 id="scan"><a href="#scan" class="headerlink" title="scan"></a>scan</h2><p>　　keys codess*<br>　　找出所有以codess开头的key。但是有缺点，数据量太大，会让服务器卡顿，一长串，数据太多。不好看，不好处理。时间复杂度为o(n).<br>　　后面多了个scan:<br>　　１多了limit参数，可控了<br>　　２通过游标分步进行进行。不阻塞线程。<br>　　３．返回的结果可能会有重复，需要客户端去重复，这点非常重要;<br>　　４．遍历的过程中如果有数据修改，改动后的数据能不能遍历到是不确定的;<br>　　５．单次返回的结果是空的并不意味着遍历结束，而要看返回的游标值是否为零;<br>　　scan 参数提供了三个参数，第一个是 cursor 整数值，第二个是 key 的正则模式，第三个是遍历的 limit hint。第一次遍历时，cursor 值为 0，然后将返回结果中第一个整数值作为下一次遍历的 cursor。一直遍历到返回的 cursor 值为 0 时结束。<br> 　limit 不是限定返回结果的数量，而是限定服务器单次遍历的字典槽位数量(约等于)。如果将 limit 设置为 10，你会发现返回结果是空的，但是游标值不为零，意味着遍历还没结束。</p>
<h2 id="key-字典"><a href="#key-字典" class="headerlink" title="key 字典"></a>key 字典</h2><p>　　redis里面所有的key存在一个很大的字典里面，类似于hashmap,sacn指令返回的游标就是第一维数组的位置索引，我们将这个位置索引称为槽 (slot)。如果不考虑字典的扩容缩容，直接按数组下标挨个遍历就行了。limit 参数就表示需要遍历的槽位数，之所以返回的结果可能多可能少，是因为不是所有的槽位上都会挂接链表，有些槽位可能是空的，还有些槽位上挂接的链表上的元素可能会有多个。每一次遍历都会将 limit 数量的槽位上挂接的所有链表元素进行模式匹配过滤后，一次性返回给客户端。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://skydh.github.io/2018/09/26/redis 内存策略 /">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="董航">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="why are you so happy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/26/redis 内存策略 /" itemprop="url">redis内存策略 LRU,LFU以及安全问题</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-26T10:52:46+08:00">
                2018-09-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="内存策略"><a href="#内存策略" class="headerlink" title="内存策略"></a>内存策略</h2><p>　　大家知道现代计算机都有虚拟内存这个概念，当redis内存超出物理内存限制的时候，内存数据就会和磁盘发生频繁交换。严重影响性能。我们一般通过配置参数maxmemory来限定内存大小。当内存要超出maxmemory时以下策略来使用。</p>
<p>　　noeviction 不会继续服务写请求 (DEL 请求可以继续服务)，读请求可以继续进行。这样可以保证不会丢失数据，但是会让线上的业务不能持续进行。这是默认的淘汰策略。</p>
<p>　　volatile-lru 尝试淘汰设置了过期时间的 key，最少使用的 key 优先被淘汰。没有设置过期时间的 key 不会被淘汰，这样可以保证需要持久化的数据不会突然丢失。</p>
<p>　　volatile-ttl 跟上面一样，除了淘汰的策略不是 LRU，而是 key 的剩余寿命 ttl 的值，ttl 越小越优先被淘汰。</p>
<p>　　volatile-random 跟上面一样，不过淘汰的 key 是过期 key 集合中随机的 key。</p>
<p>　　allkeys-lru 区别于 volatile-lru，这个策略要淘汰的 key 对象是全体的 key 集合，而不只是过期的 key 集合。这意味着没有设置过期时间的 key 也会被淘汰。</p>
<p>　　allkeys-random 跟上面一样，不过淘汰的策略是随机的 key。</p>
<p>　　实现 LRU 算法除了需要 key/value 字典外，还需要附加一个链表，链表中的元素按照一定的顺序进行排列。当空间满的时候，会踢掉链表尾部的元素。当字典的某个元素被访问时，它在链表中的位置会被移动到表头。所以链表的元素排列顺序就是元素最近被访问的时间顺序。<br>　　redis为了实现类lru算法，采用了它给每个 key 增加了一个额外的小字段，这个字段的长度是 24 个 bit，也就是最后一次被访问的时间戳。Redis 执行写操作时，发现内存超出 maxmemory，就会执行一次 LRU 淘汰算法。这个算法也很简单，就是随机采样出 5(可以配置) 个 key，然后淘汰掉最旧的 key，如果淘汰后内存还是超出 maxmemory，那就继续随机采样淘汰，直到内存低于 maxmemory 为止。<br>　　在 LRU 模式下，lru 字段存储的是 Redis 时钟server.lruclock，Redis 时钟是一个 24bit 的整数，默认是 Unix 时间戳对 2^24 取模的结果，大约 97 天清零一次。当某个 key 被访问一次，它的对象头的 lru 字段值就会被更新为server.lruclock。</p>
<p>　　默认 Redis 时钟值每毫秒更新一次，在定时任务serverCron里主动设置。Redis 的很多定时任务都是在serverCron里面完成的，比如大型 hash 表的渐进式迁移、过期 key 的主动淘汰、触发 bgsave、bgaofrewrite 等等。</p>
<p>　　如果server.lruclock没有折返 (对 2^24 取模)，它就是一直递增的，这意味着对象的 LRU 字段不会超过server.lruclock的值。如果超过了，说明server.lruclock折返了。通过这个逻辑就可以精准计算出对象多长时间没有被访问——对象的空闲时间。</p>
<p>　　LFU策略：表示按最近的访问频率进行淘汰，它比 LRU 更加精准地表示了一个 key 被访问的热度。redis4.0后出来的。<br>　　在 LFU 模式下，lru 字段 24 个 bit 用来存储两个值，分别是ldt(last decrement time)和logc(logistic counter)。<br>　　idt:16bit存储上次idt的跟新时间。内存回收时，自己被随机取到的话，自己更新的时间。<br>　　logc:对象调用次数，存储的是对数次。每次访问更新。<br>　　dt 更新的同时也会一同衰减 logc 的值，衰减也有特定的算法。它将现有的 logc 值减去对象的空闲时间 (分钟数) 除以一个衰减系数，默认这个衰减系数lfu_decay_time是 1。如果这个值大于 1，那么就会衰减的比较慢。如果它等于零，那就表示不衰减，它是可以通过配置参数lfu-decay-time进行配置。</p>
<p>　　为何不从系统里面取时间？<br>　　一次系统调用太耗时了。太多更耗时。</p>
<h2 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h2><p>　　redis有些指令是很危险的，比如flushdb 和 flushall 会让 Redis 的所有数据全部清空。Redis 在配置文件中提供了 rename-command 指令用于将某些危险的指令修改成特别的名称，用来避免人为误操作。比如在配置文件的 security 块增加下面的内容:</p>
<pre><code>rename-command keys abckeysabc
</code></pre><p>　　如果还想执行 keys 方法，那就不能直接敲 keys 命令了，而需要键入abckeysabc。 如果想完全封杀某条指令，可以将指令 rename 成空串，就无法通过任何字符串指令来执行这条指令了。<br>　　我们可以修改端口号，不用默认端口，避免被入侵。<br>　　客户端和服务器的访问时直接暴露在公网上传输，为了安全，我们可以使用ssl代理对通信通道进行加密。</p>
<h2 id="spiped原理"><a href="#spiped原理" class="headerlink" title="spiped原理"></a>spiped原理</h2><p>　　程序通过公网访问redis时，数据暴露在外面，我们可以用ssl对数据加密。使其安全传输，spiped就是其中一个代理，其原理是在2端各起一个进程，来对消息进行加密和解密。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://skydh.github.io/2018/09/25/redis 删除策略/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="董航">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="why are you so happy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/25/redis 删除策略/" itemprop="url">redis过期删除策略</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-25T18:41:04+08:00">
                2018-09-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="惰性删除"><a href="#惰性删除" class="headerlink" title="惰性删除"></a>惰性删除</h2><p>　　redis将设置了过期时间的key放到一个独立的字典里面，以后定时遍历这个字典来删除到期的key，同时采用惰性原则，当客户端访问这个key的时候，redis会对其进行检查，如果过期了，那么立即删除。</p>
<h2 id="定时策略"><a href="#定时策略" class="headerlink" title="定时策略"></a>定时策略</h2><p>　　redis默认每秒10次扫描过期字典的key,不是遍历，而是一种贪心策略。<br>　　１．从过期字典随机20个key。<br>　　２．删除这２０个ｋｅｙ里面过期的key。<br>　　３．如果过期的key&gt;1/4,那就重复1.<br>　　同时为了避免循环过度，造成线程卡死，算法还设置了一个时间上限，默认不超过25ms。<br>　　<br>　　不要用大量key同一时间过期，会导致系统卡顿。因为卡顿是很多小卡顿积累出来的。</p>
<h2 id="从库的删除策略"><a href="#从库的删除策略" class="headerlink" title="从库的删除策略"></a>从库的删除策略</h2><p>　　从库不会进行过期扫描，从库的处理是被动的。主库key到期后，会在aof文件里面增加一个del指令，同步到所以的从库。</p>
<h2 id="真删除-del"><a href="#真删除-del" class="headerlink" title="真删除 del"></a>真删除 del</h2><p>　　redis的单线程是指接受客户端请求的时候是单线程，基于多路io复用，但是redis里面还是有多个异步子线程来进行一些耗时操作的。<br>　　比如：del删除指令会直接释放对象的内存，对于小对象来说，无所谓，秒删，但是对于大的数据，hash，那么就会造成单线程卡顿，redis提供了一个叫unlink的指令，对删除进行懒操作处理。对给后台线程异步回收内存。同时使用这个指令后，主线程就无法访问到了。<br>　　主线程执行这个指令后，就会将这个key的内存回收操作包装为一个任务，塞进异步任务队列，后台线程就会从这个异步队列里面取任务，然后执行。<br>　　Aof sync 操作中一秒一次增量同步，需要频繁磁盘io,耗时，于是也有一个子线程来异步后台处理</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://skydh.github.io/2018/09/20/redis-stream/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="董航">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="why are you so happy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/20/redis-stream/" itemprop="url">redis -stream</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-20T11:48:31+08:00">
                2018-09-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="诞生"><a href="#诞生" class="headerlink" title="诞生"></a>诞生</h2><p>　　Redis5.0出来的，新的数据结构 Stream 支持多播的可持久化的消息队列。其设计借鉴了kafka的设计。<br>　　这个存储类型是一个数据链表，将所有加入的消息都串起来。每个消息都有唯一的id和对应的内容，消息是持久化的，redis重启后，内容还在，其持久化方式，类似于rdb+aof。<br>　　每个stream都有唯一的一个名称就是其key,我们首次使用xadd指令追加消息时，自动创建，同时每个strean可以同时挂多个消费组，每个消费组都有游标last_delivered_id在Stream数组之上向前移动，表示当前消费组已经消费到哪条消息了，每个消费组都有一个stream内唯一的名称，消费组不会自动创建，需要单独的指令xgroup create进行创建，需要制定从这个stream的某个消息id,表示从这个stream开始消费，这个id用来初始化last_delivered_id变量。<br>　　每个消费组的状态都是独立的。相互不影响，也就是说同一个stream内部的消息会被每个消费组消费到。<br>　　每个消费组可以挂起多个消费者，这些消费者是竞争关系的，一个消息被一个消费者消化了，那就无法被另一个消化。每个消费者组内是唯一的。<br>　　消费者内部有个状态变量pending_ids,它记录了客户端读取的消息，但是没有ack的，如果客户端发了ack,那么这个消息id就会被去掉，它来表示消息是否被至少消费一次。<br>　　消息id是timestampInMillis-sequence，当前时间戳，的第几条消息，同时也可以客户端自己指定，但是形式必须是整数-整数，消息内容是键值对。</p>
<h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><p>　　xadd:追加消息。<br>　　xadd codehole * name laoqian age 30<br>　　xdel:删除消息这里的删除仅仅是设置了标志位，不影响消息总长度。<br>　　xrange:获取消息队列，自动过滤被删除消息。<br>　　xrange codehole - +<br>　　xlen:消息长度。<br>　　xlen codehole<br>　　del：删除stream。</p>
<h2 id="独立消费"><a href="#独立消费" class="headerlink" title="独立消费"></a>独立消费</h2><p>　　我们可以不建立消费组的情况下对stream独立消费，其有一个指令叫做xread,可以将stream当做普通的消息队列（list）来使用，使用xread的时候我们可以忽略消费组的存在，好比stream就是一个普通的列表（list）。xread count 2 streams codehole 0-0表示从头读2个数据，没有数据就一直阻塞。但是我们可以用block来设置阻塞时间，0表示永久阻塞。1000表示1秒。 xread block 1000 count 1 streams codehole $。</p>
<h2 id="创建消费组"><a href="#创建消费组" class="headerlink" title="创建消费组"></a>创建消费组</h2><p>　　Stream通过xgroup createn 创建消费组。需要传递起始消息id作为参数来初始化last_delivered_id。<br>　　xgroup create codehole cg1 0-0：从头开始消费。<br>　　xgroup create codehole cg2 $：从尾部开始消费，只接受新消息。<br>　　 xinfo stream codehole：获取stream信息。</p>
<h2 id="消费"><a href="#消费" class="headerlink" title="消费"></a>消费</h2><p>　　Stream指令xreadgroup可以进行消费组的组内消费，需要消费组名称，消费者名称，起始消息id,读取到新消息后，对应的消息id就会进入消费者的PEL结构里面，等待ack,来删除。</p>
<p>　　 xreadgroup GROUP cg1 c1 count 1 streams codehole   &gt;<br>     命令           消费组 消费者  读几个    那个stream 表示从这个之后读取</p>
<h2 id="限制长度"><a href="#限制长度" class="headerlink" title="限制长度"></a>限制长度</h2><p>　　stream消息要是太多怎么办，一个链表太长了，会导致性能下降很多，而且，删除也是逻辑删除，这边我们可以在创建这个stream的时候设置默认长度，新的覆盖旧的。<br>　　xadd codehole maxlen 3 * name xiaorui age 1　长度为３</p>
<h2 id="pel如何避免消息丢失"><a href="#pel如何避免消息丢失" class="headerlink" title="pel如何避免消息丢失"></a>pel如何避免消息丢失</h2><p>　　当客户端突然断掉了来自服务端的消息，消息丢失了，但是pel里面已经保存了发消息的id,待客户端连上了，我们可以读取pel里面的消息列表，来保证消息不丢失。不过此时 xreadgroup 的起始消息 ID 不能为参数&gt;，而必须是任意有效的消息 ID，一般将参数设为 0-0，表示读取所有的 PEL 消息以及自last_delivered_id之后的新消息。</p>
<h2 id="stream的高可用"><a href="#stream的高可用" class="headerlink" title="stream的高可用"></a>stream的高可用</h2><p>　　这个的高可用是建立在主从复制的基础上的，他和其他数据的复制机制没区别。</p>
<h2 id="分区-Partition"><a href="#分区-Partition" class="headerlink" title="分区 Partition"></a>分区 Partition</h2><p>　　Redis不支持分区功能，如果要分区，那就配置多个stream,然后客户端根据一定策略生成消息到不同stream。
　　</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">董航</p>
              <p class="site-description motion-element" itemprop="description">clear 航</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">112</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            

          </nav>

          

          <div class="links-of-author motion-element">
            
          </div>

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">董航</span>

  
</div>


<div class="powered-by">
<i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv">
  本站访客数:<span id="busuanzi_value_site_uv"></span>
</span>
</div>

  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.3</div>




        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.3"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
