<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="skydh">
<meta property="og:type" content="website">
<meta property="og:title" content="learning, progress, future.">
<meta property="og:url" content="https://skydh.github.io/index.html">
<meta property="og:site_name" content="learning, progress, future.">
<meta property="og:description" content="skydh">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="learning, progress, future.">
<meta name="twitter:description" content="skydh">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://skydh.github.io/"/>





  <title>learning, progress, future.</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">learning, progress, future.</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">skydh</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://skydh.github.io/2020/03/25/java线程，线程池，juc系列/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="skydh">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="learning, progress, future.">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/03/25/java线程，线程池，juc系列/" itemprop="url">java线程，线程池系列</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-25T21:01:40+08:00">
                2020-03-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="线程通信"><a href="#线程通信" class="headerlink" title="线程通信"></a>线程通信</h1><h2 id="wait-notify"><a href="#wait-notify" class="headerlink" title="wait,notify"></a>wait,notify</h2><p>   这2个方法，是Object类的方法，必须要先加锁才可以使用。顺序使用有要求</p>
<h2 id="park-unpark"><a href="#park-unpark" class="headerlink" title="park,unpark"></a>park,unpark</h2><p>   这2个方法，对顺序没有要求，但是不能加锁使用在同步代码块里面。LockSupport类的静态方法。</p>
<p>ps，这个方法的通信条件不要使用if来进行判断，可能出现伪唤醒。使用while来代替。</p>
<h2 id="线程池数量判断规则"><a href="#线程池数量判断规则" class="headerlink" title="线程池数量判断规则"></a>线程池数量判断规则</h2><p>   1.计算类任务<br>   cpu的1-2倍，比如cpu8核，那么16个线程<br>   2.io类任务<br>   因为有io阻塞，要大一点。最佳线程数量 = （（线程等待时间+线程CPU时间）／ 线程CPU时间）* CPU个数</p>
<p>   终极规则：<br>   看看你的cpu使用情况&gt;80%是比较合理的，不断调整</p>
<h2 id="线程加锁"><a href="#线程加锁" class="headerlink" title="线程加锁"></a>线程加锁</h2><p>  synchronized关键字加锁<br>  偏向锁 -轻量级锁-重量级锁，这是java虚拟机做的优化。</p>
<p>  第一个线程第一次加锁（通过偏向锁标识位），那么就会采用偏向锁的机制，修改对象头的标识位，将第一个线程的线程id加进去。<br>  当第二个线程访问这个对象时，判断是否偏向锁，是则第一步，不是则判断是否有线程持有锁，若是没有持有锁，那么cas操作尝试加锁，切将锁升级为轻量级锁，cas操作是，将加锁标识位修改，然后把markword里面的信息，存放到线程栈的私有信息里面去，将其替代为加锁线程的地址。若是有锁，那么自旋多次cas后，还是没有成功，则将其升级为重量级锁。<br>  总量级锁通过monitor来实现，每个对象都有一个monitor。<br>  monitor里面有entrylist,里面是争抢锁的。owner则是锁的持有者，waitset则是owner调用wait后进入的集合。通过notify进入到entrylist里面。</p>
<p>  lock api<br>  ReentrantLock：独享锁，可重入锁，支持公平和不公平<br>  ReadWriteLock:读写锁，其包含2把锁，创建这个读写锁对象后，我们可以通过这个对象获取到2把锁，一个读锁，一个写锁，读锁可以多个线程同时持有，写锁，一个线程持有，在加了读锁后，不能加写锁。（可以用这个特点去做锁降级）。</p>
<p>  aqs，本质上就是通过cas，链表，park,unpark来处理的。</p>
<p>  Semaphore,信号量，创建对象时，指定一个信号量。维护一个原子变量，有2个方法，一个是<br>  acquire：获取一个许可，没有就等待<br>  release:释放一个许可<br>  场景：代码限流，维护一个资源只被限定的线程数量访问<br>  CountDownLatch：到计数器，创建对象时，指定一个计数器。维护一个原子变量，有2个方法，一个是<br>  await():方法等待计数器变为0，在此之前，线程进入等待状态。<br>  countdown():方法使得计数器建一。<br>  场景：统计线程执行情况。看看哪些线程没有执行完。<br>   使用多个线程来计算数据，实现并发处理。<br>   多个线程相互通信。</p>
<p>  CyclicBarrier：线程栅栏。创建对象时，指定一个栅栏线程大小。<br> 。维护一个原子变量，同时可以加一个Runnable接口，作为满足条件后的执行的方法<br>  核心方法是<br>  await():线程调用await方法后，判断当前调用await方法的线程数目是否达到了创建对象所指定的数量，没有达到进入等待状态，达到了，执行后续的方法。<br>  和前面countdownlatch的区别是可以多次执行。每满足一次数量后，就会执行一次调用await方法线程的后续代码和Runnable接口的方法，可以多次</p>
<p>  场景：拼多多拼团购物。<br>   批量插入数据。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://skydh.github.io/2020/03/18/查看jvm运行时参数/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="skydh">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="learning, progress, future.">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/03/18/查看jvm运行时参数/" itemprop="url">查看jvm运行时参数</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-18T09:05:20+08:00">
                2020-03-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="PrintFlagsFinal"><a href="#PrintFlagsFinal" class="headerlink" title="PrintFlagsFinal"></a>PrintFlagsFinal</h1><p>   java -XX:+PrintFlagsFinal  -version<br>  查看虚拟机默认参数</p>
<h1 id="jps"><a href="#jps" class="headerlink" title="jps"></a>jps</h1><p>  专门查看java进程的<br>  jps<br>  jps -l查看完全参数</p>
<h1 id="jinfo"><a href="#jinfo" class="headerlink" title="jinfo"></a>jinfo</h1><p>  jinfo是查看运行时进程的详细信息。比如<br>  jinfo -flag MaxHeapSize 11956<br>  查看这个java进程的最大堆大小<br>  jinfo -flag UseG1GC  11956<br>  查看是否使用了G1垃圾回收器<br>  输出是XX:-UseG1GC，其中-表示没有使用</p>
<h1 id="jstat"><a href="#jstat" class="headerlink" title="jstat"></a>jstat</h1><p>  jstat查看jvm的统计信息<br>  类加载，垃圾回收信息，jit编译信息</p>
<pre><code>jstat -class 11956
Loaded  Bytes  Unloaded  Bytes     Time
28968 58273.9      301   462.6      39.13


jstat -gc 11956
S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT     GCT
512.0  1024.0  0.0    0.0   145920.0  2871.8   453120.0   246336.3  193100.0 179678.6 26240.0 21961.4   1578   12.603 1484   410.614  423.217
</code></pre><p>  S0C,S0U,S1U,S0U,s0,s1区的使用量和总量<br>  EC,EU：Eden区的总量和使用<br>  OC,OU,Old区的总量和使用<br>  MC，MU,Metaspace区总量和使用，其中这个metaspace是存放Class对象的。<br>  CCSC,CCSU,压缩类空间总量和使用。<br>  YGC,YGCT，YoungGC的次数和时间<br>  FGC,FGCT：FullGC的次数和时间<br>  GCT，总GC的时间。</p>
<p>ps 通过官网 <a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/jstat.html#BEHHGFAE来查询" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/technotes/tools/unix/jstat.html#BEHHGFAE来查询</a></p>
<h1 id="如何导出内存镜像文件"><a href="#如何导出内存镜像文件" class="headerlink" title="如何导出内存镜像文件"></a>如何导出内存镜像文件</h1><p>  1，内存溢出是自动导出，加上2个参数<br>  -XX:+HeapDumpOnOutOfMemoryError<br>  -XX:HeapDumpPath=./<br>  2,Jmap导出<br>  jmap -dump:format=b,file=heap.hprof 11956<br>  导出的文件用mat打开，可以查看到对象的数量和大小。可以分析内存溢出的问题。</p>
<h1 id="jstack"><a href="#jstack" class="headerlink" title="jstack"></a>jstack</h1><p>   打印jvm里面所有的线程，看看cpu暴增的原因之类的。java线程的状态有new,runnable,blocked,waiting,timed_waiting,terminated,<br>  cpu飙高，可能是死循环。或者死锁。cpu过大可能导致新的请求无法处理。<br>  方案：<br>  1，查看cpu那个进程高。<br>  2，打印jstack 11569 -&gt;11.txt.<br>  3,top -p 7792 -H,打印所有的线程。找出高的线程，然后将其从10进制转换为16进制，得到一个id<br>  4，在打印的文件里面找到这个id对应的线程，然后分析。具体代码。</p>
<p>  deadlock。</p>
<h1 id="JVisuaIVM"><a href="#JVisuaIVM" class="headerlink" title="JVisuaIVM"></a>JVisuaIVM</h1><p>  可视化监控工具，可以监控远程和本地。<br>  里面有很多功能，和jstack,jmap类似，几乎包含了上面所有的命令以及mat,里面有个抽样的功能，</p>
<p>   其中cpu抽样，可以看到哪个方法的执行时间。从而针对性的优化代码</p>
<p>   内存抽样，可以看到每个类占用的内存实例数等信息。可以看到那些对象可能导致内存泄漏。</p>
<h1 id="Btrace"><a href="#Btrace" class="headerlink" title="Btrace"></a>Btrace</h1><p>  在程序不重启，正在运行的时候修改动态的修改字节码。<br>  下载btrace，然后加入到环境变量，写好脚本，然后执行 btrace pid 脚本，执行完，字节码就加入到运行的环境里面了。只要是java代码都可以拦截。</p>
<p>  参数，返回值，异常都可以获取到，还可以判断某一行代码是否执行</p>
<p>  注意点：1.只能本地执行。不能远程使用。<br>         2.修改了字节码，退出时不会回复</p>
<h1 id="tomcat"><a href="#tomcat" class="headerlink" title="tomcat"></a>tomcat</h1><p>  1,tomcat远程debug<br>  基于JDWP协议，定义了调试器和java虚拟机之间的协议。<br>  主要是修改服务器上tomcat的配置，然后调试。如果是个普通的java进程需要修改这个java进程的启动脚本，加上一些配置。</p>
<p>  2.tomcat-manager<br>   tomcat自带的，还是修改tomact配置，增加用户，增加配置。可以查看tomcat很多信息，比如有哪些应用。且对其进行处理。查看线程信息之类的。以及线程处理时间之类的。</p>
<p>  3.psi-probe<br>  先下载probe这个项目源码，然后打包，将其war包放入到tomcat的webapp下面，即可，启动tomcat即可。tomcat的配置和上面一样。</p>
<p>  4,tomcat优化<br>  1，内存优化<br>  2，线程优化<br>  主要需要配置maxConnections最大连接数。acceptCount：连接满了之后的新的连接进入队列，超出队列，则拒绝请求。maxThread:工作线程数，和cpu相关…<br>  3.配置优化<br>  autoDeploy,周期性检查是否有新的应用加了进来，但是会浪费一个线程资源。默认为true，建议为false.<br>  enableLookups:开启后会对请求做一个dns查询，浪费性能。<br>  reloadable:监控web-inf/classes和web-inf/lib目录，浪费性能。默认没有开启。<br>  还有设置协议为nio,<br>  还可以禁用session，存到redis里面。</p>
<h1 id="nginx"><a href="#nginx" class="headerlink" title="nginx"></a>nginx</h1><p>   可以通过ngxtop,动态查看访问最多的ip,访问最多的返回码等信息。<br>   Mginx-rrd是个图形化工具，这个工具统计的信息可能滞后，因为它是通过定时器来统计的。<br>   优化：<br>   增加工作线程，增加并发连接数，默认是一个工作线程，1024个连接。<br>   一般多少个cpu，就多少个工作线程，启用epoll网络模型。<br>   启用长连接。浏览器和nginx之间是有长连接的，但是Nginx和后端服务之间是没有长连接的，需要配置。<br>   启用缓存，压缩。<br>   操作系统优化。</p>
<h1 id="jvm调优"><a href="#jvm调优" class="headerlink" title="jvm调优"></a>jvm调优</h1><p>jvm内存结构<br>程序计数器：这个就是线程私有的，存放的是线程正在执行指令的地址。<br>java虚拟机栈：线程私有的，生命周期和线程一样，里面的元素是栈帧，每一个栈帧的入栈到出栈意味着一个方法的执行调用和结束。栈帧存放的是方法的局部变量表，返回值信息，方法出口灯<br>java堆，分为新生代，老年代，线程共享的，每一个实例都是在堆里面分配内存的。<br>java方法区，线程公有的，存放，常量。被虚拟机加载的类信息，编译器编译后的代码。（运行时常量池：各种常量信息，在类加载后放进去存放。）</p>
<p>ps：java本地代码，就是采用编译方式启动java进程，然后代码会被jit编译为机器码，放入到metaspace里面</p>
<p>判断对象是否回收的算法<br>可达性分析算法，从根节点到这个对象是否可达。<br>根节点很多：类加载器，Thread，虚拟机栈的本地变量表，常量应用，垃圾回收的时候，通过这些根节点来进行可达性分析。</p>
<p>垃圾回收算法<br> 标记-清除：做可达性分析之后，标记所有可回收的对象，标记完成后统一回收。缺点效率不高，产生大量内存碎片。<br>复制算法，吧内存划分为大小一样的2块，每次使用其中一块，当其中一块无法分配内存后，进行垃圾回收，吧可达的对象复制到另外一块上，再把这块用的空间一次性清除。<br>优点，简单高效<br>缺点，内存利用不高<br>标记-整理。先判断哪些对象是可达的，然后统一向一端移动，然后清除掉边界外单位内存<br>相对于标记清除，少了内存碎片，但是更加耗时。</p>
<p>一般来说，yong区使用复制算法，old区采用标记清除或者标记整理算法。</p>
<p>对象分配：<br>对象优先分配到Eden区，大对象直接到老年代，存活时间长的对象进入老年代。</p>
<p>垃圾回收器<br>串行收集器Serial:Serial,Serial Old，单线程的垃圾回收器。当内存不够时，虚拟机会启动一个单线程的垃圾回收器。<br>并行收集器Parallel: Prallel Scavenge,Parallel Old,吞吐量<br>并行：指多条垃圾回收线程并行工作，用户线程仍然处于等待状态。适合科学计算，后台处理等弱交互场景，</p>
<p>并发收集器Concurrent:CMS,G1,停顿时间。</p>
<p>并发：指多条垃圾回收线程和用户线程并行，也许是交替进行，垃圾回收的时候不会停止用户程序的运行，适合web，对相应时间有要求的应用</p>
<p>停顿时间：垃圾收集器做垃圾回收中断应用执行的时间。XX:MaxGCPauseMillis</p>
<p>吞吐量：华仔垃圾回收的时间和花在应用时间的占比-XXGCRimeRatio=<n>,垃圾收集时间栈：1/1+n</n></p>
<p>-XX:+UseSerialGX -XX:+UseSerialOldGC<br>使用串行，一般不使用</p>
<p>-XX:+UseParallelGC,-XX:+UseParallelGC<br>使用并行，吞吐量优先<br>Server模式下默认收集器。cms是old区的，</p>
<p>并发<br>CMS:XX:+UseConcMarkSweepGC -XX:+UseParNewGC<br>G1:-XX+UseG1GC</p>
<p>由于虚拟机采用分带算法<br>new               old<br>Serial             SerialOld<br>parNew             SerialOld<br>ParaLLelScavenge   SerialOld<br>Serial             CMS<br>ParNew             CMS<br>G1                 G1</p>
<p>其中CMS可能退化为SerialOld,在担保分配空间失败后</p>
<p>如何选择垃圾回收器</p>
<p>1.调整堆的大小让服务器自己选择<br>2.如果内存小于100，串行<br>3，如果单核，且没有停顿时间的要求，串行或者jvm自己选。<br>4，如果允许停止时间超过一秒，选择并行或者jvm自己选。<br>5，响应时间很重要，不能超过一秒，使用并发垃圾回收器。</p>
<p>使用并行垃圾回收器，<br>-XX:+UseParallelGC手动开启<br>-XX：ParallelGCThread=<n>,多少个GC线程。<br>cpu&gt;=8 N=5<br>Cpu&lt;8 N=CPU</n></p>
<p>并行垃圾回收器有个自适应的特性。内存不够了会自动变大。<br>因此一般不使用。</p>
<p>CMS并发<br>低停顿，低延迟<br>老年代</p>
<p>收集过程。<br>1，初始标记，标记GCroot，这个过程需要停止应用程序。<br>2，并发标记。<br>3，并发预处理<br>4，重新标记，也是需要停止应用的，<br>5，并发清除<br>6，并发重置 </p>
<p>缺点，cpu敏感，浮动垃圾，空间碎片。标记清除算法。</p>
<p>CMS参数优化<br>-XX:ConcGCThreads,并发的GC线程数<br>-XX:+UseCMSCompactAtFullCollection：fullGC之后会做压缩，减少内存碎片。<br>可视化GC日志分析工具<br>-XX:CMSFullGCsBeforCompaction:多少次FullGC之后压缩一次。<br>-XX:CMSInitiatingOccupancyFraction:触发FullGC,老年代占了多少比例后会触发这个fullGC，92%<br>-XX：+CMSScavengeBeforRemark:fullGC之前先做YGC。</p>
<p>G1垃圾回收器<br>大内存，小停顿，同时是新生代和老年代。<br>G1里面没有物理意义的新生代和老年代，他是一个个的region，多个region构成了逻辑上的新生代和老年代。<br>StaB,GC开始的时候存活对象的快照。<br>RSet：记录了其他region里面引用了本region对象的关系。<br>G1 YoungGC<br>新生代进入Eden区<br>存活对象进入su区<br>存活时间长的对象进入Old区。<br>和其他一样</p>
<p>没有fuLLGC 只有MixedGC<br>回收Young区和部分Old区。</p>
<p>global concurent marking（全局标记）<br>1,标记GC root,stw<br>2，标记存活Region<br>3.标记存活对象。<br>4.重新标记，stw<br>5.部分stw</p>
<p>MixGC时机</p>
<p>根据参数来设定，InitiatingHeapOccupancyPercent,默认45%，就会触发global concurent marking</p>
<p>G1HeapWastePercent<br>再global concurent marking之后，我们可以判断有多少对象需要回收，在每次YGC之后，和MixEdGC之前，会检查参数是否达到了，如果达到了就会MixedGC</p>
<p>是否需要切换到G1<br>1.50%堆被存活对象占用<br>2，对象分配速度快<br>3，垃圾回收时间长</p>
<p>GC日志简析<br>1吞吐量（应用线程时间和总时间的比例）和停顿时间</p>
<p>通过工具分析<br>1.在线 gceasy.io<br>2.GCViewer</p>
<p>具体的分析都可以在orcal官网查看<br>首先要打印gc日志，输入一些参数，会让gc的时候把文件打印出来。在线工具更加方便</p>
<p>ParallelGC调优原则<br>1.不要设置最大对内存<br>2.优先设置吞吐量目标<br>3.吞吐量达不到要求，调大最大内存，不要让os使用swap，如果还达不到降低吞吐量。<br>4.吞吐量能达到，GC时间长，设置停顿时间目标</p>
<p>就是不断尝试。分析gc次数。 </p>
<p>G1最佳实践<br>1.年轻代：避免使用-XMn,-XX：NewRatio,等显示设置young区大小，会覆盖暂停时间目标。<br>2.暂停时间目标：不要太苛刻，其吞吐量目标是90%的应用时间和10%的垃圾回收时间，太严格影响吞吐量。<br>3.MixGC</p>
<p>分析gC的原因。</p>
<h1 id="字节码"><a href="#字节码" class="headerlink" title="字节码"></a>字节码</h1><p>1，先编译一个java文件，生成class文件<br>2，找到其所在的目录<br>3，执行 javap -verbose aaa.class-&gt;test1.txt</p>
<h1 id="intern区别"><a href="#intern区别" class="headerlink" title="intern区别"></a>intern区别</h1><p>1.6  常量池没有，加进去，有，不管<br>1.7 常量池没有，加个指向堆对象的引用。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://skydh.github.io/2019/12/26/spring常用注解/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="skydh">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="learning, progress, future.">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/26/spring常用注解/" itemprop="url">spring常用注解</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-12-26T14:00:28+08:00">
                2019-12-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="lazy"><a href="#lazy" class="headerlink" title="@lazy"></a>@lazy</h1><p>　　这个注解和spring 单例结合使用，当你需要用这个bean时才会去选择创建。</p>
<h1 id="Configuration"><a href="#Configuration" class="headerlink" title="@Configuration"></a>@Configuration</h1><p>　　这个类似于我们之前的bean配置文件，在里面，我们通过@Bean注解注入bean到bena容器</p>
<h1 id="Conditional"><a href="#Conditional" class="headerlink" title="@Conditional"></a>@Conditional</h1><p>　　这个注解，按照条件来注入bean。这个注解里面有个参数，就是一个Conditional接口数组，里面有个方法返回布尔。</p>
<h1 id="import"><a href="#import" class="headerlink" title="@import"></a>@import</h1><p>　　里面有个参数是Class数组，如果是普通的类直接注入进去，如果是实现了ImportSelector接口的，则将实现这个接口方法的返回值注入进去，实现这个接口注入的bean的id都是类全限定名。第三个就是实现了ImportBeanDefinitionRegistrar接口的bean,在这个方法里面可以主动注册bean到bean容器里面。</p>
<h1 id="factorybean"><a href="#factorybean" class="headerlink" title="factorybean"></a>factorybean</h1><p>　　这个bean比较特殊，这类bean是实现了factorybean接口的类，里面有个getObject方法，当我们尝试将这个bean获取的时候，返回的对象是其getObject方法返回的对象。如果要获取这个bean本身，那么我们调用getBean时，需要加个&amp;符号就可以了</p>
<h1 id="bean的生命周期"><a href="#bean的生命周期" class="headerlink" title="bean的生命周期"></a>bean的生命周期</h1><p>　　生命周期为bean的创建，bean的初始化，bean的销毁。初始化方法是在对象初始化装配结束后执行的。<br>　　我们可以在在@Bean注解上面指定初始化方法和销毁方法这个方法必须在你的bean定义里面。bean的销毁是在容器关闭的时候进行，初始化则是在容器创建后执行。<br>　　或者实现InitializingBean,DisposableBean方法来实现初始化和销毁方法。<br>　　或者通过注解@PostConstruct ,@Predestroy放到类对应方法上。<br>　　或者通过接口BeanPostProcessor有2和方法，第一个方法，是在初始化方法调用执行前执行，一个是初始化执行后调用。将这个实现了这个接口的方法加入到bean，就可以在所有的bean的初始化方法调用前后执行。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://skydh.github.io/2019/12/03/java 并发001/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="skydh">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="learning, progress, future.">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/03/java 并发001/" itemprop="url">java 并发001</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-12-03T18:36:54+08:00">
                2019-12-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="CSA原理"><a href="#CSA原理" class="headerlink" title="CSA原理"></a>CSA原理</h2><p>　　CAS,(Compare-And-Swap,比较和替换)。其具有三个操作数：内存地址V，旧的预期值A，新的预期值B。当V中的值和A相同时，则用新值B替换V中的值，否则不执行更新。（PS：上述的操作是原子性的，因为过程是：要么执行更新，要么不更新），这个操作是CPU内部执行的，是原子的。类sun.misc.Unsafe提供了大量cas操作的方法。</p>
<h2 id="不同类型的锁"><a href="#不同类型的锁" class="headerlink" title="不同类型的锁"></a>不同类型的锁</h2><h3 id="阻塞锁"><a href="#阻塞锁" class="headerlink" title="阻塞锁"></a>阻塞锁</h3><p>　　让线程进入阻塞状态，等待唤醒信号，唤醒后才可以进入到就绪状态，通过竞争，进入运行状态。支持阻塞锁的方法有，synchronized关键字，ReentrantLock的lock和unlock方法，以及Object类的wait和notify方法。</p>
<h2 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h2><p>　　当一个线程获取锁时，但是锁被其他线程获取了，该线程就不断自循环来不断获取锁。</p>
<h2 id="非公平锁"><a href="#非公平锁" class="headerlink" title="非公平锁"></a>非公平锁</h2><p>　　１．当有线程竞争锁时，该线程会优先尝试获得锁，这对那些已经在队列等待的线程来说不公平，这就是不公平锁，但是会极大的提高性能。如果没有获取到锁，那么就会添加到对列尾部。</p>
<h2 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h2><p>　　AQS核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制AQS是用CLH队列锁实现的，即将暂时获取不到锁的线程加入到队列中。CLH(Craig,Landin,and Hagersten)队列是一个虚拟的双向队列（虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系）。AQS是将每条请求共享资源的线程封装成一个CLH锁队列的一个结点（Node）来实现锁的分配。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://skydh.github.io/2019/11/14/深入理解kafka客户端/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="skydh">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="learning, progress, future.">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/11/14/深入理解kafka客户端/" itemprop="url">深入理解kafka客户端</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-11-14T15:24:53+08:00">
                2019-11-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>#　分区分配策略</p>
<h2 id="RangeAssignor"><a href="#RangeAssignor" class="headerlink" title="RangeAssignor"></a>RangeAssignor</h2><p>　　默认策略，先把这个消费组的消费者按照字典排序。然后主题的分区数目均匀分布到消费者上面，无法均匀的话，字典顺序靠前的多一点。缺点就是可能不均匀</p>
<h2 id="RoundRobinAssignor"><a href="#RoundRobinAssignor" class="headerlink" title="RoundRobinAssignor"></a>RoundRobinAssignor</h2><p>　　还是先把消费者和消费者订阅的分区按照字典排序，然后轮训的方式一个一个分配节点，相对前面的来说解决了均匀问题，但是在订阅不均匀的情况下，分配可能极度不均匀。</p>
<h2 id="StickAssignor"><a href="#StickAssignor" class="headerlink" title="StickAssignor"></a>StickAssignor</h2><p>　　前期和RoundRobinAssignor一样，后期则是不一样，发生变化时，RoundRobinAssignor是全部重新弄，StickAssignor则是更具当前的重新进行分配。相对RoundRobinAssignor做了优化，尽量减少了变动。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://skydh.github.io/2019/11/12/kafka 服务端基本知识/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="skydh">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="learning, progress, future.">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/11/12/kafka 服务端基本知识/" itemprop="url">kafka 服务端基本知识</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-11-12T14:06:44+08:00">
                2019-11-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>#　协议结构</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://skydh.github.io/2019/11/05/mysql 双1配置/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="skydh">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="learning, progress, future.">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/11/05/mysql 双1配置/" itemprop="url">Mysql 双一配置保证数据0丢失</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-11-05T15:15:34+08:00">
                2019-11-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h2><p>　　请先看mysql如何做到crash后无损恢复数据。了解下mysql是如何数据落地磁盘的。</p>
<h2 id="binlog"><a href="#binlog" class="headerlink" title="binlog"></a>binlog</h2><p>　　事务执行时先把日志写到binlog cache,事务提交，binlog cache就将日志写到文件系统的page cache,这个操作叫做write。 然后等fsync来刷盘，持久化磁盘数据，这个操作叫做fsync。这2个操作是由一个叫做sync_binlog来控制的。</p>
<ul>
<li>sync_binlog=0 的时候，表示每次提交事务都只 write，不 fsync；</li>
<li>sync_binlog=1 的时候，表示每次提交事务都会执行 fsync；</li>
<li>sync_binlog=N(N&gt;1) 的时候，表示每次提交事务都 write，但累积 N 个事务后才 fsync。</li>
</ul>
<p>　　实际业务场景是100-1000，但是对于强数据安全的，可以设置为1，这个1就是双1中的1。</p>
<h2 id="redolog"><a href="#redolog" class="headerlink" title="redolog"></a>redolog</h2><p>　　和前面的binlog差不多，事务执行的时候先把数据写入到redo log buffer里面，事务提交就开始写入到page cache里面，也就是write操作，第三步就是fsync操作，将文件系统缓存的page cache持久化到磁盘里面去。</p>
<p>　　为了控制 redo log 的写入策略，InnoDB 提供了 innodb_flush_log_at_trx_commit 参数，它有三种可能取值：</p>
<ul>
<li>设置为 0 的时候，表示每次事务提交时都只是把 redo log 留在 redo log buffer 中 ;</li>
<li>设置为 1 的时候，表示每次事务提交时都将 redo log 直接持久化到磁盘；</li>
<li>设置为 2 的时候，表示每次事务提交时都只是把 redo log 写到 page cache。</li>
</ul>
<p>　　而这个１就是就是双一的最后一个１了</p>
<p>　　不仅仅如此，其实也没那么简单，比如redo log buffer快满了，怎么办，别的事务没提交怎么办，这些当然都是直接先写入磁盘处理。</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>　　Mysql默认就是双一配置。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://skydh.github.io/2019/10/31/mysql 如何做到crash后无损恢复数据的/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="skydh">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="learning, progress, future.">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/31/mysql 如何做到crash后无损恢复数据的/" itemprop="url">mysql 如何做到crash后无损恢复数据的</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-31T11:21:21+08:00">
                2019-10-31
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h2><p>　　真实的流程没有我说的那么简单，下面的是最基本的情况。</p>
<h2 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h2><ul>
<li>redolog</li>
<li>binlog</li>
<li>WAL机制</li>
</ul>
<h2 id="redolog简介"><a href="#redolog简介" class="headerlink" title="redolog简介"></a>redolog简介</h2><p>　　redolog是个循环日志，其大小固定为4g，存在2个指针来定位其是否已经满了。一个指针是当前写，一个指针是当前checkpoint,其2个指针的顺时针空间就是可写的空间。</p>
<p>　　这个redolog就是完成mysql突然宕机后，如何无损恢复数据的。</p>
<h2 id="binlog简介"><a href="#binlog简介" class="headerlink" title="binlog简介"></a>binlog简介</h2><p>　　这个是mysql自身的日志，叫做归档日志。和redolog大致3个不同点。</p>
<ul>
<li>其为mysql自带的，redolog是innodb里面的。</li>
<li>redolog是物理日志，binlog是逻辑日志。</li>
<li>redolog是循环日志，binlog是增量日志。</li>
</ul>
<p>　　这里不对其过多介绍，下一篇文章关于主从的详细介绍，主从就是通过binlog完成的。</p>
<h2 id="WAL机制简介"><a href="#WAL机制简介" class="headerlink" title="WAL机制简介"></a>WAL机制简介</h2><p>　　MySQL里经常说到的 WAL 技术，意思就是数据入库前先写进去日志，再写磁盘里面。<br>　　这里采用的是数据安全性最高的双1策略。<br>　　其数据更新顺序也保持着其顺序。<br>　　下面我来简单介绍下。<br>　　1.当要更新id=2这一行数据时，先通过这个表的索引，查询到这行记录所在的数据页。然后判断这个数据页是否在buffer pool(这个是内存)。<br>　　2.如果不在内存则需要读到内存（其实也可以不用读入内存，当要更新的这行数据没有唯一索引时，mysql为了提高效率，采用了change buffer(别看有个buffer，但是人家也是持久化到磁盘的)这个东西，将对这行修改的动作记录到change buffer里面，就不用读到内存了）。<br>　　3.在buffer pool 内存上修改这行数据（仅仅只是在内存上修改了这行数据，并没有持久化到磁盘里面）。<br>　　4.将上面的操作，写入到redolog里面，且将这个操作状态设置为prepare状态，首先写到redologbuffer里面（为了提高效率，mysql做了组提交这个优化，这里不扩展），等到这个事务提交后，redologbuffer然后再写入到文件系统的page cache里面，然后立马调用fsync,将其刷到磁盘。<br>　　5.然后写入到binlog里面，先写到binlog cache里面，然后写入page cache,然后调用fsync，写入磁盘。<br>　　6.redolog继续写一次，将其状态设置为commit状态。<br>　　如此就算完成了一个更新操作。</p>
<h2 id="mysql-如何做到crash后，数据不丢失的"><a href="#mysql-如何做到crash后，数据不丢失的" class="headerlink" title="mysql 如何做到crash后，数据不丢失的"></a>mysql 如何做到crash后，数据不丢失的</h2><p>　　前面说了数据更新操作。<br>　　当前buffer pool里面存在大量脏页（就是一些数据页，只在内存里面修改了，没有刷新到磁盘），当系统宕机了，内存里面的数据全部丢失了怎么办？<br>　　方法如下：我们需要redolog来完成灾难备份，check point到writ pos这块空间记录的所有的操作步骤派上用场了，根据这些redolog记录从磁盘里面读取所有相关的数据页。然后按照redolog上的操作恢复数据即可，那么我们发现存再内存的数据全部恢复了。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://skydh.github.io/2019/10/22/kafka日志存储 /">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="skydh">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="learning, progress, future.">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/22/kafka日志存储 /" itemprop="url">kafka入门006 -日志存储</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-22T15:39:21+08:00">
                2019-10-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>#　文件结构<br>　　前面说过kafka的有序是分区的有序性，一个分区时一个log文件，一个log文件划分为多个日志分段（logsegment）。其中log在物理存储上只以文件夹的形式存储，每个logsegmen对应磁盘上的一个日志文件和2个索引文件。</p>
<h1 id="消息压缩"><a href="#消息压缩" class="headerlink" title="消息压缩"></a>消息压缩</h1><p>　　在kafka中，kafka将多条消息一起压缩。发送到broker之后也是保持压缩状态存储，消费者端从broker获取到的也是压缩的消息，消费者在处理这些消息的时候才会解压消息。<br>　　多个消息压缩到一起发送，这个压缩体叫做外层消息，里面有个value保存的则是多个压缩的消息，叫做内层消息。内层消息内部是多个消息的压缩，内部自己维持一个offset,从0开始，同时外层消息也有个offset，这个offset是内层消息最后一个offset的实际位移。</p>
<p>　　外层消息也有个timestamp。</p>
<ul>
<li>当这个timestamp类型是createTime,那么设置的是内层消息的最大时间戳。</li>
<li>当这个类型是LogAppendTime,那么设置的是kafka服务器当前时间戳。</li>
</ul>
<p>　　内层消息里面有个时间戳timestamp。</p>
<ul>
<li>当这个外层timestamp类型是createTime,那么内层消息的时间戳设置的是生产者创建消息时的时间戳。</li>
<li>当这个外层timestamp类型是createTime,那么内层消息的时间戳会被忽略。<br>*<h1 id="变长长度"><a href="#变长长度" class="headerlink" title="变长长度"></a>变长长度</h1>　　kafka引入Varints变长整形，Varints是使用一个或者多个字节来序列化整数的方法，数值越小，占用字节数越小，Varints每个字节除了最后一个字节外最高位都是1。最后一个字节最高位是0，用于区分是否表示一个整数，除了最高位，其余的位表示数据存储。由于是变长字段，因此存储消息时很灵活。<h1 id="日志索引"><a href="#日志索引" class="headerlink" title="日志索引"></a>日志索引</h1>　　前面说了每个日志分段文件对应２个索引文件，但是不保证每个消息都可以在索引文件里面找到索引项的。这个索引文件时每当消息，写入一定量（log.index.interval.bytes默认4kb），偏移量索引文件和时间索引文件会分别增加一个索引项。索引文件都是按顺序递增的，因此我们可以使用二分查找来。</li>
</ul>
<p>　　日志文件也会分隔，满足以下条件就会分隔</p>
<ul>
<li>日志文件大小超过 log.segment.bytes,分隔，默认1GB。</li>
<li>当前日志分段中最大时间戳和当前系统时间戳差值大于log.roll.ms或者log.roll.hours,第一个优先级最高，但是默认第二个，也就是一周。</li>
<li>2个索引文件大小超过log.index.size.max默认10MB时。</li>
<li>追加消息偏移量和当前日志最大的偏移量的差值大于Integer.MAX_VALUE。</li>
</ul>
<p>　　对于非活跃日志分段，对应的索引文件是只读，对于活跃日志分段，对应的日志分段是可读写，在索引文件切分的时候，则变成只读，同时创建可读写的新的索引文件。其文件会预分配log.index.size.max.bytes的大小空间.只有当索引文件裁剪时才会将文件剪裁到实际大小。<br>#</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://skydh.github.io/2019/10/21/zookeeper/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="skydh">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="learning, progress, future.">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/21/zookeeper/" itemprop="url">zookeeper 入门 001</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-21T17:22:25+08:00">
                2019-10-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="用处"><a href="#用处" class="headerlink" title="用处"></a>用处</h1><ul>
<li>配置管理</li>
<li>分布式锁</li>
<li>组成员管理（hbase）</li>
<li>DNS服务<h1 id="不适合"><a href="#不适合" class="headerlink" title="不适合"></a>不适合</h1></li>
<li>存储大量数据，只适合存储协调服务的关键数据</li>
</ul>
<h1 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h1><p>　　主要用于搭配kafka进行学习。因为kafka就是使用zookeeper作为协调服务用的。</p>
<h1 id="zookeeper存储模型"><a href="#zookeeper存储模型" class="headerlink" title="zookeeper存储模型"></a>zookeeper存储模型</h1><p>　　Zookeeper的存储结构采用的是层次化的文件结构模型，很像数据结构当中的树，也很像文件系统的目录。树是由节点所组成，Zookeeper的数据存储也同样是基于节点，这里称之为znode。<br>　　Znode包含4个信息。<br>　　data:Znode存储的数据信息。<br>　　ACL:记录Znode的访问权限，哪些ip那些人可以访问本节点。<br>　　stat:包含Znode的各种元数据，比如事务id,大小，时间戳等。</p>
<h1 id="Znode特点"><a href="#Znode特点" class="headerlink" title="Znode特点"></a>Znode特点</h1><ul>
<li>Znode的引用方式是路径引用，类似于文件路径：/a/b。</li>
<li>znode数据只支持全量读取和写入。</li>
<li>Znode的API都是互不影响的。<h1 id="ZNode分类"><a href="#ZNode分类" class="headerlink" title="ZNode分类"></a>ZNode分类</h1></li>
<li>持久。zookeeper集群，client宕机后，重启依旧还在。</li>
<li>临时。client宕机，或者一定时间没有发消息，那就消失。</li>
</ul>
<h1 id="zk-session"><a href="#zk-session" class="headerlink" title="zk session"></a>zk session</h1><p>   zk session是zk客户端和zk集群中某一个节点建立的，客户端可以主动关闭session,zk节点如果在这个session所关联的timeout时间内收到客户端消息，zk客户端也会关闭节点，如果zk客户端发现所连接的zk节点出错，会自动和其他zk节点建立连接。</p>
<h1 id="zk-Quorun模式"><a href="#zk-Quorun模式" class="headerlink" title="zk Quorun模式"></a>zk Quorun模式</h1><p>　　这个模式就是集群模式，包含多个zookeeper节点，其中一个是lead节点，其余的是follower节点。lead节点可以处理读写请求，follower节点只能处理读请求，若是follower节点收到写请求，会将其转发给lead处理。</p>
<p>　</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/13/">13</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">skydh</p>
              <p class="site-description motion-element" itemprop="description">skydh</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">127</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            

          </nav>

          

          <div class="links-of-author motion-element">
            
          </div>

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">skydh</span>

  
</div>


<div class="powered-by">
<i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv">
  本站访客数:<span id="busuanzi_value_site_uv"></span>
</span>
</div>

  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.3</div>




        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.3"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
