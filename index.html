<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="skydh">
<meta property="og:type" content="website">
<meta property="og:title" content="learning, progress, future.">
<meta property="og:url" content="https://skydh.github.io/index.html">
<meta property="og:site_name" content="learning, progress, future.">
<meta property="og:description" content="skydh">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="learning, progress, future.">
<meta name="twitter:description" content="skydh">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://skydh.github.io/"/>





  <title>learning, progress, future.</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">learning, progress, future.</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">skydh</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://skydh.github.io/2020/07/07/go学习/go学习2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="skydh">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="learning, progress, future.">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/07/07/go学习/go学习2/" itemprop="url">go学习2</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-07-07T21:07:12+08:00">
                2020-07-07
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="基础包介绍"><a href="#基础包介绍" class="headerlink" title="基础包介绍"></a>基础包介绍</h2><ul>
<li>strings</li>
</ul>
<p>strings主要针对utf-8 编码，实现一些简单函数，字符串的很多函数基本方法。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">/是否包含指定的字符串中任意一个字符 有一个出现过 就返回<span class="literal">true</span></span><br><span class="line">fmt.Println(strings.ContainsAny(s1,<span class="string">"glass"</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回指定字符出现的次数 </span></span><br><span class="line">fmt.Println(strings.Count(s1,<span class="string">"g"</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">//文本的开头</span></span><br><span class="line">fmt.Println(strings.HasPrefix(s1,<span class="string">"ok"</span>))</span><br><span class="line"><span class="comment">//文本的结尾</span></span><br><span class="line">fmt.Println(strings.HasSuffix(s1,<span class="string">".txt"</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">//查找指定字符在字符串中存在的位置 如果不存在返回-1</span></span><br><span class="line">fmt.Println(strings.Index(s1,<span class="string">"g"</span>))</span><br><span class="line"><span class="comment">//查找字符中任意一个字符出现在字符串中的位置</span></span><br><span class="line">fmt.Println(strings.IndexAny(s1,<span class="string">"s"</span>))</span><br><span class="line"><span class="comment">//查找指定字符出现在字符串中最后一个的位置</span></span><br><span class="line">fmt.Println(strings.LastIndex(s1,<span class="string">"s"</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">//字符串的拼接</span></span><br><span class="line">s2:=[]<span class="keyword">string</span>&#123;<span class="string">"123n"</span>,<span class="string">"abc"</span>,<span class="string">"ss"</span>&#125;</span><br><span class="line">s3:=strings.Join(s2,<span class="string">"_"</span>)</span><br><span class="line">fmt.Println(s3)<span class="comment">// 123n_abc_ss</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//字符串的切割</span></span><br><span class="line">s4:=strings.Split(s3,<span class="string">"_"</span>)</span><br><span class="line">fmt.Println(s4)<span class="comment">// 返回切片[]string&#123;"123n","abc","ss"&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//字符串的替换</span></span><br><span class="line">s5 := <span class="string">"okoletsgo"</span></span><br><span class="line">s6 := strings.Replace(s5, <span class="string">"o"</span>, <span class="string">"*"</span>, <span class="number">1</span>)</span><br><span class="line">fmt.Println(s6)<span class="comment">//*koletsgo</span></span><br><span class="line"><span class="comment">//TODO 1 只替换1次,  -1 全部替换</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//字符串的截取</span></span><br><span class="line"><span class="comment">//str[start:end]包含start 不包含end</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>strconv :主要用于字符串和基本类型的数据类型的转换</p>
</li>
<li><p>time: time包操作的都是时间，时间的单位都包括年，月，日，时，分，秒，毫秒，微妙，纳秒，皮秒</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">t := time.Now()</span><br><span class="line">	fmt.Println(t) <span class="comment">//2020-03-31 21:26:01.7307507 +0800 CST m=+0.001999001</span></span><br><span class="line">	<span class="comment">//获取的时间后面的信息是时区</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//上面的时间看起来不是很方便 于是需要格式化时间</span></span><br><span class="line">	s := t.Format(<span class="string">"2006年1月3日 15:04:05"</span>)</span><br><span class="line">	fmt.Println(s)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>需要注意的室Go语言中时间的格式化，需要指定格式化时间的模板, 不管年月日的类型格式怎么写，但是具体的数值必须写成<code>2006-01-02 15:04:05</code>， 如果不是这个日期就不能够格式化，这个时间也是为了纪念Go语言诞生的时间。</p>
<h2 id="包管理"><a href="#包管理" class="headerlink" title="包管理"></a>包管理</h2><p>早期的Golang被很多开发者所诟病的一个问题就是依赖包的管理。Golang 1.5 release版本的发布之前，只能通过设置多个GOPATH的方式来解决这个问题，例如:我两个工程都依赖了Beego，但A工程依赖的是<code>Beego1.1</code>,B工程依赖的是<code>Beego1.7</code>,我必须设置两个GOPATH来区分，并且在切换工程的时候GOPATH也得切换，无比痛苦。终于终于在Golang 1.5 release 开始支持除了GOROOT和GOPATH之外的依赖查询，那就是<code>vender</code></p>
<p>但是现在模块管理，包管理一般都是使用mod,go官方推荐的。</p>
<p>环境变量中可以增加<code>GOPROXY=https://goproxy.io</code> 这样没有梯子的情况下可以正确的加载相应的包文件。</p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>我们自定义函数的时候，需要注意按照规则定义必须满足以下格式，函数的名字可以由字母和数字组成，但是不能是数字开头，函数的首字母区分大小写，如果是大写的表示公共的函数，其他包内可以调用到，相当于其他语言中的public 前提是在别的包中引入了当前包。如果是小写的，表示私有的函数，仅能够在本包中调用，相当于其他语言中的private。</p>
<p>函数可以定义多个返回值，并且返回值类型，返回值数量都必须是一一对应的，return是将结果返回到函数的调用处，结束函数的执行。 <code>_</code> 空白标识符，舍弃返回的数据。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	s1:=[<span class="number">2</span>]<span class="keyword">string</span>&#123;&#125;</span><br><span class="line">	s3,_:=join(s1)</span><br><span class="line">	fmt.Println(s3)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">join</span><span class="params">(ele [2]<span class="keyword">string</span>)</span> <span class="params">([2]<span class="keyword">string</span>,<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span>  ele,<span class="number">12</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数也可以声明为一个变量。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c:=join</span><br><span class="line">c(s1)</span><br></pre></td></tr></table></figure>
<p>匿名函数</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">res:=<span class="function"><span class="keyword">func</span><span class="params">(a <span class="keyword">int</span>,b <span class="keyword">int</span>)</span> <span class="title">int</span></span>&#123;</span><br><span class="line">		fmt.Println(a+b)</span><br><span class="line">		<span class="keyword">return</span>  a+b</span><br><span class="line">	&#125;(<span class="number">12</span>,<span class="number">13</span>)</span><br><span class="line">	fmt.Println(res)</span><br><span class="line"></span><br><span class="line">	a:=<span class="function"><span class="keyword">func</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">		<span class="keyword">return</span> a + b</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(a)</span><br></pre></td></tr></table></figure>
<p>加了后面的（），才算调用，不然不算调用。</p>
<ul>
<li>匿名函数可以作为另一个函数的参数</li>
<li>匿名函数可以作为另一个函数的返回值</li>
<li>根据go语言的数据类型的特点，函数也是一种类型，所以可以将一个函数作为另一个函数的参数传递func1()和func2()是两个函数，将func1函数作为func2这个函数的参数，func2函数就叫做高阶函数，因为他接收了一个函数作为参数。所以func1叫做回调函数，他作为另一个函数的参数。</li>
</ul>
<h3 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h3><p>defer 表示延时推迟的意思，在go语言中用来延时一个函数或者方法的执行。如果一个函数或者方法添加了defer关键字，表示则暂时不执行，等到主函数的所有方法都执行完后才开始执行。</p>
<p>当多个函数被defer的时候他们被添加到一个堆栈中，并且根据先进后出的原则执行。 即 <code>Last In First Out（LIFO）</code></p>
<p>defer函数调用时候，参数已经传递了，只不过代码暂时不执行而已。等待主函数执行结束后，才会去执行。</p>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>一个外层函数当中有内层函数，这个内层函数会操作外层函数的局部变量。并且，外层函数把内层函数作为返回值，则这里内层函数和外层函数的局部变量，统称为 <strong>闭包结构</strong> 。 这个外层函数的局部变量的生命周期会随着发生改变，原本当一个函数执行结束后，函数内部的局部变量也会随之销毁。但是闭包结构内的局部变量不会随着外层函数的结束而销毁。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    res := closure()</span><br><span class="line">    fmt.Println(res) <span class="comment">//0x49a880  返回内层函数函数体地址</span></span><br><span class="line">    r1 := res()      <span class="comment">//执行closure函数返回的匿名函数</span></span><br><span class="line">    fmt.Println(r1)  <span class="comment">//1</span></span><br><span class="line">    r2 := res()</span><br><span class="line">    fmt.Println(r2) <span class="comment">//2 </span></span><br><span class="line">    <span class="comment">//普通的函数应该返回1，而这里存在闭包结构所以返回2 。</span></span><br><span class="line">    <span class="comment">//一个外层函数当中有内层函数，这个内层函数会操作外层函数的局部变量,并且外层函数把内层函数作为返回值,则这里内层函数和外层函数的局部变量,统称为闭包结构。这个外层函数的局部变量的生命周期会发生改变，不会随着外层函数的结束而销毁。</span></span><br><span class="line">    <span class="comment">//所以上面打印的r2 是累计到2 。</span></span><br><span class="line"></span><br><span class="line">    res2 := closure() <span class="comment">//再次调用则产生新的闭包结构 局部变量则新定义的</span></span><br><span class="line">    fmt.Println(res2)</span><br><span class="line">    r3 := res2()<span class="comment">//1</span></span><br><span class="line">    fmt.Println(r3)</span><br><span class="line">    	r4 := res()</span><br><span class="line">	fmt.Println(r4)<span class="comment">//3</span></span><br><span class="line">	fmt.Println(res())<span class="comment">//4</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个闭包结构的函数 返回一个匿名函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">closure</span><span class="params">()</span> <span class="title">func</span><span class="params">()</span> <span class="title">int</span></span> &#123; <span class="comment">//外层函数</span></span><br><span class="line">    <span class="comment">//定义局部变量a</span></span><br><span class="line">    a := <span class="number">0</span> <span class="comment">//外层函数的局部变量</span></span><br><span class="line">    <span class="comment">//定义内层匿名函数 并直接返回</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">int</span></span> &#123; <span class="comment">//内层函数</span></span><br><span class="line">        a++ <span class="comment">//在匿名函数中将变量自增。内层函数用到了外层函数的局部变量，此变量不会随着外层函数的结束销毁</span></span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><p>指针是存储另一个变量的内存地址的变量。 例如： 变量B的值为100， 地址为0x1122。变量A的值为变量B的地址0x1122，那么A就拥有了变量B的地址，则A就成为指针。Go语言中通过<code>&amp;</code>获取变量的地址。通过<code>*</code>获取指针所对应的变量存储的数值。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a := <span class="number">2</span></span><br><span class="line"><span class="keyword">var</span> i *<span class="keyword">int</span>         <span class="comment">//声明一个int类型的指针</span></span><br><span class="line">fmt.Println(&amp;a)	   <span class="comment">//0xc00000c1c8</span></span><br><span class="line">i = &amp;a             <span class="comment">//将a的地址取出来放到i里面</span></span><br><span class="line">fmt.Println(&amp;i)    <span class="comment">//0xc000006028</span></span><br><span class="line"><span class="keyword">var</span> a2 **<span class="keyword">int</span>       <span class="comment">//声明一个指针类型的指针</span></span><br><span class="line">a2 = &amp;i            <span class="comment">//再把i的地址放进a2里面</span></span><br><span class="line">fmt.Println(a2)    <span class="comment">//获取的是a2所对应的数值0xc000006028也就是i的地址</span></span><br></pre></td></tr></table></figure>
<p>指针的指针，无线套娃。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个普通的数组</span></span><br><span class="line">arr := [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">fmt.Println(arr)</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个指针 用来存储数组的地址 即：数组指针</span></span><br><span class="line"><span class="keyword">var</span> p *[<span class="number">3</span>]<span class="keyword">int</span></span><br><span class="line">p = &amp;arr        <span class="comment">//将数组arr的地址，存储到数组指针p上。</span></span><br><span class="line">fmt.Println(p[<span class="number">0</span>])  <span class="comment">//数组的指针 &amp;[1 2 3] 后面跟数组的内容</span></span><br><span class="line">fmt.Println((*p)[<span class="number">0</span>])  <span class="comment">//数组的指针 &amp;[1 2 3] 后面跟数组的内容</span></span><br></pre></td></tr></table></figure>
<p>直接传递数组是传递的数据，传递指针，才是传递真实数据</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://skydh.github.io/2020/06/29/go学习/go学习1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="skydh">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="learning, progress, future.">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/06/29/go学习/go学习1/" itemprop="url">go学习1</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-06-29T09:18:48+08:00">
                2020-06-29
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p><a href="https://golang.google.cn/dl/" target="_blank" rel="noopener">https://golang.google.cn/dl/</a> 官网直接安装go。</p>
<p>打开cmd 输入 go version</p>
<p>然后安装ide，这边使用的是goland。</p>
<p>安装包和破解文件都在里面：直接安装，然后将jetbrains-agent-latest.zip拖到goland窗口，重启即可。</p>
<p><a href="https://pan.baidu.com/s/1eyKoegOhHppqTxtNbHunpQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1eyKoegOhHppqTxtNbHunpQ</a></p>
<p>w1m2</p>
<h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	fmt.Println(<span class="string">"ok"</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>入门代码：输出一个ok</p>
<p>go有如下规则：</p>
<ul>
<li>每个源文件都有一个专门的package</li>
<li>程序的入口依旧是main函数</li>
<li>main函数必须在main  这个package下。</li>
<li>文件名称和package没有直接联系</li>
<li>可以 go run这个go文件，也可以go build这个模块后，生成对应的可执行的机器文件，直接执行。</li>
</ul>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>Go语言是静态强类型语言，所以变量是有明确类型的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> age <span class="keyword">string</span>     <span class="comment">//声明 未赋值默认为0</span></span><br><span class="line">age = <span class="string">"18"</span></span><br></pre></td></tr></table></figure>
<p>可以声明其类型，然后赋值</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"王钢蛋"</span> </span><br><span class="line"><span class="keyword">var</span> age = <span class="number">10</span></span><br></pre></td></tr></table></figure>
<p>也可以直接赋值。</p>
<p>Go语言支持根据数据推导数据类型的方法。所以在定义的时候可以不用写数据类型，直接根据你所初始化的值，来推导出定义的数据类型。</p>
<ul>
<li>变量在使用前必须先声明。</li>
<li>变量名不能重复定义。</li>
<li>如果是简短定义方式，左边至少有一个是新的变量。</li>
<li>如果定义了变量，必须得使用，否则编译无法通过。</li>
<li>全局变量可以不使用也能编译通过，定义的全局变量和局部变量名称如果相同，则会优先使用局部变量。</li>
<li>简短定义方式不能定义全局变量，也就是不能声明在函数外部</li>
</ul>
<h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="number">111</span></span><br></pre></td></tr></table></figure>
<p>由var变成了const</p>
<ul>
<li>常量数值不能修改。</li>
<li>常量定义后可以不使用。</li>
<li>常量定义不能使用简短定义方式。</li>
<li>常量中使用的数据类型只能是 整型、布尔、浮点、复数类型、字符串类型。</li>
</ul>
<p>iota是常量里面的计数器，初始值默认值是0，可以被编译器自动修改，每定义一组常量时，iota逐行自增1。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span>(</span><br><span class="line">		a=<span class="number">1</span>+<span class="literal">iota</span></span><br><span class="line">		b=<span class="number">3</span>+<span class="literal">iota</span></span><br><span class="line">		c</span><br><span class="line">		d</span><br><span class="line">		e=<span class="string">"asd"</span></span><br><span class="line">		f</span><br><span class="line">		g=<span class="literal">iota</span></span><br><span class="line"></span><br><span class="line">	)</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">asd</span><br><span class="line">asd</span><br><span class="line">6</span><br></pre></td></tr></table></figure>
<p>可以看到iota从0开始，每多一个变量，数字加一。每个常量都有这个属性。可以用其做一些骚操作。</p>
<p>如果下面没有声明常量的值，那么就和上面常量保持一致，如果第一行没有声明，那么报错。</p>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>数据类型是一门高级语言的基础，Go属于又属于强类型静态编译语言。Go语言拥有两大数据类型，基本数据类型和复合数据类型。</p>
<p>整型</p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>说明</th>
<th>取值范围</th>
</tr>
</thead>
<tbody>
<tr>
<td>有符号整数</td>
<td></td>
<td></td>
</tr>
<tr>
<td>int8</td>
<td>有符号 8位整数</td>
<td>-128到 127</td>
</tr>
<tr>
<td>int16</td>
<td>有符号 16位整数</td>
<td>-32768 到32767</td>
</tr>
<tr>
<td>int32</td>
<td>有符号 32位整数</td>
<td>-2147483648到2147483647</td>
</tr>
<tr>
<td>int64</td>
<td>有符号 64位整数</td>
<td>-9223372036854775808到9223372036854775807</td>
</tr>
<tr>
<td>无符号整数</td>
<td></td>
<td></td>
</tr>
<tr>
<td>uint8</td>
<td>无符号8位整数</td>
<td>0到255</td>
</tr>
<tr>
<td>uint16</td>
<td>无符号16位整数</td>
<td>0到65535</td>
</tr>
<tr>
<td>uint32</td>
<td>无符号32位整数</td>
<td>0到4294967295</td>
</tr>
<tr>
<td>uint64</td>
<td>无符号64位整数</td>
<td>0到18446744073709551615</td>
</tr>
</tbody>
</table>
<p>在Go语言中 byte与uint8 是一样的，rune与int32是一样的，代表同一种数据类型。但是int和int64 不是同一种类型。</p>
<p>int不等于上面任意一个类型。</p>
<p>Go语言中int类型的大小与具体的平台有关系，一般来说，int在32位系统中是4字节，在64位系统中是8字节，使用简短定义自动推导类型初始化一个整数，默认为int类型。</p>
<p>字符串：</p>
<p>字符串的概念就是多个byte的集合，一个字符序列用双引号””，或者`` (esc下面的键) 表示。</p>
<p>浮点数</p>
<p>Go语言有两种精度的浮点数 float32 和 float64。浮点类型的数据取值范围可以从很小或者很巨大。</p>
<table>
<thead>
<tr>
<th>单精度 浮点类型</th>
<th></th>
<th>取值范围</th>
</tr>
</thead>
<tbody>
<tr>
<td>float32</td>
<td>负数时</td>
<td>-3.402823E38 到 -1.401298E-45</td>
</tr>
<tr>
<td>float32</td>
<td>正数时</td>
<td>1.401298E-45 到 3.402823E38</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>双精度 浮点类型</th>
<th>取值范围</th>
</tr>
</thead>
<tbody>
<tr>
<td>float64</td>
<td>-1.79E+308 到 +1.79E+308</td>
</tr>
</tbody>
</table>
<p><code>1.79E-308</code> 是 1.79 乘以 10的负308次方。 <code>1.79E+308</code> 是 1.79 乘以 10的308次方。</p>
<p>单精度双精度两者区别</p>
<p>在内存中占有的字节数不同</p>
<ul>
<li>单精度浮点数在机内占4个字节。</li>
<li>双精度浮点数在机内占8个字节。</li>
</ul>
<p>有效数字位数不同</p>
<ul>
<li>单精度浮点数 有效数字7位。</li>
<li>双精度浮点数 有效数字16位。</li>
</ul>
<p>对于float型数据，其长度是4个字节，右边23位用来表示小数点后面的数字，中间8位用来表示e，左边一位用来表示正负。</p>
<p>对于double型数据，其长度是8个字节，右边52位用来表示小数点后面的数字.中间11位表示e，左边一位用来表示正负。</p>
<h3 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h3><p>go 语言是静态语言，要求，定义、赋值、 运算、类型一致才能进行操作。所以要进行操作的时候必须保证数据类型一直。需要注意的是，只有兼容的数据类型才能够转换。 强制类型转换的语法 Type(value)</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a1 <span class="keyword">int</span>=<span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> a2 <span class="keyword">int32</span></span><br><span class="line">a2= <span class="keyword">int32</span>(<span class="number">10</span> + a1)</span><br><span class="line">a1= <span class="keyword">int</span>(<span class="number">10</span> + a2)</span><br><span class="line">fmt.Println(a1)</span><br><span class="line">fmt.Println(a2)</span><br></pre></td></tr></table></figure>
<h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><p>这个和java差不多，没啥区别。主要说几个没玩过的</p>
<ul>
<li>&amp;^ : a&amp;^b  对于b上面的每个数值，如果为0，则去a上的数值，如果为1，则是0（很有趣不知道有什么用）</li>
<li>^ :异或，不解释。</li>
<li>&lt;&lt;,&gt;&gt; 左移和右移，包含符号位的移动</li>
</ul>
<h4 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h4><p>这块go是蛮有意思的了。</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>=</td>
<td>把等号右侧的数值 赋给左边的变量</td>
</tr>
<tr>
<td>+=</td>
<td>自身加上后面的值 再赋给左边的变量</td>
</tr>
<tr>
<td>-=</td>
<td>自身减去后面的值 在赋给左边</td>
</tr>
<tr>
<td>/=</td>
<td>自身除后面的值 再赋值给左边</td>
</tr>
<tr>
<td>%=</td>
<td>自身与后面的值求余数后 再赋值给左边</td>
</tr>
<tr>
<td>&lt;&lt;=</td>
<td>左移后再赋值</td>
</tr>
<tr>
<td>&gt;&gt;=</td>
<td>右移后再赋值</td>
</tr>
<tr>
<td>&amp;=</td>
<td>按位与后再赋值</td>
</tr>
<tr>
<td>!=</td>
<td>按位或 后再赋值</td>
</tr>
<tr>
<td>^=</td>
<td>按位异或后再赋值</td>
</tr>
</tbody>
</table>
<p>这块赋值操作，让代码节省了很多，有趣。</p>
<h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><p>if模块</p>
<p>这个和java的语法没有区别。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> a3==a1&#123;</span><br><span class="line">		fmt.Println(<span class="string">"as"</span>)</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		fmt.Println(<span class="string">"asd"</span>)</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>但是go存在特殊的一些写法。条件判断之间再加上一段执行语句，执行的结果再用作后面的条件判断。例如</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> a4=a3; a3==a1&#123;</span><br><span class="line">		fmt.Println(<span class="string">"as"</span>)</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		fmt.Println(<span class="string">"asd"</span>)</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>试了一下，只能加一个语句哈。</p>
<p>switch模块</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">//switch语法一</span><br><span class="line">switch 变量名&#123;</span><br><span class="line">    case 数值1: 分支1</span><br><span class="line">    case 数值2: 分支2</span><br><span class="line">    case 数值3: 分支3</span><br><span class="line">    ...</span><br><span class="line">    default:</span><br><span class="line">        最后一个分支</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//语法二 省略变量 相当于作用在了bool 类型上</span><br><span class="line"></span><br><span class="line">switch&#123;</span><br><span class="line">    case true: 分支1</span><br><span class="line">    case false: 分支2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//语法三 case 后可以跟随多个数值， 满足其中一个就执行</span><br><span class="line">switch num&#123;</span><br><span class="line">    case 1,2,3:</span><br><span class="line">        fmt.Println(&quot;num符合其中某一个 执行代码&quot;)</span><br><span class="line">    case 4,5,6:</span><br><span class="line">        fmt.Println(&quot;执行此代码&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//语法四 可以添加初始化变量 作用于switch内部</span><br><span class="line"></span><br><span class="line">switch name:=&quot;huangrong&quot;; name&#123;</span><br><span class="line">    case &quot;guojing&quot;:</span><br><span class="line">        fmt.Println(&quot;shideguojing&quot;)</span><br><span class="line">    case &quot;huangrong&quot;:</span><br><span class="line">        fmt.Println(&quot;shidehuangrong&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看看例子</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sd=<span class="string">"asds"</span></span><br><span class="line"><span class="keyword">switch</span> sd &#123;</span><br><span class="line"><span class="keyword">case</span><span class="string">"1"</span>,<span class="string">"asds"</span>:</span><br><span class="line">   fmt.Println(<span class="string">"1sdf"</span>)</span><br><span class="line"><span class="keyword">case</span><span class="string">" 2"</span>:</span><br><span class="line">   fmt.Println(<span class="string">"12"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在switch 语句中，默认每个case后自带一个break，表示到此结束 不向下执行了，跳出整个switch。fallthrough 表示强制执行后面的没有执行的下一个case代码。</p>
<p>for</p>
<p>语法： <strong>for</strong> init; condition;post{ }</p>
<ul>
<li><p>init            初始化  只执行一次</p>
</li>
<li><p>condition   <strong>bool</strong>类型 执行条件 如果满足继续执行后面的循环体  如果不满足 则终止执行</p>
</li>
<li><p>{}               循环体 </p>
</li>
<li>post           表达式 将在循环体执行结束之后执行</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++&#123;</span><br><span class="line">		fmt.Println(i)</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>break默认是结束当前循环，如果当前多重循环，那么可以如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">flag:</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">for</span> j := <span class="number">1</span>; j &lt; i; j++ &#123;</span><br><span class="line">			fmt.Println(i, j)</span><br><span class="line">			<span class="keyword">if</span> j == <span class="number">5</span> &#123;</span><br><span class="line">				<span class="keyword">break</span> flag</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Println(i)</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>给循环体加个标签，然后break掉。</p>
<p>goto模块</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Test:</span><br><span class="line"><span class="keyword">var</span> as <span class="keyword">int</span> =<span class="number">1</span></span><br><span class="line">Test2:</span><br><span class="line">fmt.Println(as)</span><br><span class="line"><span class="keyword">goto</span> Test2</span><br><span class="line"><span class="keyword">goto</span> Test</span><br></pre></td></tr></table></figure>
<p>给语句加个标签，然后goto到那里直接执行。</p>
<h2 id="复合数据类型"><a href="#复合数据类型" class="headerlink" title="复合数据类型"></a>复合数据类型</h2><p>数组声明的语法格式为： <code>var 数组名称 [长度]数据类型</code></p>
<ul>
<li>数组只能用来存储一组相同类型的数据结构。</li>
<li>数组需要通过下标来访问，并且有长度和容量 。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sd [<span class="number">5</span>] <span class="keyword">int</span></span><br><span class="line">sd[<span class="number">1</span>]=<span class="number">11</span></span><br><span class="line">arr:=[<span class="number">5</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>&#125;</span><br><span class="line">arr1:=[<span class="number">5</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>:<span class="number">2</span>,<span class="number">3</span>:<span class="number">5</span>&#125;</span><br><span class="line">arr3:=[...]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>&#125;</span><br><span class="line">arr4:=[...]<span class="keyword">int</span>&#123;<span class="number">1</span>:<span class="number">2</span>,<span class="number">3</span>:<span class="number">5</span>&#125;</span><br></pre></td></tr></table></figure>
<p>数组不足补0处理。</p>
<p>数组的遍历，除了上面说的for，还可以</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> index,value:=<span class="keyword">range</span> arr1&#123;</span><br><span class="line">		fmt.Println(index,value)</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>slice</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> slice [] <span class="keyword">int</span></span><br><span class="line">slice =<span class="built_in">make</span>([]<span class="keyword">int</span>,<span class="number">3</span>，<span class="number">8</span>)</span><br><span class="line">slice[<span class="number">0</span>]=<span class="number">1</span></span><br><span class="line">slice=<span class="built_in">append</span>(slice,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<p>通过make函数定义slice，然后通过append扩容进去。前面的3是长度，后面的8是容量，扩容时基于容量计算的。容量就是真实的数组长度，而长度则是当前slice元素数目。</p>
<p>除了用make创建slice，还可以通过new创建。但是不一样，看看效果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">slice1 := new([]int)</span><br><span class="line">fmt.Println(slice1) //输出的是一个地址  &amp;[]</span><br><span class="line"></span><br><span class="line">//使用make创建切片</span><br><span class="line">slice2 := make([]int, 5)</span><br><span class="line">fmt.Println(slice2)//输出初始值都为0的数组， [0 0 0 0 0]</span><br><span class="line"></span><br><span class="line">fmt.Println(slice1[0])//结果出错 slice1是一个空指针 invalid operation: slice1[0] (type *[]int does not support indexing)</span><br><span class="line">fmt.Println(slice2[0])//结果为 0 因为已经初始化了</span><br></pre></td></tr></table></figure>
<p>如果实现了扩容， 地址就会发生改变成新的地址，旧的则自动销毁。</p>
<p>删除数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">slice:=[]int&#123;1,2,3,4,5,6&#125;</span><br><span class="line">	slice1:=[]int&#123;1,2,3,4,5,6&#125;</span><br><span class="line">	//i := 2      // 要删除的下标为2</span><br><span class="line">	//slice = append(slice[:i], slice[i+1:]...) // 删除中间1个元素</span><br><span class="line">	//fmt.Println(slice)  //结果[1 2 4]</span><br><span class="line">	slice=slice[:3]</span><br><span class="line">	slice1=slice1[3:]</span><br><span class="line">	fmt.Println(slice)  //结果[1 2 4]</span><br><span class="line">	fmt.Println(slice1)  //结果[1 2 4]</span><br></pre></td></tr></table></figure>
<p>:n，表示获取这个slice前面n个元素，n：,表示获取获取第三个元素后面的其余元素。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">i := <span class="number">2</span>      <span class="comment">// 要删除的下标为2</span></span><br><span class="line">slice = <span class="built_in">append</span>(slice[:i], slice[i+<span class="number">1</span>:]...) <span class="comment">// 删除中间1个元素</span></span><br><span class="line">fmt.Println(slice)  <span class="comment">//结果[1 2 4]</span></span><br></pre></td></tr></table></figure>
<p>相当于删除了第i个元素，其逻辑是，获取前面2个元素，然后再把第三个元素后面的元素添加进去。  </p>
<h3 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h3><ul>
<li>每一个切片都引用了一个底层数组。</li>
<li>切片本身不能存储任何数据，都是这底层数组存储数据，所以修改切片的时候修改的是底层数组中的数据。</li>
<li>当切片添加数据时候，如果没有超过容量，直接进行添加，如果超出容量自动扩容成倍增长。</li>
<li>切片一旦扩容，指向一个新的底层数组内存地址也就随之改变。</li>
<li>声明了长度的就是数组，没有声明就是slice,快速定义模式的，如果是make声明长度的则是slice</li>
<li>数组，slice都是声明的变量，实际数据存储在内存。</li>
</ul>
<p>map</p>
<p>和java里面的map一样,创建和删除语法如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> map1 <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span></span><br><span class="line"><span class="keyword">if</span> map1==<span class="literal">nil</span>&#123;</span><br><span class="line">	map1= <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> map2=<span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>)</span><br><span class="line">map2[<span class="number">13</span>]=<span class="string">"sad"</span></span><br><span class="line">val :=map2[<span class="number">13</span>]</span><br><span class="line">fmt.Print(val)</span><br><span class="line"><span class="built_in">delete</span>(map2,<span class="number">12</span>)</span><br><span class="line">map3:=<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>&#123;<span class="number">12</span>:<span class="string">"asd"</span>&#125;</span><br><span class="line">fmt.Print(map3[<span class="number">12</span>])</span><br></pre></td></tr></table></figure>
<p>遍历</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">map1:=<span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>)</span><br><span class="line">	map1[<span class="number">1</span>]=<span class="string">"asd"</span></span><br><span class="line">	map1[<span class="number">2</span>]=<span class="string">"asd2"</span></span><br><span class="line">	map1[<span class="number">3</span>]=<span class="string">"asd3"</span></span><br><span class="line">	<span class="keyword">for</span> key,value:=<span class="keyword">range</span> map1&#123;</span><br><span class="line">		fmt.Println(key,value)</span><br><span class="line">	&#125;</span><br><span class="line">	map1 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</span><br><span class="line">	map1[<span class="string">"name"</span>] = <span class="string">"1name"</span></span><br><span class="line">	map1[<span class="string">"age"</span>] = <span class="string">"1age"</span></span><br><span class="line">	map2 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</span><br><span class="line">	map2[<span class="string">"name"</span>] = <span class="string">"2name"</span></span><br><span class="line">	map2[<span class="string">"age"</span>] = <span class="string">"2age"</span></span><br><span class="line">	s1:=<span class="built_in">make</span>([]<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>,<span class="number">0</span>,<span class="number">2</span>)</span><br><span class="line">	s1=<span class="built_in">append</span>(s1,map1,map2)</span><br><span class="line">	<span class="keyword">for</span> key,value:=<span class="keyword">range</span> s1&#123;</span><br><span class="line">		fmt.Println(key,value)</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>map在Go语言并发编程中,如果仅用于读取数据时候是安全的，但是在读写操作的时候是不安全的，在Go语言1.9版本后提供了一种并发安全的，sync.Map是Go语言提供的内置map，不同于基本的map,他提供了特有的方法，不需要初始化操作实现增删改查的操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var syncmap sync.Map</span><br><span class="line">syncmap.Store(&quot;as&quot;,12)</span><br><span class="line">fmt.Println(syncmap.Load(&quot;as&quot;))</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://skydh.github.io/2020/06/29/es/ElasticSearch 增删改查原理解析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="skydh">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="learning, progress, future.">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/06/29/es/ElasticSearch 增删改查原理解析/" itemprop="url">ElasticSearch 增删改查原理解析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-06-29T08:56:13+08:00">
                2020-06-29
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>参考文档：<a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/distributed-search.html" target="_blank" rel="noopener">https://www.elastic.co/guide/cn/elasticsearch/guide/current/distributed-search.html</a></p>
<h3 id="es写数据原理"><a href="#es写数据原理" class="headerlink" title="es写数据原理"></a>es写数据原理</h3><ul>
<li>客户端选择一个 node 发送请求过去，这个 node 就是 <code>coordinating node</code> （协调节点）。</li>
<li><code>coordinating node</code> 对 document 进行<strong>路由</strong>，将请求转发给对应的 node（有 primary shard）。</li>
<li>实际的 node 上的 <code>primary shard</code> 处理请求，然后将数据同步到 <code>replica node</code> 。</li>
<li><code>coordinating node</code> 如果发现 <code>primary node</code> 和所有 <code>replica node</code> 都搞定之后，就返回响应结果给客户端。</li>
</ul>
<h3 id="es-读数据过程"><a href="#es-读数据过程" class="headerlink" title="es 读数据过程"></a>es 读数据过程</h3><p>可以通过 <code>doc id</code> 来查询，会根据 <code>doc id</code> 进行 hash，判断出来当时把 <code>doc id</code> 分配到了哪个 shard 上面去，从那个 shard 去查询。</p>
<ul>
<li>客户端发送请求到<strong>任意</strong>一个 node，成为 <code>coordinate node</code> 。</li>
<li><code>coordinate node</code> 对 <code>doc id</code> 进行哈希路由，将请求转发到对应的 node，此时会使用 <code>round-robin</code> <strong>随机轮询算法</strong>，在 <code>primary shard</code> 以及其所有 replica 中随机选择一个，让读请求负载均衡。</li>
<li>接收请求的 node 返回 document 给 <code>coordinate node</code> 。</li>
<li><code>coordinate node</code> 返回 document 给客户端。</li>
</ul>
<h3 id="es-搜索数据过程"><a href="#es-搜索数据过程" class="headerlink" title="es 搜索数据过程"></a>es 搜索数据过程</h3><p>你根据 <code>java</code> 关键词来搜索，将包含 <code>java</code> 的 <code>document</code> 给搜索出来。</p>
<ul>
<li>客户端发送请求到一个 <code>coordinate node</code> 。</li>
<li>协调节点将搜索请求转发到<strong>所有</strong>的 shard 对应的 <code>primary shard</code> 或 <code>replica shard</code> ，都可以。</li>
<li>query phase：每个 shard 将自己的搜索结果（其实就是一些 <code>doc id</code> ）返回给协调节点，由协调节点进行数据的合并、排序、分页等操作，产出最终结果。</li>
<li>fetch phase：接着由协调节点根据 <code>doc id</code> 去各个节点上<strong>拉取实际</strong>的 <code>document</code> 数据，最终返回给客户端。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://skydh.github.io/2020/06/29/es/ElasticSearch 聚合查询原理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="skydh">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="learning, progress, future.">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/06/29/es/ElasticSearch 聚合查询原理/" itemprop="url">ElasticSearch 聚合查询原理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-06-29T08:56:13+08:00">
                2020-06-29
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h5 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h5><p>参考：<a href="https://www.cnblogs.com/huangying2124/p/12717369.html" target="_blank" rel="noopener">https://www.cnblogs.com/huangying2124/p/12717369.html</a></p>
<p><a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/_limiting_memory_usage.html" target="_blank" rel="noopener">https://www.elastic.co/guide/cn/elasticsearch/guide/current/_limiting_memory_usage.html</a></p>
<p>聚合使用一个叫 <em>doc values</em> 的数据结构（在 <a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/docvalues-intro.html" target="_blank" rel="noopener">Doc Values 介绍</a> 里简单介绍）。 Doc values 可以使聚合更快、更高效并且内存友好，所以理解它的工作方式十分有益。</p>
<p>Doc values 的存在是因为倒排索引只对某些操作是高效的。 倒排索引的优势 在于查找包含某个项的文档，而对于从另外一个方向的相反操作并不高效，即：确定哪些项是否存在单个文档里，聚合需要这种次级的访问模式。</p>
<p>在 <code>Elasticsearch</code> 中，<code>Doc Values</code> 就是一种列式存储结构。</p>
<p><code>Doc Values</code> 是在索引时与 <code>倒排索引</code> 同时生成。也就是说 <code>Doc Values</code> 和 <code>倒排索引</code> 一样，基于 <code>Segement</code> 生成并且是不可变的。同时 <code>Doc Values</code> 和 <code>倒排索引</code> 一样序列化到磁盘，这样对性能和扩展性有很大帮助。</p>
<p>因此我们可以通过禁用某些字段的doc_values来节约磁盘空间。</p>
<p>我们对字符串做聚合时，如何时默认的，那么久会出现很坑的点。demo如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">POST /agg_analysis/data/_bulk</span><br><span class="line">&#123; &quot;index&quot;: &#123;&#125;&#125;</span><br><span class="line">&#123; &quot;state&quot; : &quot;New York&quot; &#125;</span><br><span class="line">&#123; &quot;index&quot;: &#123;&#125;&#125;</span><br><span class="line">&#123; &quot;state&quot; : &quot;New Jersey&quot; &#125;</span><br><span class="line"></span><br><span class="line">GET /agg_analysis/data/_search</span><br><span class="line">&#123;</span><br><span class="line">    &quot;size&quot; : 0,</span><br><span class="line">    &quot;aggs&quot; : &#123;</span><br><span class="line">        &quot;states&quot; : &#123;</span><br><span class="line">            &quot;terms&quot; : &#123;</span><br><span class="line">                &quot;field&quot; : &quot;state&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">   &quot;aggregations&quot;: &#123;</span><br><span class="line">      &quot;states&quot;: &#123;</span><br><span class="line">         &quot;buckets&quot;: [</span><br><span class="line">            &#123;</span><br><span class="line">               &quot;key&quot;: &quot;new&quot;,</span><br><span class="line">               &quot;doc_count&quot;: 2</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">               &quot;key&quot;: &quot;york&quot;,</span><br><span class="line">               &quot;doc_count&quot;: 1</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">               &quot;key&quot;: &quot;jersey&quot;,</span><br><span class="line">               &quot;doc_count&quot;: 1</span><br><span class="line">            &#125;,</span><br><span class="line">           </span><br><span class="line">         ]</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们对state聚合，结果出现了很多奇怪的桶，这个就是对string这个字段每个词都做了桶，为了禁止这个可以直接加keyword,来处理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">GET /data1/data1/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;size&quot; : 0,</span><br><span class="line">  &quot;aggs&quot; : &#123;</span><br><span class="line">    &quot;states&quot; : &#123;</span><br><span class="line">        &quot;terms&quot; : &#123;</span><br><span class="line">            &quot;field&quot; : &quot;state.keyword&quot; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&quot;aggregations&quot; : &#123;</span><br><span class="line">    &quot;states&quot; : &#123;</span><br><span class="line">      &quot;doc_count_error_upper_bound&quot; : 0,</span><br><span class="line">      &quot;sum_other_doc_count&quot; : 0,</span><br><span class="line">      &quot;buckets&quot; : [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;key&quot; : &quot;New York&quot;,</span><br><span class="line">          &quot;doc_count&quot; : 3</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;key&quot; : &quot;New Jersey&quot;,</span><br><span class="line">          &quot;doc_count&quot; : 1</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;key&quot; : &quot;New Mexico&quot;,</span><br><span class="line">          &quot;doc_count&quot; : 1</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>对于常规字段和text字段的keyword,都是直接走doc values的，这个列索引。效率很高，如果需要对这个字段进行桶聚合，那么就要开启fielddata 。</p>
<p>analyzed字符串的字段，字段分词后占用空间很大，正排索引不能很有效的表示多值字符串，所以正排索引不支持此类字段。</p>
<p>fielddata结构与正排索引类似，是另外一份数据，构建和管理100%在内存中，并常驻于JVM内存堆，极易引起OOM问题。</p>
<p>Fielddata 是 <em>延迟</em> 加载。如果你从来没有聚合一个分析字符串，就不会加载 fielddata 到内存中。此外，fielddata 是基于字段加载的， 这意味着只有很活跃地使用字段才会增加 fielddata 的负担。</p>
<p>实际情况是，fielddata 会加载索引中（针对该特定字段的） <strong>所有的</strong> 文档，而不管查询的特异性。逻辑是这样：如果查询会访问文档 X、Y 和 Z，那很有可能会在下一个查询中访问其他文档。因此会把所有的文档全部加载进来。</p>
<p>与 doc values 不同，fielddata 结构不会在索引时创建。相反，它是在查询运行时，动态填充。这可能是一个比较复杂的操作，可能需要一些时间。 将所有的信息一次加载，再将其维持在内存中的方式要比反复只加载一个 fielddata 的部分代价要低。</p>
<p>因此很少使用。</p>
<p>由于fielddata 使用的是jvm堆内存，因此这里扩展下elasticSearch内存分配以及jvm内存。</p>
<p>这里参考另外一篇文档<a href="http://wiki.61info.cn/pages/viewpage.action?pageId=17150953" target="_blank" rel="noopener">ElasticSearch 内存配置及其原因</a>里面详细描述了elasticSearch的分配策略以及原理。</p>
<p><code>indices.fielddata.cache.size</code> 控制为 fielddata 分配的堆空间大小。 当你发起一个查询，如果这些字符串之前没有被加载过，分析字符串的聚合将会被加载到 fielddata，加载过，直接取用，前面说过了，这个是全局加载。</p>
<p>默认情况下，设置都是 <em>unbounded</em> ，Elasticsearch 永远都不会从 fielddata 中回收数据。</p>
<p>设想我们正在对日志进行索引，每天使用一个新的索引。通常我们只对过去一两天的数据感兴趣，尽管我们会保留老的索引，但我们很少需要查询它们。不过如果采用默认设置，旧索引的 fielddata 永远不会从缓存中回收！ fieldata 会保持增长直到 fielddata 发生断熔（请参阅 <a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/_limiting_memory_usage.html#circuit-breaker" target="_blank" rel="noopener">断路器</a>），这样我们就无法载入更多的 fielddata。</p>
<p>为了防止发生这样的事情，可以通过在 <code>config/elasticsearch.yml</code> 文件中增加配置为 fielddata 设置一个上限：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">indices.fielddata.cache.size:</span>  <span class="number">20</span><span class="string">%</span></span><br></pre></td></tr></table></figure>
<p>有了这个设置，最久未使用（LRU）的 fielddata 会被回收为新数据腾出空间。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://skydh.github.io/2020/06/29/es/ElasticSearch 分页查询调研/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="skydh">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="learning, progress, future.">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/06/29/es/ElasticSearch 分页查询调研/" itemprop="url">ElasticSearch 聚合查询语法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-06-29T08:56:13+08:00">
                2020-06-29
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>参考资料：<a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/aggregations.html" target="_blank" rel="noopener">https://www.elastic.co/guide/cn/elasticsearch/guide/current/aggregations.html</a></p>
<h4 id="创建数据"><a href="#创建数据" class="headerlink" title="创建数据"></a>创建数据</h4><pre><code>我们先通过模拟的数据来看看有哪些语法。

由于es集群禁止了自动创建索引，我们只能先创建索引。
</code></pre><ul>
<li>创建索引</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">PUT /test?pretty</span><br><span class="line">&#123;</span><br><span class="line">	&quot;settings&quot;: &#123;</span><br><span class="line">		&quot;number_of_shards&quot;: 3,</span><br><span class="line">		&quot;number_of_replicas&quot;: 2</span><br><span class="line">	&#125;,</span><br><span class="line">&quot;mapping&quot;: &#123;</span><br><span class="line">	&quot;test&quot;: &#123;</span><br><span class="line">		&quot;properties&quot;: &#123;</span><br><span class="line">			&quot;price&quot;: &#123;</span><br><span class="line">				&quot;type&quot;: &quot;text&quot;</span><br><span class="line">			&#125;,</span><br><span class="line">			&quot;color&quot;: &#123;</span><br><span class="line">				&quot;type&quot;: &quot;text&quot;</span><br><span class="line">			&#125;,</span><br><span class="line">			&quot;make&quot;: &#123;</span><br><span class="line">				&quot;type&quot;: &quot;text&quot;</span><br><span class="line">			&#125;,</span><br><span class="line">			&quot;sold&quot;: &#123;</span><br><span class="line">				&quot;type&quot;: &quot;text&quot;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>新增数据</p>
<p>批量插入部分数据。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">post /test/test/_bulk</span><br><span class="line">&#123; &quot;index&quot;: &#123;&#125;&#125;</span><br><span class="line">&#123; &quot;price&quot; : 10000, &quot;color&quot; : &quot;red&quot;, &quot;make&quot; : &quot;honda&quot;, &quot;sold&quot; : &quot;2014-10-28&quot; &#125;</span><br><span class="line">&#123; &quot;index&quot;: &#123;&#125;&#125;</span><br><span class="line">&#123; &quot;price&quot; : 20000, &quot;color&quot; : &quot;red&quot;, &quot;make&quot; : &quot;honda&quot;, &quot;sold&quot; : &quot;2014-11-05&quot; &#125;</span><br><span class="line">&#123; &quot;index&quot;: &#123;&#125;&#125;</span><br><span class="line">&#123; &quot;price&quot; : 30000, &quot;color&quot; : &quot;green&quot;, &quot;make&quot; : &quot;ford&quot;, &quot;sold&quot; : &quot;2014-05-18&quot; &#125;</span><br><span class="line">&#123; &quot;index&quot;: &#123;&#125;&#125;</span><br><span class="line">&#123; &quot;price&quot; : 15000, &quot;color&quot; : &quot;blue&quot;, &quot;make&quot; : &quot;toyota&quot;, &quot;sold&quot; : &quot;2014-07-02&quot; &#125;</span><br><span class="line">&#123; &quot;index&quot;: &#123;&#125;&#125;</span><br><span class="line">&#123; &quot;price&quot; : 12000, &quot;color&quot; : &quot;green&quot;, &quot;make&quot; : &quot;toyota&quot;, &quot;sold&quot; : &quot;2014-08-19&quot; &#125;</span><br><span class="line">&#123; &quot;index&quot;: &#123;&#125;&#125;</span><br><span class="line">&#123; &quot;price&quot; : 20000, &quot;color&quot; : &quot;red&quot;, &quot;make&quot; : &quot;honda&quot;, &quot;sold&quot; : &quot;2014-11-05&quot; &#125;</span><br><span class="line">&#123; &quot;index&quot;: &#123;&#125;&#125;</span><br><span class="line">&#123; &quot;price&quot; : 80000, &quot;color&quot; : &quot;red&quot;, &quot;make&quot; : &quot;bmw&quot;, &quot;sold&quot; : &quot;2014-01-01&quot; &#125;</span><br><span class="line">&#123; &quot;index&quot;: &#123;&#125;&#125;</span><br><span class="line">&#123; &quot;price&quot; : 25000, &quot;color&quot; : &quot;blue&quot;, &quot;make&quot; : &quot;ford&quot;, &quot;sold&quot; : &quot;2014-02-12&quot; &#125;</span><br></pre></td></tr></table></figure>
<h4 id="了解聚合概念"><a href="#了解聚合概念" class="headerlink" title="了解聚合概念"></a>了解聚合概念</h4><ul>
<li><p>桶（Buckets）</p>
<p>满足特定条件的文档的集合</p>
</li>
<li><p>指标（Metrics）</p>
<p>对桶内的文档进行统计计算。</p>
<pre><code>  聚合是由桶和指标组成的。 聚合可能只有一个桶，可能只有一个指标，或者可能两个都有。也有可能有一些桶嵌套在其他桶里面。例如，我们可以通过所属国家来划分文档（桶），然后计算每个国家的平均薪酬（指标）。

另外聚合计算是实时的。一旦文档可以被搜到，它就能被聚合。这也就意味着我们可以直接将聚合的结果源源不断的传入前端，让其动态显示变化。

 5.x后对排序，聚合这些操作用单独的数据结构(fielddata)缓存到内存里了，需要单独开启。对哪个字段聚合就要开启哪个字段。比如我就开启了color字段，方便后续的聚合。
</code></pre></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">PUT test/_mapping/test/</span><br><span class="line">&#123;</span><br><span class="line">  &quot;properties&quot;: &#123;</span><br><span class="line">    &quot;color&quot;: &#123; </span><br><span class="line">      &quot;type&quot;:     &quot;text&quot;,</span><br><span class="line">      &quot;fielddata&quot;: true</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据颜色分组，参考mysql的groupby</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">GET /cars/transactions/_search</span><br><span class="line">&#123;</span><br><span class="line">    &quot;size&quot; : 0,</span><br><span class="line">    &quot;aggs&quot; : &#123; </span><br><span class="line">        &quot;popular_colors&quot; : &#123; </span><br><span class="line">            &quot;terms&quot; : &#123; </span><br><span class="line">              &quot;field&quot; : &quot;color&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>核心结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&quot;aggregations&quot; : &#123;</span><br><span class="line">    &quot;popular_colors&quot; : &#123;</span><br><span class="line">      &quot;doc_count_error_upper_bound&quot; : 0,</span><br><span class="line">      &quot;sum_other_doc_count&quot; : 0,</span><br><span class="line">      &quot;buckets&quot; : [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;key&quot; : &quot;red&quot;,</span><br><span class="line">          &quot;doc_count&quot; : 4</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;key&quot; : &quot;blue&quot;,</span><br><span class="line">          &quot;doc_count&quot; : 2</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;key&quot; : &quot;green&quot;,</span><br><span class="line">          &quot;doc_count&quot; : 2</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>对桶内的数据计算一下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">GET /test/test/_search</span><br><span class="line">&#123;</span><br><span class="line">   &quot;size&quot; : 0,</span><br><span class="line">   &quot;aggs&quot;: &#123;</span><br><span class="line">      &quot;colors&quot;: &#123;</span><br><span class="line">         &quot;terms&quot;: &#123;</span><br><span class="line">            &quot;field&quot;: &quot;color&quot;</span><br><span class="line">         &#125;,</span><br><span class="line">         &quot;aggs&quot;: &#123; </span><br><span class="line">            &quot;avg_price&quot;: &#123; </span><br><span class="line">               &quot;avg&quot;: &#123;</span><br><span class="line">                  &quot;field&quot;: &quot;price&quot; </span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&quot;aggregations&quot; : &#123;</span><br><span class="line">   &quot;colors&quot; : &#123;</span><br><span class="line">     &quot;doc_count_error_upper_bound&quot; : 0,</span><br><span class="line">     &quot;sum_other_doc_count&quot; : 0,</span><br><span class="line">     &quot;buckets&quot; : [</span><br><span class="line">       &#123;</span><br><span class="line">         &quot;key&quot; : &quot;red&quot;,</span><br><span class="line">         &quot;doc_count&quot; : 4,</span><br><span class="line">         &quot;avg_price&quot; : &#123;</span><br><span class="line">           &quot;value&quot; : 32500.0</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;,</span><br><span class="line">       &#123;</span><br><span class="line">         &quot;key&quot; : &quot;blue&quot;,</span><br><span class="line">         &quot;doc_count&quot; : 2,</span><br><span class="line">         &quot;avg_price&quot; : &#123;</span><br><span class="line">           &quot;value&quot; : 20000.0</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;,</span><br><span class="line">       &#123;</span><br><span class="line">         &quot;key&quot; : &quot;green&quot;,</span><br><span class="line">         &quot;doc_count&quot; : 2,</span><br><span class="line">         &quot;avg_price&quot; : &#123;</span><br><span class="line">           &quot;value&quot; : 21000.0</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;</span><br><span class="line">     ]</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>希望求出每个颜色里面制造厂商的分布情况，那就里面在嵌套一个桶。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">GET /test/test/_search</span><br><span class="line">&#123;</span><br><span class="line">   &quot;size&quot; : 0,</span><br><span class="line">   &quot;aggs&quot;: &#123;</span><br><span class="line">      &quot;colors&quot;: &#123;</span><br><span class="line">         &quot;terms&quot;: &#123;</span><br><span class="line">            &quot;field&quot;: &quot;color&quot;</span><br><span class="line">         &#125;,</span><br><span class="line">         &quot;aggs&quot;: &#123;</span><br><span class="line">            &quot;avg_price&quot;: &#123; </span><br><span class="line">               &quot;avg&quot;: &#123;</span><br><span class="line">                  &quot;field&quot;: &quot;price&quot;</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;make&quot;: &#123; </span><br><span class="line">                &quot;terms&quot;: &#123;</span><br><span class="line">                    &quot;field&quot;: &quot;make&quot; </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&quot;aggregations&quot; : &#123;</span><br><span class="line">   &quot;colors&quot; : &#123;</span><br><span class="line">     &quot;doc_count_error_upper_bound&quot; : 0,</span><br><span class="line">     &quot;sum_other_doc_count&quot; : 0,</span><br><span class="line">     &quot;buckets&quot; : [</span><br><span class="line">       &#123;</span><br><span class="line">         &quot;key&quot; : &quot;red&quot;,</span><br><span class="line">         &quot;doc_count&quot; : 4,</span><br><span class="line">         &quot;avg_price&quot; : &#123;</span><br><span class="line">           &quot;value&quot; : 32500.0</span><br><span class="line">         &#125;,</span><br><span class="line">         &quot;make&quot; : &#123;</span><br><span class="line">           &quot;doc_count_error_upper_bound&quot; : 0,</span><br><span class="line">           &quot;sum_other_doc_count&quot; : 0,</span><br><span class="line">           &quot;buckets&quot; : [</span><br><span class="line">             &#123;</span><br><span class="line">               &quot;key&quot; : &quot;honda&quot;,</span><br><span class="line">               &quot;doc_count&quot; : 3</span><br><span class="line">             &#125;,</span><br><span class="line">             &#123;</span><br><span class="line">               &quot;key&quot; : &quot;bmw&quot;,</span><br><span class="line">               &quot;doc_count&quot; : 1</span><br><span class="line">             &#125;</span><br><span class="line">           ]</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;,</span><br><span class="line">       ......</span><br></pre></td></tr></table></figure>
<p>条形图</p>
<p>这个关键字histogram，这个关键字要求字段必须是数值类型，然后interval定义了区间，然后可以在加几个指标，来获取这个区间的信息，比如最大值，最小值，和，平均值巴拉巴拉的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">GET /test/test/_search</span><br><span class="line">&#123;</span><br><span class="line">   &quot;size&quot; : 0,</span><br><span class="line">   &quot;aggs&quot;:&#123;</span><br><span class="line">      &quot;pricesss&quot;:&#123;</span><br><span class="line">         &quot;histogram&quot;:&#123; </span><br><span class="line">            &quot;field&quot;: &quot;price&quot;,</span><br><span class="line">            &quot;interval&quot;: 20000</span><br><span class="line">         &#125;,</span><br><span class="line">         &quot;aggs&quot;:&#123;</span><br><span class="line">            &quot;revenue&quot;: &#123;</span><br><span class="line">               &quot;max&quot;: &#123; </span><br><span class="line">                 &quot;field&quot; : &quot;price&quot;</span><br><span class="line">               &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&quot;aggregations&quot; : &#123;</span><br><span class="line">    &quot;pricesss&quot; : &#123;</span><br><span class="line">      &quot;buckets&quot; : [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;key&quot; : 0.0,</span><br><span class="line">          &quot;doc_count&quot; : 3,</span><br><span class="line">          &quot;revenue&quot; : &#123;</span><br><span class="line">            &quot;value&quot; : 15000.0</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;key&quot; : 20000.0,</span><br><span class="line">          &quot;doc_count&quot; : 4,</span><br><span class="line">          &quot;revenue&quot; : &#123;</span><br><span class="line">            &quot;value&quot; : 30000.0</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;key&quot; : 40000.0,</span><br><span class="line">          &quot;doc_count&quot; : 0,</span><br><span class="line">          &quot;revenue&quot; : &#123;</span><br><span class="line">            &quot;value&quot; : null</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;key&quot; : 60000.0,</span><br><span class="line">          &quot;doc_count&quot; : 0,</span><br><span class="line">          &quot;revenue&quot; : &#123;</span><br><span class="line">            &quot;value&quot; : null</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;key&quot; : 80000.0,</span><br><span class="line">          &quot;doc_count&quot; : 1,</span><br><span class="line">          &quot;revenue&quot; : &#123;</span><br><span class="line">            &quot;value&quot; : 80000.0</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>根据时间来聚合数据，首先命名为sales，然后使用关键字date_histogram，选择字段，和时间粒度即可。中间没有的月份也会显示，只是数目为0。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">GET /test/test/_search</span><br><span class="line">&#123;</span><br><span class="line">   &quot;size&quot; : 0,</span><br><span class="line">   &quot;aggs&quot;: &#123;</span><br><span class="line">      &quot;sales&quot;: &#123;</span><br><span class="line">         &quot;date_histogram&quot;: &#123;</span><br><span class="line">            &quot;field&quot;: &quot;sold&quot;,</span><br><span class="line">            &quot;interval&quot;: &quot;year&quot;, </span><br><span class="line">            &quot;format&quot;: &quot;yyyy-MM-dd&quot; </span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&quot;aggregations&quot; : &#123;</span><br><span class="line">   &quot;sales&quot; : &#123;</span><br><span class="line">     &quot;buckets&quot; : [</span><br><span class="line">       &#123;</span><br><span class="line">         &quot;key_as_string&quot; : &quot;2014-01-01&quot;,</span><br><span class="line">         &quot;key&quot; : 1388534400000,</span><br><span class="line">         &quot;doc_count&quot; : 1</span><br><span class="line">       &#125;,</span><br><span class="line">       &#123;</span><br><span class="line">         &quot;key_as_string&quot; : &quot;2014-02-01&quot;,</span><br><span class="line">         &quot;key&quot; : 1391212800000,</span><br><span class="line">         &quot;doc_count&quot; : 1</span><br><span class="line">       &#125;,</span><br><span class="line">       &#123;</span><br><span class="line">         &quot;key_as_string&quot; : &quot;2014-03-01&quot;,</span><br><span class="line">         &quot;key&quot; : 1393632000000,</span><br><span class="line">         &quot;doc_count&quot; : 0</span><br><span class="line">       &#125;,</span><br><span class="line">       &#123;</span><br><span class="line">         &quot;key_as_string&quot; : &quot;2014-04-01&quot;,</span><br><span class="line">         &quot;key&quot; : 1396310400000,</span><br><span class="line">         &quot;doc_count&quot; : 0</span><br><span class="line">       &#125;,</span><br><span class="line">       ......</span><br></pre></td></tr></table></figure>
<p>另外由于elasticSearch版本差异太大，2.x版本<code>date_histogram</code>  ，<code>histogram</code> 时间聚合和数值聚合返回的buckets是没有空值的，也就是某个月份数据为0或者某个区间值为0，那么返回值里面是没有的（当然可以设置参数让其有），但是目前线上版本是6.x的，默认已经有空值了</p>
<p>下面来一个复杂的聚合，我来解释下其逻辑。</p>
<ul>
<li>首先根据每个季度创建一个桶，然后在每个桶里面在进行聚合计算。</li>
<li>在季度每个桶里面第一个指标算出，这个季度一共卖了多少钱。</li>
<li>在季度这个桶里面再根据制造厂商创建桶，同时计算出每个厂商卖了多少钱。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">GET /test/test/_search</span><br><span class="line">&#123;</span><br><span class="line">   &quot;size&quot; : 0,</span><br><span class="line">   &quot;aggs&quot;: &#123;</span><br><span class="line">      &quot;sales&quot;: &#123;</span><br><span class="line">         &quot;date_histogram&quot;: &#123;</span><br><span class="line">            &quot;field&quot;: &quot;sold&quot;,</span><br><span class="line">            &quot;interval&quot;: &quot;quarter&quot;, </span><br><span class="line">            &quot;format&quot;: &quot;yyyy-MM-dd&quot;</span><br><span class="line">         &#125;,</span><br><span class="line">         &quot;aggs&quot;: &#123;</span><br><span class="line">            &quot;per_make_sum&quot;: &#123;</span><br><span class="line">               &quot;terms&quot;: &#123;</span><br><span class="line">                  &quot;field&quot;: &quot;make&quot;</span><br><span class="line">               &#125;,</span><br><span class="line">               &quot;aggs&quot;: &#123;</span><br><span class="line">                  &quot;sum_price&quot;: &#123;</span><br><span class="line">                     &quot;sum&quot;: &#123; &quot;field&quot;: &quot;price&quot; &#125; </span><br><span class="line">                  &#125;</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;total_sum&quot;: &#123;</span><br><span class="line">               &quot;sum&quot;: &#123; &quot;field&quot;: &quot;price&quot; &#125; </span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是一个稍微复杂点的聚合逻辑，理解了他基本也就理解了全部的概念</p>
<p>结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">&quot;aggregations&quot; : &#123;</span><br><span class="line">    &quot;sales&quot; : &#123;</span><br><span class="line">      &quot;buckets&quot; : [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;key_as_string&quot; : &quot;2014-01-01&quot;,</span><br><span class="line">          &quot;key&quot; : 1388534400000,</span><br><span class="line">          &quot;doc_count&quot; : 2,</span><br><span class="line">          &quot;per_make_sum&quot; : &#123;</span><br><span class="line">            &quot;doc_count_error_upper_bound&quot; : 0,</span><br><span class="line">            &quot;sum_other_doc_count&quot; : 0,</span><br><span class="line">            &quot;buckets&quot; : [</span><br><span class="line">              &#123;</span><br><span class="line">                &quot;key&quot; : &quot;bmw&quot;,</span><br><span class="line">                &quot;doc_count&quot; : 1,</span><br><span class="line">                &quot;sum_price&quot; : &#123;</span><br><span class="line">                  &quot;value&quot; : 80000.0</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;,</span><br><span class="line">              &#123;</span><br><span class="line">                &quot;key&quot; : &quot;ford&quot;,</span><br><span class="line">                &quot;doc_count&quot; : 1,</span><br><span class="line">                &quot;sum_price&quot; : &#123;</span><br><span class="line">                  &quot;value&quot; : 25000.0</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">            ]</span><br><span class="line">          &#125;,</span><br><span class="line">          &quot;total_sum&quot; : &#123;</span><br><span class="line">            &quot;value&quot; : 105000.0</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;key_as_string&quot; : &quot;2014-04-01&quot;,</span><br><span class="line">          &quot;key&quot; : 1396310400000,</span><br><span class="line">          &quot;doc_count&quot; : 1,</span><br><span class="line">          &quot;per_make_sum&quot; : &#123;</span><br><span class="line">            &quot;doc_count_error_upper_bound&quot; : 0,</span><br><span class="line">            &quot;sum_other_doc_count&quot; : 0,</span><br><span class="line">            &quot;buckets&quot; : [</span><br><span class="line">              &#123;</span><br><span class="line">                &quot;key&quot; : &quot;ford&quot;,</span><br><span class="line">                &quot;doc_count&quot; : 1,</span><br><span class="line">                &quot;sum_price&quot; : &#123;</span><br><span class="line">                  &quot;value&quot; : 30000.0</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">            ]</span><br><span class="line">          &#125;,</span><br><span class="line">          &quot;total_sum&quot; : &#123;</span><br><span class="line">            &quot;value&quot; : 30000.0</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;key_as_string&quot; : &quot;2014-07-01&quot;,</span><br><span class="line">          &quot;key&quot; : 1404172800000,</span><br><span class="line">          &quot;doc_count&quot; : 2,</span><br><span class="line">          &quot;per_make_sum&quot; : &#123;</span><br><span class="line">            &quot;doc_count_error_upper_bound&quot; : 0,</span><br><span class="line">            &quot;sum_other_doc_count&quot; : 0,</span><br><span class="line">            &quot;buckets&quot; : [</span><br><span class="line">              &#123;</span><br><span class="line">                &quot;key&quot; : &quot;toyota&quot;,</span><br><span class="line">                &quot;doc_count&quot; : 2,</span><br><span class="line">                &quot;sum_price&quot; : &#123;</span><br><span class="line">                  &quot;value&quot; : 27000.0</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">            ]</span><br><span class="line">          &#125;,</span><br><span class="line">          &quot;total_sum&quot; : &#123;</span><br><span class="line">            &quot;value&quot; : 27000.0</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        ......</span><br></pre></td></tr></table></figure>
<p>我们可以将查询和聚合一起来使用，前面的聚合查询基本都相当于加了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&quot;query&quot; : &#123;</span><br><span class="line">       &quot;match&quot; : &#123;</span><br><span class="line">           &quot;make&quot; : &quot;ford&quot;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>下面是个简单例子，是聚合和查询集合的例子。查出ford厂商的卖的车的颜色聚合。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">GET /test/test/_search</span><br><span class="line">&#123;</span><br><span class="line">    &quot;query&quot; : &#123;</span><br><span class="line">        &quot;match&quot; : &#123;</span><br><span class="line">            &quot;make&quot; : &quot;ford&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;aggs&quot; : &#123;</span><br><span class="line">        &quot;colors&quot; : &#123;</span><br><span class="line">            &quot;terms&quot; : &#123;</span><br><span class="line">              &quot;field&quot; : &quot;color&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们不仅可以在查询条件内做聚合，还可以全局聚合，同时使用，用法是关键字all</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">GET /test/test/_search</span><br><span class="line">&#123;</span><br><span class="line">    &quot;size&quot; : 0,</span><br><span class="line">    &quot;query&quot; : &#123;</span><br><span class="line">        &quot;match&quot; : &#123;</span><br><span class="line">            &quot;make&quot; : &quot;ford&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;aggs&quot; : &#123;</span><br><span class="line">        &quot;single_avg_price&quot;: &#123;</span><br><span class="line">            &quot;avg&quot; : &#123; &quot;field&quot; : &quot;price&quot; &#125; </span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;all&quot;: &#123;</span><br><span class="line">            &quot;global&quot; : &#123;&#125;, </span><br><span class="line">            &quot;aggs&quot; : &#123;</span><br><span class="line">                &quot;avg_price&quot;: &#123;</span><br><span class="line">                    &quot;avg&quot; : &#123; &quot;field&quot; : &quot;price&quot; &#125; </span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：算出了查询值得平均值，还算出了全部文档的平均值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&quot;aggregations&quot; : &#123;</span><br><span class="line">   &quot;all&quot; : &#123;</span><br><span class="line">     &quot;doc_count&quot; : 8,</span><br><span class="line">     &quot;avg_price&quot; : &#123;</span><br><span class="line">       &quot;value&quot; : 26500.0</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;,</span><br><span class="line">   &quot;single_avg_price&quot; : &#123;</span><br><span class="line">     &quot;value&quot; : 27500.0</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>聚合也可以和过滤一起使用。比如这个语句查出大于15000销售额的平均值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">GET /test/test/_search</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    &quot;query&quot; : &#123;</span><br><span class="line">        &quot;constant_score&quot;: &#123;</span><br><span class="line">            &quot;filter&quot;: &#123;</span><br><span class="line">                &quot;range&quot;: &#123;</span><br><span class="line">                    &quot;price&quot;: &#123;</span><br><span class="line">                        &quot;gte&quot;: 15000</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;aggs&quot; : &#123;</span><br><span class="line">        &quot;single_avg_price&quot;: &#123;</span><br><span class="line">            &quot;avg&quot; : &#123; &quot;field&quot; : &quot;price&quot; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&quot;aggregations&quot; : &#123;</span><br><span class="line">    &quot;single_avg_price&quot; : &#123;</span><br><span class="line">      &quot;value&quot; : 31666.666666666668</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>过滤桶，对聚合结果过滤。</p>
<p>先选出ford厂商的车，然后在这个结果里面再进行过滤选出上个月的数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">GET /test/test/_search</span><br><span class="line">&#123;</span><br><span class="line">   &quot;size&quot; : 0,</span><br><span class="line">   &quot;query&quot;:&#123;</span><br><span class="line">      &quot;match&quot;: &#123;</span><br><span class="line">         &quot;make&quot;: &quot;ford&quot;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;,</span><br><span class="line">   &quot;aggs&quot;:&#123;</span><br><span class="line">      &quot;recent_sales&quot;: &#123;</span><br><span class="line">         &quot;filter&quot;: &#123; </span><br><span class="line">            &quot;range&quot;: &#123;</span><br><span class="line">               &quot;sold&quot;: &#123;</span><br><span class="line">                  &quot;from&quot;: &quot;now-1M&quot;</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;,</span><br><span class="line">         &quot;aggs&quot;: &#123;</span><br><span class="line">            &quot;average_price&quot;:&#123;</span><br><span class="line">               &quot;avg&quot;: &#123;</span><br><span class="line">                  &quot;field&quot;: &quot;price&quot; </span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有一种做法，先查询，然后聚合，再过滤一部分数据，这个过滤不能影响聚合。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">GET /test/test/_search</span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">    &quot;query&quot;: &#123;</span><br><span class="line">        &quot;match&quot;: &#123;</span><br><span class="line">            &quot;make&quot;: &quot;ford&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;post_filter&quot;: &#123;    </span><br><span class="line">        &quot;term&quot; : &#123;</span><br><span class="line">            &quot;color&quot; : &quot;green&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;aggs&quot; : &#123;</span><br><span class="line">        &quot;all_colors&quot;: &#123;</span><br><span class="line">            &quot;terms&quot; : &#123; &quot;field&quot; : &quot;color&quot; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的聚合可以不断嵌套聚合。从而组合成更加复杂的结果</p>
<p>排序的话，下面这个技巧很有意思，可以参考了解下，业务中很有可能用的到。</p>
<ul>
<li>先根据颜色分组，然后算出每一组的平均值，然后再根据平均值排序。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">GET /cars/transactions/_search</span><br><span class="line">&#123;</span><br><span class="line">    &quot;size&quot; : 0,</span><br><span class="line">    &quot;aggs&quot; : &#123;</span><br><span class="line">        &quot;colors&quot; : &#123;</span><br><span class="line">            &quot;terms&quot; : &#123;</span><br><span class="line">              &quot;field&quot; : &quot;color&quot;,</span><br><span class="line">              &quot;order&quot;: &#123;</span><br><span class="line">                &quot;avg_price&quot; : &quot;asc&quot; </span><br><span class="line">              &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;aggs&quot;: &#123;</span><br><span class="line">                &quot;avg_price&quot;: &#123;</span><br><span class="line">                    &quot;avg&quot;: &#123;&quot;field&quot;: &quot;price&quot;&#125; </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>统计唯一值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">GET /test/test/_search</span><br><span class="line">&#123;</span><br><span class="line">    &quot;size&quot; : 0,</span><br><span class="line">    &quot;aggs&quot; : &#123;</span><br><span class="line">        &quot;distinct_colors&quot; : &#123;</span><br><span class="line">            &quot;cardinality&quot; : &#123;</span><br><span class="line">              &quot;field&quot; : &quot;color&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个是统计颜色的种类，es使用了cardinality算法，也就是 <a href="http://static.googleusercontent.com/media/research.google.com/en//pubs/archive/40671.pdf" target="_blank" rel="noopener">HyperLogLog++</a> 算法做的，他不需要统计全部的数据，然后汇总计算，有误差，但是可以接受，性能可以。</p>
<p>如果统计唯一值得时候对速度要求很高，这块可以优化，参考：<a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/cardinality.html。就是给这些字段建立索引。" target="_blank" rel="noopener">https://www.elastic.co/guide/cn/elasticsearch/guide/current/cardinality.html。就是给这些字段建立索引。</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://skydh.github.io/2020/03/25/java/java线程，线程池，juc系列/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="skydh">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="learning, progress, future.">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/03/25/java/java线程，线程池，juc系列/" itemprop="url">java线程，线程池系列</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-25T21:01:40+08:00">
                2020-03-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="线程通信"><a href="#线程通信" class="headerlink" title="线程通信"></a>线程通信</h1><h2 id="wait-notify"><a href="#wait-notify" class="headerlink" title="wait,notify"></a>wait,notify</h2><p>   这2个方法，是Object类的方法，必须要先加锁才可以使用。顺序使用有要求</p>
<h2 id="park-unpark"><a href="#park-unpark" class="headerlink" title="park,unpark"></a>park,unpark</h2><p>   这2个方法，对顺序没有要求，但是不能加锁使用在同步代码块里面。LockSupport类的静态方法。</p>
<p>ps，这个方法的通信条件不要使用if来进行判断，可能出现伪唤醒。使用while来代替。</p>
<h2 id="线程池数量判断规则"><a href="#线程池数量判断规则" class="headerlink" title="线程池数量判断规则"></a>线程池数量判断规则</h2><p>   1.计算类任务<br>   cpu的1-2倍，比如cpu8核，那么16个线程<br>   2.io类任务<br>   因为有io阻塞，要大一点。最佳线程数量 = （（线程等待时间+线程CPU时间）／ 线程CPU时间）* CPU个数</p>
<p>   终极规则：<br>   看看你的cpu使用情况&gt;80%是比较合理的，不断调整</p>
<h2 id="线程加锁"><a href="#线程加锁" class="headerlink" title="线程加锁"></a>线程加锁</h2><p>  synchronized关键字加锁<br>  偏向锁 -轻量级锁-重量级锁，这是java虚拟机做的优化。</p>
<p>  第一个线程第一次加锁（通过偏向锁标识位），那么就会采用偏向锁的机制，修改对象头的标识位，将第一个线程的线程id加进去。<br>  当第二个线程访问这个对象时，判断是否偏向锁，是则第一步，不是则判断是否有线程持有锁，若是没有持有锁，那么cas操作尝试加锁，切将锁升级为轻量级锁，cas操作是，将加锁标识位修改，然后把markword里面的信息，存放到线程栈的私有信息里面去，将其替代为加锁线程的地址。若是有锁，那么自旋多次cas后，还是没有成功，则将其升级为重量级锁。<br>  总量级锁通过monitor来实现，每个对象都有一个monitor。<br>  monitor里面有entrylist,里面是争抢锁的。owner则是锁的持有者，waitset则是owner调用wait后进入的集合。通过notify进入到entrylist里面。</p>
<p>  lock api<br>  ReentrantLock：独享锁，可重入锁，支持公平和不公平<br>  ReadWriteLock:读写锁，其包含2把锁，创建这个读写锁对象后，我们可以通过这个对象获取到2把锁，一个读锁，一个写锁，读锁可以多个线程同时持有，写锁，一个线程持有，在加了读锁后，不能加写锁。（可以用这个特点去做锁降级）。</p>
<p>  aqs，本质上就是通过cas，链表，park,unpark来处理的。</p>
<p>  Semaphore,信号量，创建对象时，指定一个信号量。维护一个原子变量，有2个方法，一个是<br>  acquire：获取一个许可，没有就等待<br>  release:释放一个许可<br>  场景：代码限流，维护一个资源只被限定的线程数量访问<br>  CountDownLatch：到计数器，创建对象时，指定一个计数器。维护一个原子变量，有2个方法，一个是<br>  await():方法等待计数器变为0，在此之前，线程进入等待状态。<br>  countdown():方法使得计数器建一。<br>  场景：统计线程执行情况。看看哪些线程没有执行完。<br>   使用多个线程来计算数据，实现并发处理。<br>   多个线程相互通信。</p>
<p>  CyclicBarrier：线程栅栏。创建对象时，指定一个栅栏线程大小。<br> 。维护一个原子变量，同时可以加一个Runnable接口，作为满足条件后的执行的方法<br>  核心方法是<br>  await():线程调用await方法后，判断当前调用await方法的线程数目是否达到了创建对象所指定的数量，没有达到进入等待状态，达到了，执行后续的方法。<br>  和前面countdownlatch的区别是可以多次执行。每满足一次数量后，就会执行一次调用await方法线程的后续代码和Runnable接口的方法，可以多次</p>
<p>  场景：拼多多拼团购物。<br>   批量插入数据。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://skydh.github.io/2020/03/18/java/查看jvm运行时参数/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="skydh">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="learning, progress, future.">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/03/18/java/查看jvm运行时参数/" itemprop="url">查看jvm运行时参数</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-18T09:05:20+08:00">
                2020-03-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="PrintFlagsFinal"><a href="#PrintFlagsFinal" class="headerlink" title="PrintFlagsFinal"></a>PrintFlagsFinal</h1><p>   java -XX:+PrintFlagsFinal  -version<br>  查看虚拟机默认参数</p>
<h1 id="jps"><a href="#jps" class="headerlink" title="jps"></a>jps</h1><p>  专门查看java进程的<br>  jps<br>  jps -l查看完全参数</p>
<h1 id="jinfo"><a href="#jinfo" class="headerlink" title="jinfo"></a>jinfo</h1><p>  jinfo是查看运行时进程的详细信息。比如<br>  jinfo -flag MaxHeapSize 11956<br>  查看这个java进程的最大堆大小<br>  jinfo -flag UseG1GC  11956<br>  查看是否使用了G1垃圾回收器<br>  输出是XX:-UseG1GC，其中-表示没有使用</p>
<h1 id="jstat"><a href="#jstat" class="headerlink" title="jstat"></a>jstat</h1><p>  jstat查看jvm的统计信息<br>  类加载，垃圾回收信息，jit编译信息</p>
<pre><code>jstat -class 11956
Loaded  Bytes  Unloaded  Bytes     Time
28968 58273.9      301   462.6      39.13


jstat -gc 11956
S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT     GCT
512.0  1024.0  0.0    0.0   145920.0  2871.8   453120.0   246336.3  193100.0 179678.6 26240.0 21961.4   1578   12.603 1484   410.614  423.217
</code></pre><p>  S0C,S0U,S1U,S0U,s0,s1区的使用量和总量<br>  EC,EU：Eden区的总量和使用<br>  OC,OU,Old区的总量和使用<br>  MC，MU,Metaspace区总量和使用，其中这个metaspace是存放Class对象的。<br>  CCSC,CCSU,压缩类空间总量和使用。<br>  YGC,YGCT，YoungGC的次数和时间<br>  FGC,FGCT：FullGC的次数和时间<br>  GCT，总GC的时间。</p>
<p>ps 通过官网 <a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/jstat.html#BEHHGFAE来查询" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/technotes/tools/unix/jstat.html#BEHHGFAE来查询</a></p>
<h1 id="如何导出内存镜像文件"><a href="#如何导出内存镜像文件" class="headerlink" title="如何导出内存镜像文件"></a>如何导出内存镜像文件</h1><p>  1，内存溢出是自动导出，加上2个参数<br>  -XX:+HeapDumpOnOutOfMemoryError<br>  -XX:HeapDumpPath=./<br>  2,Jmap导出<br>  jmap -dump:format=b,file=heap.hprof 11956<br>  导出的文件用mat打开，可以查看到对象的数量和大小。可以分析内存溢出的问题。</p>
<h1 id="jstack"><a href="#jstack" class="headerlink" title="jstack"></a>jstack</h1><p>   打印jvm里面所有的线程，看看cpu暴增的原因之类的。java线程的状态有new,runnable,blocked,waiting,timed_waiting,terminated,<br>  cpu飙高，可能是死循环。或者死锁。cpu过大可能导致新的请求无法处理。<br>  方案：<br>  1，查看cpu那个进程高。<em>ps auxw | head -1;ps auxw |sort -rn -k3 |head -11</em><br>  2，打印jstack 11569 -&gt;11.txt.<br>  3,top -p 7792 -H,打印所有的线程。找出高的线程，然后将其从10进制转换为16进制，得到一个id<br>  4，在打印的文件里面找到这个id对应的线程，然后分析。具体代码。</p>
<p>  deadlock。</p>
<h1 id="JVisuaIVM"><a href="#JVisuaIVM" class="headerlink" title="JVisuaIVM"></a>JVisuaIVM</h1><p>  可视化监控工具，可以监控远程和本地。<br>  里面有很多功能，和jstack,jmap类似，几乎包含了上面所有的命令以及mat,里面有个抽样的功能，</p>
<p>   其中cpu抽样，可以看到哪个方法的执行时间。从而针对性的优化代码</p>
<p>   内存抽样，可以看到每个类占用的内存实例数等信息。可以看到那些对象可能导致内存泄漏。</p>
<h1 id="Btrace"><a href="#Btrace" class="headerlink" title="Btrace"></a>Btrace</h1><p>  在程序不重启，正在运行的时候修改动态的修改字节码。<br>  下载btrace，然后加入到环境变量，写好脚本，然后执行 btrace pid 脚本，执行完，字节码就加入到运行的环境里面了。只要是java代码都可以拦截。</p>
<p>  参数，返回值，异常都可以获取到，还可以判断某一行代码是否执行</p>
<p>  注意点：1.只能本地执行。不能远程使用。<br>         2.修改了字节码，退出时不会回复</p>
<h1 id="tomcat"><a href="#tomcat" class="headerlink" title="tomcat"></a>tomcat</h1><p>  1,tomcat远程debug<br>  基于JDWP协议，定义了调试器和java虚拟机之间的协议。<br>  主要是修改服务器上tomcat的配置，然后调试。如果是个普通的java进程需要修改这个java进程的启动脚本，加上一些配置。</p>
<p>  2.tomcat-manager<br>   tomcat自带的，还是修改tomact配置，增加用户，增加配置。可以查看tomcat很多信息，比如有哪些应用。且对其进行处理。查看线程信息之类的。以及线程处理时间之类的。</p>
<p>  3.psi-probe<br>  先下载probe这个项目源码，然后打包，将其war包放入到tomcat的webapp下面，即可，启动tomcat即可。tomcat的配置和上面一样。</p>
<p>  4,tomcat优化<br>  1，内存优化<br>  2，线程优化<br>  主要需要配置maxConnections最大连接数。acceptCount：连接满了之后的新的连接进入队列，超出队列，则拒绝请求。maxThread:工作线程数，和cpu相关…<br>  3.配置优化<br>  autoDeploy,周期性检查是否有新的应用加了进来，但是会浪费一个线程资源。默认为true，建议为false.<br>  enableLookups:开启后会对请求做一个dns查询，浪费性能。<br>  reloadable:监控web-inf/classes和web-inf/lib目录，浪费性能。默认没有开启。<br>  还有设置协议为nio,<br>  还可以禁用session，存到redis里面。</p>
<h1 id="nginx"><a href="#nginx" class="headerlink" title="nginx"></a>nginx</h1><p>   可以通过ngxtop,动态查看访问最多的ip,访问最多的返回码等信息。<br>   Mginx-rrd是个图形化工具，这个工具统计的信息可能滞后，因为它是通过定时器来统计的。<br>   优化：<br>   增加工作线程，增加并发连接数，默认是一个工作线程，1024个连接。<br>   一般多少个cpu，就多少个工作线程，启用epoll网络模型。<br>   启用长连接。浏览器和nginx之间是有长连接的，但是Nginx和后端服务之间是没有长连接的，需要配置。<br>   启用缓存，压缩。<br>   操作系统优化。</p>
<h1 id="jvm调优"><a href="#jvm调优" class="headerlink" title="jvm调优"></a>jvm调优</h1><p>运行时数据区（这是一个规范）</p>
<p>jvm内存结构<br>程序计数器：这个就是线程私有的，存放的是线程正在执行指令的地址。<br>java虚拟机栈：线程私有的，生命周期和线程一样，里面的元素是栈帧，每一个栈帧的入栈到出栈意味着一个方法的执行调用和结束。栈帧存放的是方法的局部变量表，返回值信息，方法出口灯<br>java堆，分为新生代，老年代，线程共享的，每一个实例都是在堆里面分配内存的。<br>java方法区，线程公有的，存放，常量。被虚拟机加载的类信息，编译器编译后的代码。（运行时常量池：各种常量信息，在类加载后放进去存放。）</p>
<p>上面的是java虚拟机规范的jvm内存结构</p>
<p>下面是实际的jvm内存结构（实现）</p>
<p>堆：和上面的一样</p>
<p>非堆区（metaspace）</p>
<p>存放字节码文件，class，package,method,常量池，符号引用。</p>
<p>ccs：压缩类空间，只有你启用了这个才会存在（java堆中每个对象都有一个指针指向自己的Class,因为在64位虚拟机下面，每个指针64位长度，为了压缩，采用32位，那么数据就会存到ccs里面）</p>
<p>codeCache：jit即时编译的代码，jvm执行的本地代码。如果没有采用jit，没有使用native方法，那么就是空的。</p>
<p>ps：java本地代码，就是采用编译方式启动java进程，然后代码会被jit编译为机器码，放入到metaspace里面</p>
<p>判断对象是否回收的算法<br>可达性分析算法，从根节点到这个对象是否可达。<br>根节点很多：类加载器，Thread，虚拟机栈的本地变量表，常量应用，垃圾回收的时候，通过这些根节点来进行可达性分析。</p>
<p>垃圾回收算法<br> 标记-清除：做可达性分析之后，标记所有可回收的对象，标记完成后统一回收。缺点效率不高，产生大量内存碎片。<br>复制算法，吧内存划分为大小一样的2块，每次使用其中一块，当其中一块无法分配内存后，进行垃圾回收，吧可达的对象复制到另外一块上，再把这块用的空间一次性清除。<br>优点，简单高效<br>缺点，内存利用不高<br>标记-整理。先判断哪些对象是可达的，然后统一向一端移动，然后清除掉边界外单位内存<br>相对于标记清除，少了内存碎片，但是更加耗时。</p>
<p>一般来说，yong区使用复制算法，old区采用标记清除或者标记整理算法。</p>
<p>对象分配：<br>对象优先分配到Eden区，大对象直接到老年代，存活时间长的对象进入老年代。</p>
<p>垃圾回收器<br>串行收集器Serial:Serial,Serial Old，单线程的垃圾回收器。当内存不够时，虚拟机会启动一个单线程的垃圾回收器。<br>并行收集器Parallel: Prallel Scavenge,Parallel Old,吞吐量优先<br>并行：指多条垃圾回收线程并行工作，用户线程仍然处于等待状态。适合科学计算，后台处理等弱交互场景，</p>
<p>并发收集器Concurrent:CMS,G1,停顿时间短优先。</p>
<p>并发：指多条垃圾回收线程和用户线程并行，也许是交替进行，垃圾回收的时候不会停止用户程序的运行，适合web，对相应时间有要求的应用</p>
<p>停顿时间：垃圾收集器做垃圾回收中断应用执行的时间。XX:MaxGCPauseMillis</p>
<p>吞吐量：花在垃圾回收的时间和花在应用时间的占比-XXGCRimeRatio=<n>,垃圾收集时间栈：1/1+n</n></p>
<p>-XX:+UseSerialGX -XX:+UseSerialOldGC<br>使用串行，一般不使用</p>
<p>-XX:+UseParallelGC,-XX:+UseParallelGC<br>使用并行，吞吐量优先<br>Server模式下默认收集器。cms是old区的，</p>
<p>并发<br>CMS:XX:+UseConcMarkSweepGC -XX:+UseParNewGC<br>G1:-XX+UseG1GC</p>
<p>由于虚拟机采用分带算法<br>new               old<br>Serial             SerialOld<br>parNew             SerialOld<br>ParaLLelScavenge   SerialOld<br>Serial             CMS<br>ParNew             CMS<br>G1                 G1</p>
<p>其中CMS可能退化为SerialOld,在担保分配空间失败后</p>
<p>如何选择垃圾回收器</p>
<p>1.调整堆的大小让服务器自己选择<br>2.如果内存小于100，串行<br>3，如果单核，且没有停顿时间的要求，串行或者jvm自己选。<br>4，如果允许停止时间超过一秒，选择并行或者jvm自己选。<br>5，响应时间很重要，不能超过一秒，使用并发垃圾回收器。</p>
<p>使用并行垃圾回收器，<br>-XX:+UseParallelGC手动开启<br>-XX：ParallelGCThread=<n>,多少个GC线程。<br>cpu&gt;=8 N=5<br>Cpu&lt;8 N=CPU</n></p>
<p>并行垃圾回收器有个自适应的特性。内存不够了会自动变大。<br>因此一般不使用。</p>
<p>CMS并发<br>低停顿，低延迟<br>老年代</p>
<p>收集过程。<br>1，初始标记，标记GCroot，这个过程需要停止应用程序。<br>2，并发标记。<br>3，并发预处理<br>4，重新标记，也是需要停止应用的，<br>5，并发清除<br>6，并发重置 </p>
<p>缺点，cpu敏感，浮动垃圾，空间碎片。标记清除算法。</p>
<p>CMS参数优化<br>-XX:ConcGCThreads,并发的GC线程数<br>-XX:+UseCMSCompactAtFullCollection：fullGC之后会做压缩，减少内存碎片。<br>可视化GC日志分析工具<br>-XX:CMSFullGCsBeforCompaction:多少次FullGC之后压缩一次。<br>-XX:CMSInitiatingOccupancyFraction:触发FullGC,老年代空间使用了多少比例后会触发这个fullGC，92%<br>-XX：+CMSScavengeBeforRemark:fullGC之前先做YGC。</p>
<p>G1垃圾回收器<br>大内存，小停顿，同时是新生代和老年代。<br>G1里面没有物理意义的新生代和老年代，他是一个个的region，多个region构成了逻辑上的新生代和老年代。<br>StaB,GC开始的时候存活对象的快照。<br>RSet：记录了其他region里面引用了本region对象的关系。<br>G1 YoungGC<br>新生代进入Eden区<br>存活对象进入su区<br>存活时间长的对象进入Old区。<br>和其他一样</p>
<p>没有fuLLGC 只有MixedGC<br>回收Young区和部分Old区。不是回收全部的old区。</p>
<p>global concurent marking（全局标记）<br>1,标记GC root,stw<br>2，标记存活Region<br>3.标记存活对象。<br>4.重新标记，stw<br>5.部分stw</p>
<p>根据参数来设定，InitiatingHeapOccupancyPercent,默认45%，就会触发global concurent marking</p>
<p>G1HeapWastePercent默认5%。<br>再global concurent marking之后，我们可以判断有多少对象需要回收，也就是说要判断要回收的对象是否超过了5%，如果超过了就要回收。在每次YGC之后和Mixed GC之前，会检查参数是否达到了这个值，如果达到了就会MixedGC</p>
<p>是否需要切换到G1<br>1.50%堆被存活对象占用<br>2，对象分配速度快<br>3，垃圾回收时间长</p>
<p>GC日志简析<br>1吞吐量（应用线程时间和总时间的比例）和停顿时间</p>
<p>通过工具分析<br>1.在线 gceasy.io<br>2.GCViewer</p>
<p>具体的分析都可以在orcal官网查看<br>首先要打印gc日志，输入一些参数，会让gc的时候把文件打印出来。在线工具更加方便</p>
<p>ParallelGC调优原则<br>1.不要设置最大对内存<br>2.优先设置吞吐量目标<br>3.吞吐量达不到要求，调大最大内存，不要让os使用swap，如果还达不到降低吞吐量。<br>4.吞吐量能达到，GC时间长，设置停顿时间目标</p>
<p>就是不断尝试。分析gc次数。 </p>
<p>G1最佳实践<br>1.年轻代：避免使用-XMn,-XX：NewRatio,等显示设置young区大小，会覆盖暂停时间目标。<br>2.暂停时间目标：不要太苛刻，其吞吐量目标是90%的应用时间和10%的垃圾回收时间，太严格影响吞吐量。<br>3.MixGC</p>
<p>分析gC的原因。</p>
<h1 id="字节码"><a href="#字节码" class="headerlink" title="字节码"></a>字节码</h1><p>1，先编译一个java文件，生成class文件<br>2，找到其所在的目录<br>3，执行 javap -verbose aaa.class-&gt;test1.txt</p>
<h1 id="intern区别"><a href="#intern区别" class="headerlink" title="intern区别"></a>intern区别</h1><p>1.6  常量池没有，加进去，有，不管<br>1.7 常量池没有，加个指向堆对象的引用。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://skydh.github.io/2019/12/26/spring/spring常用注解/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="skydh">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="learning, progress, future.">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/26/spring/spring常用注解/" itemprop="url">spring常用注解</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-12-26T14:00:28+08:00">
                2019-12-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="lazy"><a href="#lazy" class="headerlink" title="@lazy"></a>@lazy</h1><p>　　这个注解和spring 单例结合使用，当你需要用这个bean时才会去选择创建。</p>
<h1 id="Configuration"><a href="#Configuration" class="headerlink" title="@Configuration"></a>@Configuration</h1><p>　　这个类似于我们之前的bean配置文件，在里面，我们通过@Bean注解注入bean到bena容器</p>
<h1 id="Conditional"><a href="#Conditional" class="headerlink" title="@Conditional"></a>@Conditional</h1><p>　　这个注解，按照条件来注入bean。这个注解里面有个参数，就是一个Conditional接口数组，里面有个方法返回布尔。</p>
<h1 id="import"><a href="#import" class="headerlink" title="@import"></a>@import</h1><p>　　里面有个参数是Class数组，如果是普通的类直接注入进去，如果是实现了ImportSelector接口的，则将实现这个接口方法的返回值注入进去，实现这个接口注入的bean的id都是类全限定名。第三个就是实现了ImportBeanDefinitionRegistrar接口的bean,在这个方法里面可以主动注册bean到bean容器里面。</p>
<h1 id="factorybean"><a href="#factorybean" class="headerlink" title="factorybean"></a>factorybean</h1><p>　　这个bean比较特殊，这类bean是实现了factorybean接口的类，里面有个getObject方法，当我们尝试将这个bean获取的时候，返回的对象是其getObject方法返回的对象。如果要获取这个bean本身，那么我们调用getBean时，需要加个&amp;符号就可以了</p>
<h1 id="bean的生命周期"><a href="#bean的生命周期" class="headerlink" title="bean的生命周期"></a>bean的生命周期</h1><p>　　生命周期为bean的创建，bean的初始化，bean的销毁。初始化方法是在对象初始化装配结束后执行的。<br>　　我们可以在在@Bean注解上面指定初始化方法和销毁方法这个方法必须在你的bean定义里面。bean的销毁是在容器关闭的时候进行，初始化则是在容器创建后执行。<br>　　或者实现InitializingBean,DisposableBean方法来实现初始化和销毁方法。<br>　　或者通过注解@PostConstruct ,@Predestroy放到类对应方法上。<br>　　或者通过接口BeanPostProcessor有2和方法，第一个方法，是在初始化方法调用执行前执行，一个是初始化执行后调用。将这个实现了这个接口的方法加入到bean，就可以在所有的bean的初始化方法调用前后执行。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://skydh.github.io/2019/12/03/java/java 并发001/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="skydh">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="learning, progress, future.">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/03/java/java 并发001/" itemprop="url">java 并发001</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-12-03T18:36:54+08:00">
                2019-12-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="CSA原理"><a href="#CSA原理" class="headerlink" title="CSA原理"></a>CSA原理</h2><p>　　CAS,(Compare-And-Swap,比较和替换)。其具有三个操作数：内存地址V，旧的预期值A，新的预期值B。当V中的值和A相同时，则用新值B替换V中的值，否则不执行更新。（PS：上述的操作是原子性的，因为过程是：要么执行更新，要么不更新），这个操作是CPU内部执行的，是原子的。类sun.misc.Unsafe提供了大量cas操作的方法。</p>
<h2 id="不同类型的锁"><a href="#不同类型的锁" class="headerlink" title="不同类型的锁"></a>不同类型的锁</h2><h3 id="阻塞锁"><a href="#阻塞锁" class="headerlink" title="阻塞锁"></a>阻塞锁</h3><p>　　让线程进入阻塞状态，等待唤醒信号，唤醒后才可以进入到就绪状态，通过竞争，进入运行状态。支持阻塞锁的方法有，synchronized关键字，ReentrantLock的lock和unlock方法，以及Object类的wait和notify方法。</p>
<h2 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h2><p>　　当一个线程获取锁时，但是锁被其他线程获取了，该线程就不断自循环来不断获取锁。</p>
<h2 id="非公平锁"><a href="#非公平锁" class="headerlink" title="非公平锁"></a>非公平锁</h2><p>　　１．当有线程竞争锁时，该线程会优先尝试获得锁，这对那些已经在队列等待的线程来说不公平，这就是不公平锁，但是会极大的提高性能。如果没有获取到锁，那么就会添加到对列尾部。</p>
<h2 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h2><p>　　AQS核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制AQS是用CLH队列锁实现的，即将暂时获取不到锁的线程加入到队列中。CLH(Craig,Landin,and Hagersten)队列是一个虚拟的双向队列（虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系）。AQS是将每条请求共享资源的线程封装成一个CLH锁队列的一个结点（Node）来实现锁的分配。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://skydh.github.io/2019/11/14/kafka/深入理解kafka客户端/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="skydh">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="learning, progress, future.">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/11/14/kafka/深入理解kafka客户端/" itemprop="url">深入理解kafka客户端</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-11-14T15:24:53+08:00">
                2019-11-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>#　分区分配策略</p>
<h2 id="RangeAssignor"><a href="#RangeAssignor" class="headerlink" title="RangeAssignor"></a>RangeAssignor</h2><p>　　默认策略，先把这个消费组的消费者按照字典排序。然后主题的分区数目均匀分布到消费者上面，无法均匀的话，字典顺序靠前的多一点。缺点就是可能不均匀</p>
<h2 id="RoundRobinAssignor"><a href="#RoundRobinAssignor" class="headerlink" title="RoundRobinAssignor"></a>RoundRobinAssignor</h2><p>　　还是先把消费者和消费者订阅的分区按照字典排序，然后轮训的方式一个一个分配节点，相对前面的来说解决了均匀问题，但是在订阅不均匀的情况下，分配可能极度不均匀。</p>
<h2 id="StickAssignor"><a href="#StickAssignor" class="headerlink" title="StickAssignor"></a>StickAssignor</h2><p>　　前期和RoundRobinAssignor一样，后期则是不一样，发生变化时，RoundRobinAssignor是全部重新弄，StickAssignor则是更具当前的重新进行分配。相对RoundRobinAssignor做了优化，尽量减少了变动。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/13/">13</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">skydh</p>
              <p class="site-description motion-element" itemprop="description">skydh</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">126</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            

          </nav>

          

          <div class="links-of-author motion-element">
            
          </div>

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">skydh</span>

  
</div>


<div class="powered-by">
<i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv">
  本站访客数:<span id="busuanzi_value_site_uv"></span>
</span>
</div>

  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.3</div>




        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.3"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
